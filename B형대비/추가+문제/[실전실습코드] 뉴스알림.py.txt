import heapq

MAX_USER = 500
MAX_CHANNEL = 500
MAX_NEWS = 30000

class News:
    def __init__(self, _newsId=0, _channelId=0, _time=0):
        self.newsId = _newsId
        self.chnnelId = _channelId
        self.time = _time
        self.isDeleted = False

    # time이 낮을수록, newId가 낮을수록 우선순위 큼
    def __lt__(self, other):
        if self.time != other.time:
            return self.time < other.time
        else:
            return self.newsId < other.newsId

# 초기화
def init(N, K):
    global newsPool, newsIndex
    global channelArr, userArr, newsArr, notiPQ
    global cMapper, uMapper, nMapper
    global cIndex, uIndex, nIndex

    newsPool = [News() for _ in range(MAX_NEWS)]
    newsIndex = 0

    channelArr = [[] for _ in range(MAX_CHANNEL + 1)]   # key: 채널ID, value: 해당 채널을 구독하고 있는 유저ID리스트
    userArr = [[] for _ in range(MAX_USER + 1)]         # key: 유저ID, value: 해당 유저가 받은 뉴스들
    newsArr = [None for _ in range(MAX_NEWS + 1)]       # key: 뉴스ID, value: 해당 뉴스 저장
    notiPQ = []     # 보낼 뉴스들 저장(시간 낮은 뉴스 우선)

    # 1~10억 범위를 배열 인덱스로 매핑
    cMapper = {}
    uMapper = {}
    nMapper = {}
    cIndex = 0
    uIndex = 0
    nIndex = 0

# time까지 보내야할 뉴스들 보내기
def sendNews(time):
    while len(notiPQ) > 0:
        if notiPQ[0].time > time:
            return

        news = notiPQ[0]
        heapq.heappop(notiPQ)

        # 삭제된 뉴스인 경우
        if news.isDeleted:
            continue

        # 해당 채널을 구독하고 있는 유저들에게 뉴스 보내기
        userList = channelArr[news.channelId]
        for i in userList:
            userArr[i].append(news)

# 유저가 채널을 구독
def registerUser(mTime, mUID, mNum, mChannelIDs):
    global uIndex, cIndex

    sendNews(mTime)

    if mUID not in uMapper:
        uIndex += 1
        uMapper[mUID] = uIndex
    userID = uMapper[mUID]

    # 각 채널 구독자 목록에 해당 유저 추가
    for i in range(mNum):
        if mChannelIDs[i] not in cMapper:
            cIndex += 1
            cMapper[mChannelIDs[i]] = cIndex
        channelId = cMapper[mChannelIDs[i]]

        channelArr[channelId].append(userID)

# 뉴스 등록
def offerNews(mTime, mNewsID, mDelay, mChannelID):
    global nIndex, newsIndex

    nIndex += 1
    nID = nMapper[mNewsID] = nIndex
    channelID = cMapper[mChannelID]

    # 뉴스 생성 후 뉴스 등록
    newsIndex += 1
    newNews = newsPool[newsIndex]
    newNews.newsId = mNewsID
    newNews.channelId = channelID
    newNews.time = mTime + mDelay
    newNews.isDeleted = False

    heapq.heappush(notiPQ, newNews)
    newsArr[nID] = newNews

    return len(channelArr[channelID])

# 뉴스 취소
def cancelNews(mTime, mNewsID):
    sendNews(mTime)

    nID = nMapper[mNewsID]

    # 삭제 표시
    newsArr[nID].isDeleted = True

# 유저가 받은 뉴스 확인
def checkUser(mTime, mUID, mRetIDs):
    sendNews(mTime)

    uID = uMapper[mUID]

    # list의 뒤에서부터는 최신 뉴스가 쌓여있다
    newsList = userArr[uID]

    total = len(newsList)
    cnt = 0 # 받은 뉴스 카운트

    while total > 0:
        news = newsList[total - 1]

        # 삭제된 뉴스인 경우
        if news.isDeleted:
            total -= 1
            continue

        # 최신 뉴스 최대 3개 저장
        if cnt < 3:
            mRetIDs[cnt] = news.newsId

        total -= 1
        cnt += 1

    # 유저가 받았던 뉴스 초기화
    userArr[uID] = []
    return cnt