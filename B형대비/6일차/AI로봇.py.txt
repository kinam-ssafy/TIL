MAXN = 50001
MAXM = 50001
MAXK = 200001

class Robot:
    def __init__(self, rID=0, IQ=0, wID=0, begin=0, broken=False, maxidx=0, minidx=0):
        self.rID = rID      # 로봇의 아이디
        self.IQ = IQ        # 지능
        self.wID = wID      # 일하고 있는 작업 번호
        self.begin = begin  # 일을 시작한 시각
        self.broken = broken    # 고장 여부
        self.maxidx = maxidx    # maxHeap 에서의 위치 기억
        self.minidx = minidx    # minHeap 에서의 위치 기억

class Job:  # 작업 객체
    def __init__(self, arr=[], n=0):
        self.arr = arr  # 투입된 로봇 정보
        self.n = n

def getRobot(n):
    global mm

    ret = mem[mm:mm + n]
    mm += n

    return ret

def max_set(a, idx):
    a.maxidx = idx

def max_comp(a, b):
    if a.IQ != b.IQ:
        return a.IQ < b.IQ
    else:
        return a.rID > b.rID

def min_set(a, idx):
    a.minidx = idx

def min_comp(a, b):
    if a.IQ != b.IQ:
        return a.IQ > b.IQ
    else:
        return a.rID > b.rID

class Que:      # 쉬는 로봇들을 담는 자료구조
    def __init__(self, arr=[], size=0, set=min_set, comp=min_comp):
        self.arr = arr
        self.size = size
        self.set = set
        self.comp = comp

    def init(self):
        self.size = 0

    def init(self, n, heapifed):
        for i in range(n):
            self.arr.append(heapifed[i + 1])
            self.set(self.arr[i], i)

        self.size = n

    def push(self, v):
        self.arr[self.size] = v
        self.set(self.arr[self.size], self.size)

        cur = self.size
        self.size += 1

        while cur > 0:
            par = (cur - 1) // 2
            if self.comp(self.arr[cur], self.arr[par]):
                break

            self.arr[cur], self.arr[par] = self.arr[par], self.arr[cur]
            self.set(self.arr[cur], cur)
            self.set(self.arr[par], par)
            cur = par

    def pop(self):
        if self.size == 0:
            return None

        ret = self.arr[0]
        self.size -= 1
        self.arr[0] = self.arr[self.size]
        self.set(self.arr[0], 0)

        cur = 0
        while cur * 2 + 1 < self.size:
            child = cur * 2 + 2 if (cur * 2 + 2 < self.size and self.comp(self.arr[cur * 2 + 1], self.arr[cur * 2 + 2])) else cur * 2 + 1
            if self.comp(self.arr[child], self.arr[cur]):
                break

            self.arr[cur], self.arr[child] = self.arr[child], self.arr[cur]
            self.set(self.arr[cur], cur)
            self.set(self.arr[child], child)
            cur = child

        return ret

    def remove(self, idx):
        if idx >= self.size:
            return

        self.size -= 1
        self.arr[idx] = self.arr[self.size]
        self.set(self.arr[self.size], idx)

        cur = idx
        while cur * 2 + 1 < self.size:
            child = cur * 2 + 2 if (cur * 2 + 2 < self.size and self.comp(self.arr[cur * 2 + 1], self.arr[cur * 2 + 2])) else cur * 2 + 1
            if self.comp(self.arr[child], self.arr[cur]):
                break
            self.arr[cur], self.arr[child] = self.arr[child], self.arr[cur]
            self.set(self.arr[cur], cur)
            self.set(self.arr[child], child)
            cur = child

        while cur > 0:
            par = (cur - 1) // 2
            if self.comp(self.arr[cur], self.arr[par]):
                break
            self.arr[cur], self.arr[par] = self.arr[par], self.arr[cur]
            self.set(self.arr[cur], cur)
            self.set(self.arr[par], par)
            cur = par


def init(N):    # 초기화
    global maxque, minque
    global jobs, mm, mem, robot

    jobs = [Job() for _ in range(MAXM)]     #  jobs[i] := i 번째 작업 정보
    mm = 0
    mem = [Robot() for _ in range(MAXK)]    # mem[i] := i 번째 로봇의 정보
    robot = [Robot(i, 0, 0, 0, False) for i in range(N + 1)]

    maxque = Que([], set=max_set, comp=max_comp)
    minque = Que([], set=min_set, comp=min_comp)

    maxque.init(N, robot)
    minque.init(N, robot)

def callJob(cTime, wID, mNum, mOpt):    # cTime 시간에 wID 작업으로 mNum대의 로봇을 투입한다. mOpt 기준에 맞게 한다.
    jobs[wID].arr = getRobot(mNum)
    jobs[wID].n = mNum

    ret = 0
    if mOpt == 0:   # 높은 지능을 우선으로
        cnt = 0
        while cnt < mNum:
            p = maxque.pop()    # 제일 높은 지능의 로봇을 선택

            # 작업에 로봇을 배정한다.
            p.wID = wID
            p.begin = cTime
            jobs[wID].arr[cnt] = p
            cnt += 1

            # 해당 로봇을 minque 에서도 제외한다.
            minque.remove(p.minidx)
            ret += p.rID
    else:   # 낮은 지능을 우선으로
        cnt = 0
        while cnt < mNum:
            p = minque.pop()    # 제일 낮은 지능의 로봇을 선택

            # 작업에 로봇을 배정한다.
            p.wID = wID
            p.begin = cTime
            jobs[wID].arr[cnt] = p
            cnt += 1

            # 해당 로봇을 maxque 에서도 제외한다.
            maxque.remove(p.maxidx)
            ret += p.rID

    return ret

def returnJob(cTime, wID):  # cTime 시간에 wID 작업에 있는 로봇들을 반환한다.
    n = jobs[wID].n
    for i in range(n):
        p = jobs[wID].arr[i]
        if p.broken or p.wID != wID:    # 로봇이 고장났거나, 다른 작업 중이면 무시한다. (Lazy return)
            continue

        # 작업 시간만큼 지능을 낮춘다.
        p.IQ -= cTime - p.begin
        p.wID = 0

        # 가용 로봇 집합에 반환시킨다.
        maxque.push(p)
        minque.push(p)

def broken(cTime, rID): # cTime 시간에 rID 로봇이 고장난다.
    if robot[rID].wID != 0: # 작업 중이라면, 작업을 취소하고 고장 처리한다.
        robot[rID].wID = 0
        robot[rID].broken = True

def repair(cTime, rID): # cTime 시간에 rID 로봇이 고쳐졌다.
    if robot[rID].broken:
        robot[rID].IQ = -cTime  # 로봇의 지능 지수를 -cTime 으로 처리한다.
        robot[rID].broken = False

        # 가용 로봇 집합에 반환시킨다.
        maxque.push(robot[rID])
        minque.push(robot[rID])

def check(cTime, rID):  # cTime 시간에 rID 로봇의 상황을 확인한다.
    if robot[rID].broken:   # 고장난 상태
        return 0
    elif robot[rID].wID != 0:   # 작업 중인 상태
        return -robot[rID].wID
    else:   # 그 외의 상태
        return cTime + robot[rID].IQ    # 깎인 지능에 흐른 시간을 더하면 원래 지능이 계산된다.