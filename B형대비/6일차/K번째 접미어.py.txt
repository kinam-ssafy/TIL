class Trie:
    def __init__(self, alphabet='\0'):
        self.alphabet = alphabet    # 이 정점으로 이동하는 알파벳
        self.isWordEnd = False      # 이 정점에서 끝나는 문자열이 존재하는 지 표현
        self.cnt = 0                # 이 정점을 root로 하는 subtree에 포함된 문자열 개수
        self.children = {}          # 각 문자에 대해 이동하는 다른 정점을 기억하는 Map

results = []

def dfs(trie, test_case):
    global K

    if K == 0:
        return

    if trie.isWordEnd:              # 해당 정점에서 끝나는 단어가 있다면
        K -= 1
        if K == 0:                  # 원하는 문자열에 도달했다면,
            result = "".join(results)
            print(f'#{test_case} {result}')

    for i in range(ord('a'), ord('z') + 1):     # 낮은 알파벳부터 하나씩 이동한다.
        c = chr(i)
        if c in trie.children:                  # 해당 알파벳으로 이동할 수 있다면,
            child = trie.children[c]
            if child.cnt < K:                   # 해당 정점으로 이동하더라도 K 개의 문자열보다 적은 개수의 문자열이 있다면,
                K -= child.cnt                  # 빠르게 해당 개수만큼 skip 한다.
                continue

            results.append(c)
            dfs(child, test_case)
            results.pop()

T = int(input())

for test_case in range(1, T + 1):
    head = Trie()
    K = int(input())
    words = input()
    length = len(words)

    if K > length:
        print(f'#{test_case} none')
        continue

    for i in range(length):             # i 번째 문자에서 시작하는 접미열을 Trie에 반영
        indexTrie = head

        for j in range(i, length):      # j 번째 문자로 이동하기
            alphabet = words[j]

            if alphabet not in indexTrie.children:          # 새로운 문자라면 정점 추가하기
                indexTrie.children[alphabet] = Trie()

            indexTrie = indexTrie.children[alphabet]
            indexTrie.cnt += 1                              # 하위 문자열 개수 증가

        indexTrie.isWordEnd = True

    dfs(head, test_case)