class Trie:
    def __init__(self, alphabet='\0'):
        self.alphabet = alphabet    # 이 정점으로 이동하는 알파벳
        self.isWordEnd = False      # 이 정점에서 끝나는 문자열이 존재하는 지 표현
        self.cnt = 0                # 이 정점을 root로 하는 subtree에 포함된 문자열 개수
        self.children = {}          # 각 문자에 대해 이동하는 다른 정점을 기억하는 Map

results = []

def insert(words, idx, trie):
    # words[idx] 번 문자를 trie에 삽입
    if idx == len(words):
        return 0

    alphabet = words[idx]

    subCnt = 0  # 이번에 새로 추가된 T의 개수
    if alphabet not in trie.children:
        newTrie = Trie(alphabet)
        newTrie.cnt = 1
        subCnt = 1
        trie.children[alphabet] = newTrie

    subCnt += insert(words, idx + 1, trie.children[alphabet])
    trie.cnt += subCnt

    return subCnt

def dfs(trie, test_case):
    global K

    if K == 0:
        return

    K -= 1
    if K == 0:      # 원하는 문자열에 도달했다면,
        result = ''.join(results)

        print(f'#{test_case} {result}')
        return

    for i in range(ord('a'), ord('z') + 1):     # 낮은 알파벳부터 하나씩 이동한다.
        if chr(i) in trie.children:             # 해당 알파벳으로 이동할 수 있다면,
            child = trie.children[chr(i)]
            if child.cnt < K:           # 해당 정점으로 이동하더라도 K 개의 문자열보다 적은 개수의 문자열이 있다면,
                K -= child.cnt          # 빠르게 해당 개수만큼 skip 한다.
                continue

            results.append(chr(i))
            dfs(trie.children[chr(i)], test_case)
            results.pop()

T = int(input())

for test_case in range(1, T + 1):
    head = Trie()

    K = int(input())
    K += 1

    words = input()
    length = len(words)
    for i in range(length):     # i : 부분문자열의 시작 위치
        insert(words, i, head)  # i에서 시작한 부분 문자열들을 삽입

    dfs(head, test_case)
    if K > 0:
        print(f'#{test_case} none')