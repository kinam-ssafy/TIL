/*
boj2015 - 수들의 합 4

문제
A[1], A[2], ..., A[N]의 N개의 정수가 저장되어 있는 배열이 있다. 
이 배열 A의 부분합이란 1 ≤ i ≤ j ≤ N인 정수 i와 j에 대해 A[i]부터 A[j]까지의 합을 말한다.

N과 A[1], A[2], ..., A[N]이 주어졌을 때, 이러한 N×(N+1)/2개의 부분합 중 합이 K인 것이 몇 개나 있는지를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 정수 N과 K가 주어진다. (1 ≤ N ≤ 200,000, |K| ≤ 2,000,000,000) 
N과 K 사이에는 빈칸이 하나 있다. 
둘째 줄에는 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 A[1], A[2], ..., A[N]의 순서로 주어진다. 
주어지는 정수의 절댓값은 10,000을 넘지 않는다.
*/

/*
N = 4, K = 0 :
2, -2, 2, -2 >> 4
배열 A를 이루는 N개의 정수(2, -2, 2, -2)
A[1] = 2
A[2] = -2
A[3] = 2
A[4] = -2

합이 K = 0인 것이 몇개나? > 부분합 구해보기,, 연속된 구간의 합
A[1] + A[2] = 0
A[2] + A[3] = 0
A[3] + A[4] = 0
A[1] + A[2] + A[3] + A[4] = 0

4개

1. 완전탐색 해보기? N이 200000까지인데 완탐 씹불가능
2. 백트래킹 DFS.... x 이런 문제에 쓰는게 아닌듯
3. DP? 되는지 안되는지 모름
4. 누적합을 이용하면 좋을거같음 << 이거부터 해보기

A[i] ~ A[j] 합 

K 범위 -20억 ~ 20억
K가 몇개? >> 카운터인가 뭔가 써보기

    A[i] ~ A[j]까지의 합 = 부분 합
    다르게 표현하면 
    (A[1] ~ A[j] 까지의 합) - (A[1] ~ A[i] 까지의 합) = 부분 합

*/


#include <iostream>
#include <algorithm>
#include <map> // counter 구현을 위한 라이브러리

using namespace std;

int N, K; // N개의 배열, 부분 합 K
int A[200001]; // A 배열
map<long long, int> cnt; // 누적합의 카운터배열

int main() { 
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> N >> K;

    long long sum = 0;
    long long ans = 0;

    cnt[0] = 1; // 

    for (int i = 1; i <= N; i++) {
        cin >> A[i];
    
        sum += A[i]; // 현재까지 누적합 = A[1] ~ A[j] 까지의 합에 해당

        // 현재까지 누적합 = 100, 부분 합 30이라고 가정
        // A[1]~A[i]의 합이 70인 것의 개수를 구해야함
        // A[1]~A[2]일수도있고 A[1]~A[4]일수도
        ans += cnt[sum - K]; // (A[1] ~ A[i] 까지의 합)의 개수

        cnt[sum]++;
    }

    cout << ans;


    return 0;
}