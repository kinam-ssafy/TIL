# -*- coding: utf-8 -*-
"""(과제-문제)_0-1_AI를_위한_Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DvTS1SqRQvd154e7fAt8CCecommU8Rnf

### **Content License Agreement**

<font color='red'><b>**WARNING**</b></font> : 본 자료는 삼성청년SW·AI아카데미의 컨텐츠 자산으로, 보안서약서에 의거하여 어떠한 사유로도 임의로 복사, 촬영, 녹음, 복제, 보관, 전송하거나 허가 받지 않은 저장매체를 이용한 보관, 제3자에게 누설, 공개 또는 사용하는 등의 무단 사용 및 불법 배포 시 법적 조치를 받을 수 있습니다.

### **Objectives**

1. **과제명**: AI를 위한 Python

2. **핵심 주제**
  - Python 클래스와 객체 지향 프로그래밍
  - `pandas`를 활용한 데이터 분석 및 가공
  - 조건문, 반복문, 그룹 연산 등 데이터 처리 로직 구현

3. **학습 목표**
  - 클래스와 메서드를 정의하고 인스턴스를 생성할 수 있다
  - 조건문과 반복문을 통해 데이터 필터링 및 흐름 제어를 구현할 수 있다
  - `pandas`의 `groupby`, `pivot`, `melt` 등을 활용해 데이터를 변환할 수 있다
  - 사용자 정의 메서드를 통해 객체의 상태를 출력하거나 조작할 수 있다
  - 실습 데이터를 기반으로 통계적 요약 및 시각화를 수행할 수 있다

4. **학습 개념**
  - **클래스(Class)**: 객체의 구조와 동작을 정의하는 Python의 핵심 문법
  - **groupby**: 특정 기준에 따라 데이터를 그룹화하여 집계하는 `pandas` 기능
  - **melt**: wide-format 데이터를 long-format으로 변환하는 데이터 정리 기법

5. **학습 방향**
  - 실습 구성 방식: 문제와 정답 코드가 병렬로 제공되며, 각 단계별로 TODO 영역을 채우며 학습자가 직접 구현
  - 참고 자료 및 도구: `pandas`, `seaborn` 라이브러리의 tips 데이터셋을 활용하며, Python의 클래스 문법과 데이터 분석 기법을 병행 학습
  - 단계별 구조:
    1. 클래스 기반 은행 시스템 구현
    2. Tips 데이터셋을 활용한 통계 분석
    3. `groupby`, `pivot`, `melt`, `apply` 등 다양한 pandas 기능 실습
    4. 조건 필터링 및 최고 팁 비율 고객 추출
    5. 실습 마무리 및 개념 정리

6. **데이터셋 개요 및 저작권 정보**
  - 데이터셋 명: Tips 데이터셋
  - 데이터셋 개요: 식사 인원, 총 금액(total_bill), 팁(tip), 성별(sex), 요일(day), 시간(time), 흡연 여부(smoker) 등의 정보를 담은 레스토랑 팁 관련 데이터셋
  - 데이터셋 저작권: seaborn 라이브러리에서 제공하는 공개 데이터셋으로, BSD 라이선스에 따라 자유롭게 사용 가능

### **Prerequisites**
```
pandas>=2.0
seaborn==0.13.2
```

# 1. 간단한 은행 시스템 구축하기

- **학습 목표**: 실습시간에 배운 기초적인 Python을 복습하는 시간을 가져봅니다.
- **학습 개념**:
  - 클래스와 인스턴스 생성의 이해
  - 메서드 정의 및 호출
  - 조건문, 반복문을 활용한 흐름 제어
  - 문자열, 정수, 리스트 등 기본 자료형 활용
  - Python의 매직 메서드(`__str__`, `__repr__`) 사용
- **진행하는 실습 요약**: 사용자는 본인의 계좌를 하나 만들고, 입출금, 잔액 조회, 입출금 내역 조회 등의 기능을 수행할 수 있습니다. 또한 `print(계좌)`를 하면 계좌 정보가 보기 좋게 출력되도록 `__str__` 메서드를 오버라이딩해야 합니다.
"""

# 문제 코드
class BankAccount:
    """은행 계좌 클래스
    Attributes:
        owner (str): 계좌 소유자 이름
        balance (int): 계좌 잔액
        history (list): 거래 내역 리스트
    """
    def __init__(self, owner: str, balance: int = 0):
        # TODO
        # - owner와 balance를 클래스 변수에 저장하고, 거래 내역(history)을 빈 리스트로 초기화하세요.
        self.owner = owner
        self.balance = balance
        self.history = []


    def deposit(self, amount: int):
        # TODO
        # - 금액이 0보다 작거나 같으면 입금할 수 없다는 메시지를 출력하세요.
        if amount <= 0:
          print("금액이 0보다 커야 입금 가능합니다.")
          return
        # - 금액이 올바르다면 잔액(balance)을 증가시키고, "입금: {금액}원"을 거래 내역에 추가하세요.
        self.balance += amount # 잔액 증가
        self.history.append(f"입금: {amount}원") # 거래 내역 추가

        # - 입금이 완료되면 입금 완료 메시지를 출력하세요.
        print(f"입금 완료")


    def withdraw(self, amount: int):
        # TODO
        # - 금액이 0보다 작거나 같으면 출금할 수 없다는 메시지를 출력하세요.
        if amount <= 0:
          print("출금 금액은 0원 보다 커야 합니다.")
        # - 출금 금액이 잔액보다 크면 잔액 부족 메시지를 출력하세요.
        if amount > self.balance:
          print("잔액이 부족합니다.")
        # - 출금이 가능하면 잔액(balance)을 감소시키고, "출금: {금액}원"을 거래 내역에 추가하세요.
        if amount <= self.balance:
          self.balance -= amount
          self.history.append(f"출금: {amount}원")
        # - 출금이 완료되면 출금 완료 메시지를 출력하세요.
        print(f"{amount}원이 출금되었습니다.")


    def show_balance(self):
        # TODO
        # - 메소드 실행시 현재 잔액을 "현재 잔액: {balance}원" 형식으로 출력하세요.
        print(f"현재 잔액: {self.balance}원")


    def get_transaction_history(self) -> list:
        # TODO:
        # - 거래 내역이 없으면 "거래 내역이 없습니다."를 출력하세요.
        if not self.history:
          print("거래 내역이 없습니다.")
        # - 거래 내역이 있다면 각 내역을 줄 단위로 출력하세요.
        else:
          for i in self.history:
            print(i)
        # - 거래 내역 리스트를 return 하세요.
        return self.history


    def __str__(self):
        # TODO
        # - 계좌 정보를 보기 좋게 출력할 수 있도록 문자열을 리턴하세요.
        # - 예: "[계좌 소유자: Alice, 잔액: 10000원]"
        return f"[계좌 소유자: {self.owner}, 잔액: {self.balance}원]"

"""아래 코드는 여러분이 코드를 잘 짰는지 확인하는 코드입니다. 수정없이 사용해주세요 :)"""

# 테스트용 계좌 생성
account = BankAccount("TestUser", 10000)

# 입금 테스트
account.deposit(5000)
assert account.balance == 15000, "입금 후 잔액이 올바르지 않음"
assert account.history[-1] == "입금: 5000원", "입금 내역이 기록되지 않음"

# 출금 테스트
account.withdraw(3000)
assert account.balance == 12000, "출금 후 잔액이 올바르지 않음"
assert account.history[-1] == "출금: 3000원", "출금 내역이 기록되지 않음"

# 출금 초과 테스트
account.withdraw(20000)  # 잔액보다 많음
assert account.balance == 12000, "출금 실패 시 잔액이 변하면 안 됨"

# 거래 내역 확인
history = account.get_transaction_history()
assert len(history) == 2 or "출금: 20000원" not in history, "잘못된 거래 내역 포함됨"

# __str__ 출력 테스트
output = str(account)
assert "TestUser" in output and "12000" in output, "__str__ 출력 형식이 잘못됨"

print("✅ 모든 테스트 통과")

# 테스트용 계좌 생성
account = BankAccount("TestUser", 10000)

# 입금 테스트
account.deposit(5000)
assert account.balance == 15000, "입금 후 잔액이 올바르지 않음"
assert account.history[-1] == "입금: 5000원", "입금 내역이 기록되지 않음"

# 출금 테스트
account.withdraw(3000)
assert account.balance == 12000, "출금 후 잔액이 올바르지 않음"
assert account.history[-1] == "출금: 3000원", "출금 내역이 기록되지 않음"

# 출금 초과 테스트
account.withdraw(20000)  # 잔액보다 많음
assert account.balance == 12000, "출금 실패 시 잔액이 변하면 안 됨"

# 거래 내역 확인
history = account.get_transaction_history()
assert len(history) == 2 or "출금: 20000원" not in history, "잘못된 거래 내역 포함됨"

# __str__ 출력 테스트
output = str(account)
assert "TestUser" in output and "12000" in output, "__str__ 출력 형식이 잘못됨"

print("✅ 모든 테스트 통과")

"""# 2. 월별 판매 데이터 분석 및 가공"""

import seaborn as sns
import pandas as pd

df = sns.load_dataset('tips')
df.head()

"""### 1. 💰 성별 및 요일별 평균 팁 금액을 구하세요 (`groupby`, `pivot` 활용)
  - `groupby`를 사용해 성별(sex)과 요일(day)에 따라 팁 평균 계산
  - 결과를 `pivot`을 사용해 테이블 형태로 재구성 (행: 성별, 열: 요일)

출력예시:
```python
# pivot_table
day	       Thur	     Fri     	Sat	     Sun
sex
Male	  2.980333	2.693000	3.083898	3.220345
Female	2.575625	2.781111	2.801786	3.367222
```
"""

# 문제 코드
# TODO: groupby + pivot을 사용하여 성별/요일별 평균 팁을 표로 출력하세요.

pivot_table = pd.pivot_table(df, values='tip', index='sex', columns='day', aggfunc='mean')
pivot_table.info()
'''
df: 피벗 테이블을 생성할 DataFrame을 지정
values='tip': 피벗 테이블의 "값"으로 사용할 컬럼을 지정
index='sex': 피벗 테이블의 "행(index)"으로 사용할 컬럼을 지정
columns='day': 피벗 테이블의 "열(columns)"으로 사용할 컬럼을 지정
aggfunc='mean': values로 지정된 컬럼의 값들을 어떻게 "집계(aggregate)"할 것인지를 지정
aggfunc에는 'sum', 'count', 'max', 'min' 등 다양한 집계 함수를 사용
'''

grouped = df.groupby(['sex', 'day'])['tip'].mean().reset_index().pivot(index='sex', columns='day', values='tip')
grouped.info()
'''
grouped = df.groupby(['sex', 'day']) : 'sex'와 'day' 컬럼을 기준으로 데이터를 그룹화
['tip'].mean() : 그룹화된 데이터에서 'tip' 컬럼의 평균을 계산
reset_index() : 그룹화된 데이터의 인덱스를 초기화
pivot(index='sex', columns='day', values='tip') : 결과를 피벗 테이블 형태로 변환
'''
# reset_index() 이거 왜 필요한지? 없이 실행하면??
# df.groupby(['sex', 'day'])['tip'].mean().pivot(index='sex', columns='day', values='tip')
# AttributeError: 'Series' object has no attribute 'pivot'
# 타입: Series (1차원 데이터)
# 인덱스는 컬럼이 아니라서 pivot에서 사용 불가
# pivot()은 DataFrame의 메서드이고, 컬럼 이름이 필요
# reset_index() 하면 타입: DataFrame (2차원 테이블)로 바뀜
# sex, day가 이제 일반 컬럼, 인덱스도 0, 1, 2....로 초기화


''' 그런데 인덱스면 그냥 원래 0, 1, 2 이런식으로 진행되는거 아닌가..
찾아보니 pandas의 인덱스는 "위치"가 아니라 "이름표(라벨)"이라고 함
내가 알던 python의 인덱스와 pandas의 인덱스는 완전히 다른 개념인듯
'''


# 테스트 코드
assert isinstance(pivot_table, pd.DataFrame), "pivot_table은 DataFrame이어야 합니다."
assert 'Sun' in pivot_table.columns, "요일 열이 포함되어야 합니다."
assert 'Female' in pivot_table.index, "성별 인덱스가 포함되어야 합니다."
print("✅ 모든 테스트 통과")

"""### 2. 📉 팁 비율 컬럼 추가 (tip_percent)
  - `apply` 또는 단순 연산을 사용하여, `tip_percent = tip / total_bill` 컬럼을 생성하세요
"""

# 문제 코드
# TODO: `df`에 `tip_percent`라는 열을 추가해주세요!
# 단순 연산
df['tip_percent'] = df['tip'] / df['total_bill']
df.info()

# apply 사용
df['tip_percent'] = df.apply(lambda row: row['tip'] / row['total_bill'], axis=1)
df.info()

# 단순연산이 빠르고 단순한 코딩 가능해서 좋다고 함. apply는 왜 있지 그럼?
# 조건이 복잡한 경우 apply가 좋다고 함

'''# 단순 연산으로는 불가능
df['grade'] = # 어떻게...?

# ✅ apply로 해결
def get_grade(row):
    if row['tip_percent'] >= 0.2 and row['total_bill'] > 30:
        return 'VIP'
    elif row['tip_percent'] >= 0.15:
        return 'Good'
    elif row['day'] == 'Sun' and row['time'] == 'Dinner':
        return 'Special'
    else:
        return 'Normal'

df['grade'] = df.apply(get_grade, axis=1)'''


# 테스트 코드
assert 'tip_percent' in df.columns, "tip_percent 컬럼이 존재해야 합니다."
assert df['tip_percent'].between(0, 1).all(), "tip_percent 값은 0과 1 사이여야 합니다."
print("✅ 모든 테스트 통과")

"""### 3. 🧠 조건문 필터링: 팁 비율이 20% 이상인 경우만 필터링하세요.
1. 2번에서 만든 `tip_percent`가 0.2 이상인 행만 추출하여 `high_tippers`라는 새로운 DataFrame에 저장하세요.
2.	결과에는 팁 비율이 20% 미만인 행이 없어야 합니다.
"""

# 문제 코드
# TODO: tip_percent를 활용하여 high_tippers를 만들어주세요!
high_tippers = df[df['tip_percent'] >= 0.2]
high_tippers.info()


# 테스트 코드
assert not high_tippers.empty, "tip_percent >= 0.2인 데이터가 있어야 합니다."
assert (high_tippers['tip_percent'] >= 0.2).all(), "모든 행의 tip_percent가 0.2 이상이어야 합니다."
print("✅ 모든 테스트 통과")

"""### 4. 🍽️ `melt` 연습: 식사 인원별(total_bill과 tip)의 long-format 변환

#### 🧠 개념 설명: Wide-format vs Long-format

📌 Wide-format (넓은 형식)
  - 여러 개의 측정값/변수가 각각 열(column)로 표현됨
  - 읽기는 편하지만, `groupby`나 시각화에 비효율적
  - 예시 (Wide-format):
```python
size   total_bill    tip
   2           16.99   1.01
   3           10.34   1.66
```

📌 Long-format (길게 늘어진 형식)
  - 측정 항목을 하나의 열(item)에 모으고, 값은 별도 열(amount)로 표현
  - `groupby`, `pivot`, 시각화 등에 유용하게 사용
  - 예시 (Long-format):
```python
size        item   amount
   2     total_bill    16.99
   2            tip     1.01
   3     total_bill    10.34
   3            tip     1.66
```


#### 요구사항
1.	`tips` DataFrame에서 `total_bill`, `tip` 컬럼만 녹이세요.
2.	`size` 컬럼은 그대로 유지되도록 `id_vars=['size']`를 사용하세요.
3.	다음 컬럼을 가진 결과를 만들어야 합니다: `['size', 'item', 'amount']`

출력예시
```python
    size	      item	amount
0	  2	total_bill	16.99
1	  3	total_bill	10.34
2	  3	total_bill	21.01
3	  2	total_bill	23.68
4	  4	total_bill	24.59
...
483	3	       tip 	5.92
484	2	       tip 	2.00
485	2	       tip 	2.00
486	2	       tip 	1.75
487	2	       tip 	3.00
```
"""

# 정답코드
# TODO: 위의 요구사항을 만족하는 melted DataFrame을 만들어주세요!
melted = df.melt(
    id_vars=['size'],                 # 유지할 컬럼 (그대로 둠)
    value_vars=['total_bill', 'tip'], # 녹일 컬럼들 (세로로 쌓을 것)
    var_name='item',                  # 녹인 컬럼 이름들이 들어갈 새 컬럼명
    value_name='amount'               # 녹인 컬럼의 값들이 들어갈 새 컬럼명
)
melted.info()


# 테스트 코드
assert 'item' in melted.columns, "'item' 컬럼이 존재해야 합니다."
assert 'amount' in melted.columns, "'amount' 컬럼이 존재해야 합니다."
assert set(melted['item'].unique()) == {'total_bill', 'tip'}, "'item' 컬럼 값이 total_bill과 tip이어야 합니다."
print("✅ 모든 테스트 통과")

"""### 5. 📊 size별 평균 팁 비율 구하기 (`groupby` + `apply` 조합도 OK)
1.	`size` 컬럼을 기준으로 `tip_percent`의 평균을 계산하세요.
2.	`size=1`부터 `size=6`까지 평균 비율이 나와야 합니다.


출력결과 예시
```python
       tip_percent
size
1	     0.217292
2	     0.165719
3	     0.152157
4	     0.145949
5	     0.141495
6	     0.156229
Name: tip_percent, dtype: float64
```
"""

# 문제 코드
# TODO: size별 tip_percent의 평균을 구하여 size_group에 저장하세요!
size_group = df.groupby('size')['tip_percent'].mean()
size_group.info()

# 그룹바이와 apply 같이 쓰기
size_group = df.groupby('size')['tip_percent'].apply(lambda x: x.mean())
size_group.info()


# 테스트 코드
assert isinstance(size_group, pd.Series), "groupby 결과는 Series여야 합니다."
assert all(size_group.index >= 1), "size는 1 이상이어야 합니다."
assert size_group.between(0, 1).all(), "평균 tip_percent는 0과 1 사이여야 합니다."
print("✅ 모든 테스트 통과")

"""### 6. 🏆 최고 팁 비율을 기록한 고객의 정보 출력"""

# 문제 코드
# TODO: tip_percent가 최대인 고객을 모두 찾아 top_tipper에 저장하세요!
top_tipper = df[df['tip_percent'] == df['tip_percent'].max()]
top_tipper.info()


# 테스트 코드
assert len(top_tipper) >= 1, "최고 팁 비율 고객이 존재해야 합니다."
assert (top_tipper['tip_percent'] == df['tip_percent'].max()).all(), "tip_percent가 최댓값과 같아야 합니다."
print("✅ 모든 테스트 통과")

"""## 마치며

오늘은 기초적인 Python class를 응용하는 시간과 `pandas`의 조금 더 다양한 용례를 구현해보았습니다. `numpy`의 경우 후에 더 자세히 다루는 시간이 있어 이번 시간에는 `pandas`에 조금 더 집중하였습니다 :)

### Further Readings

- Pandas AI: The Generative AI Python Library PandasAI의 기본 개념과 실습 예제를 통해 자연어 질의로 데이터프레임을 다루는 원리를 익힐 수 있습니다. Pandas 코드 자동 생성 과정을 직접 경험하며, 수작업과 AI 보조 분석 간의 차이를 체험해 보세요.
  - https://www.geeksforgeeks.org/pandas/pandas-ai/

- Advanced Pandas Operations | Data Analysis with Python: 그룹 연산, 시간 시리즈 처리, 고급 인덱싱 등 Pandas의 심화 기능을 정리한 튜토리얼입니다. 과제에서 다루지 않은 기법들을 습득해 보다 복잡한 데이터 전처리·분석 작업에 도전해 보세요.
  - https://dynamicduniya.com/tutorials/data-science/data-analysis-with-python/advanced-pandas-operations

### Open-Ended Mission

- 고객 1인당 소비·팁 계산 및 분석
- `pd.cut`을 이용한 팁 비율 등급화 및 빈도 분석
"""