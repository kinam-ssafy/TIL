# -*- coding: utf-8 -*-
"""(실습-문제) 0-1_AI를_위한_Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17A68zvYXzJ92VspqdEbT8Y912ZuYcPd1

### **Content License Agreement**

<font color='red'><b>**WARNING**</b></font> : 본 자료는 삼성청년SW·AI아카데미의 컨텐츠 자산으로, 보안서약서에 의거하여 어떠한 사유로도 임의로 복사, 촬영, 녹음, 복제, 보관, 전송하거나 허가 받지 않은 저장매체를 이용한 보관, 제3자에게 누설, 공개 또는 사용하는 등의 무단 사용 및 불법 배포 시 법적 조치를 받을 수 있습니다.

### **Objectives**


1. 실습명: AI를 위한 Python

2. 핵심 주제
  - Python의 기본 자료형과 제어문 이해 및 활용
  - 함수, 클래스 등 객체지향 프로그래밍의 기초
  - 데이터 분석을 위한 NumPy & Pandas의 실전 활용

3. 학습 목표
  - 다양한 Python 자료형을 선언하고 조작할 수 있다
  - 조건문과 반복문을 활용해 흐름 제어 로직을 작성할 수 있다
  - 사용자 정의 함수와 클래스를 구현할 수 있다
  - NumPy와 Pandas를 활용해 데이터를 처리하고 분석할 수 있다
  - 실습을 통해 Python 문법과 라이브러리 사용에 익숙해질 수 있다

4. 학습 개념
  - `int`, `float`, `str`, `None`: Python의 기본 데이터 타입
  - `list`, `tuple`, `set`, `dict`: 컬렉션 자료형과 특징
  - `defaultdict`, `Counter`, `itertools`: 고급 내장 모듈 활용
  - List Comprehension: 반복문을 간결하게 표현하는 문법
  - `function`, `class`: 코드 재사용성과 구조화의 핵심
  - NumPy, Pandas: 대규모 데이터 처리 및 분석 도구

5. 학습 방향
  - 실습은 Python의 기초 문법부터 시작해 점차 객체지향과 데이터 분석으로 확장됩니다.
  - 각 섹션은 개념 설명 + 실습 코드 + 테스트 코드로 구성되어 있어 학습자 스스로 확인 가능합니다.
  - 공식 문서 및 PEP8 스타일 가이드를 참고하며, 실무에서 자주 쓰이는 패턴을 중심으로 구성하였습니다.
  - 실습은 단계별로 진행되며, 각 단계는 독립적으로 테스트 가능하도록 설계되었습니다.
  - Pandas 실습에서는 tips 데이터셋을 활용하며, 시각화와 통계 분석의 기초를 다집니다.

### **Prerequisites**
```
pandas>=2.0
seaborn==0.13.2
```

# 1. 기초 Python

- **학습 목표**: Python의 가장 기초적인 개념에 대해 학습합니다.
- **학습 개념**: Python에서 사용하는 자료형 (`int`, `float`, `str`, `list`, `dict`, `set`), 조건분/반복문 사용법, 함수 사용법
- **진행하는 실습 요약**: 기초적인 자료형의 인스턴스화 방법과 내장된 메소드를 직접 사용해봅니다.

## 1.1 `int`, `float`, `str`

🔢 int (정수형)
- 정수 값을 저장하는 자료형으로 Java의 int, long 등과 유사합니다.
"""

# Python은 크기 제한이 없습니다.
age = 30
print(f"정수형 예시: {age}, 타입: {type(age)}")

"""🔣 float (부동소수점형)
- 소수점을 포함한 숫자로 Java의 float, double과 유사합니다.
- Python은 기본적으로 `double` 정밀도를 가집니다.
"""

height = 175.5
print(f"부동소수점형 예시: {height}, 타입: {type(height)}")

"""🚫 None (값 없음)
- Java의 null과 유사합니다.
- 값이 없음을 명시적으로 표현합니다.
"""

nothing = None
print(f"None 타입 예시: {nothing}, 타입: {type(nothing)}")

"""☝️ 불리언형 (Booleans):
- Java의 boolean과 동일합니다.
- True 또는 False 값을 가집니다. (첫 글자는 대문자)
"""

is_student = True
print(f"불리언형 예시: {is_student}, 타입: {type(is_student)}")

"""### ⌨️ **실습 1**: `int`/`float`에 내장된 함수 사용해보기
다음의 코드에서 None에 해당하는 코드를 수정하여 결과를 만들어주세요.

예시)
```python
# 1. a에 1을 더해 a_1에 할당해주세요
a_1 = a + 1
```
"""

# 정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
a = -3.14159

# TODO: None 부분을 직접 채워보세요 :)
# 1. a의 절대값을 만들어서 `a_abs`에 할당해주세요.
a_abs = abs(a) # TODO
print(a_abs)
assert a_abs > 0, "절댓값이 양수가 아닙니다."

# 2. a를 반올림하여 `a_rounded`에 할당해주세요.
a_rounded = round(a) # TODO
print(a_rounded)
assert isinstance(a_rounded, int), "반올림 결과가 정수가 아닙니다."
assert a_rounded == -3, "반올림 결과가 올바르지 않습니다."

# 3. a의 제곱을 `a_squared`에 할당해주세요.
a_squared = a**2 # TODO
print(a_squared)
expected_squared = 9.869587728099999
tolerance = 1e-10
assert abs(a_squared - expected_squared) < tolerance, "제곱 결과가 예상값과 다릅니다."

# 4. a의 절댓값과 원주율 π를 비교하여 얼마나 가까운지 확인해주세요.
# 확인결과를 `is_close_to_pi`에 할당해주세요.
# 참고: https://docs.python.org/3/library/math.html#math.isclose
# is_close_to_pi: bool = None # TODO
# assert isinstance(is_close_to_pi, bool), "결과물이 boolean이 아닙니다."

print("✅ 모든 수치형 데이터 테스트 통과!")

"""📝 str (문자열형)
- 문자들의 집합으로 Java의 String과 유사합니다.
- 작은따옴표 ' ' 또는 큰따옴표 " " 모두 사용 가능합니다.
"""

name = "김철수"
greeting = '안녕하세요!'
print(f"문자열 예시1: {name}, 타입: {type(name)}")
print(f"문자열 예시2: {greeting}, 타입: {type(greeting)}")

"""### ⌨️ **실습 2**: `str`에 내장된 함수 사용해보기
지시 사항에 따라 다음 실습을 완성해주세요.
"""

s = "Hello World!"

# TODO
# 1. s를 소문자로 변환하여 `s_lower`에 할당해주세요.
s_lower = None
assert s_lower == "hello world!", "소문자 변환이 올바르지 않습니다."

# 2. s를 대문자로 변환하여 `s_upper`에 할당해주세요.
s_upper = None
assert s_upper == "HELLO WORLD!", "대문자 변환이 올바르지 않습니다."

# 3. s를 두 개 붙인 결과를 `s_double`에 할당해주세요.
s_double = None
assert s_double == "Hello World!Hello World!", "문자열 덧셈 결과가 다릅니다."

# 4. s가 !로 끝나는지 아닌지의 결과를 `ends_with_exclamation`에 할당해주세요.
# HINT: https://docs.python.org/3/library/stdtypes.html#str.endswith
ends_with_exclamation: bool = None
assert ends_with_exclamation is True, '"!"로 끝나지 않습니다.'

# 5. s가 int/float으로 변환 가능이 가능할까요? 가능여부를 `is_convertible`에 할당해주세요.
# https://docs.python.org/ko/3.13/library/stdtypes.html#str.isdigit
is_convertible: bool = None
assert isinstance(is_convertible, bool), "문자열이 숫자로 변환 가능하다고 잘못 판단했습니다."

print("✅ 모든 문자열 테스트 통과!")

"""### 📝 **참고**: Python은 변수 선언 시 타입을 명시하지 않습니다. (동적 타이핑)

**JAVA**
```java
Java: int count = 10;
```

**python**
```python
count = 10 # (변수에 할당되는 값에 따라 타입이 결정됩니다.)
```

**typehint**: 동적타이핑을 사용하다보니 변수가 어떤 자료형인지 헷갈릴 수 있습니다. 그래서 변수의 자료형을 알려주는 **typehint**를 사용하면 다른 개발자들과 협업할 때 아주 좋은 관례입니다.
```python
count: int = 10
```

## 1.2 `list`, `tuple`, `set`, `dict`

📋 List (리스트)
- 순서가 있고, 변경 가능한 자료형입니다.
- 다양한 타입의 데이터를 함께 저장 가능합니다.
"""

my_list = [1, 2, 'apple', True]
print(f"\n리스트 예시: {my_list}, 타입: {type(my_list)}")
print(f"리스트 첫 번째 요소: {my_list[0]}")
my_list.append('banana')
print(f"요소 추가 후 리스트: {my_list}")
print(f"리스트 길이: {len(my_list)}")

# 리스트 특정 값 포함 여부 확인
print(f"리스트에 'apple'이 있나요? {'apple' in my_list}")
print(f"리스트에 3이 있나요? {3 in my_list}")

# 리스트 이어 붙이기
l1 = [1, 2]
l2 = [3, 4]
combined = l1 + l2
print(f"리스트 이어 붙이기: {combined}")

# 리스트 슬라이싱
numbers = [10, 20, 30, 40, 50]
print(f"리스트 일부 추출 (1~3번째): {numbers[1:4]}")   # [20, 30, 40]

# 짝수 인덱스 추출
print(f"짝수 인덱스 요소들: {numbers[1::2]}")  # [20, 40]

"""### ⌨️ **실습 3**: `list`에 내장된 함수 사용해보기

None 부분을 지시사항에 맞춰 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)   
혹시 문제를 풀어보다가 막히면 [Python에서 제공하는 공식 List Documentation](https://docs.python.org/ko/3.13/tutorial/datastructures.html)을 확인해보세요.   
정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
"""

# 초기 리스트
l = [1, 2, 3, 4]

# TODO
# 1. l에는 몇 개의 원소가 들어있나요? `length`에 할당해주세요
length = None
assert length == 4

# 2. l에 1이 들어있나요? 1이 있는지 없는지 `has_1`에 할당해주세요.
has_1: bool = None
assert has_1 is True

# 3. l에 5가 들어있나요? 5가 있는지 없는지 `has_5`에 할당해주세요.
has_5: bool = None
assert has_5 is False

# 4. l을 이어붙일 수 있나요? (출력값: [1, 2, 3, 4, 1, 2, 3, 4])
# 이어 붙일 수 있다면 `doubled_l`에 할당해주세요.
doubled_l = None
assert doubled_l == [1, 2, 3, 4, 1, 2, 3, 4]

# 5. l에서 2, 3만 뽑아낸 `sublist_2_3`를 만들어주세요.
sublist_2_3 = None
assert sublist_2_3 == [2, 3]

# 6. l에서 짝수번째 배열만 있는 `even_indexed`를 만들어주세요.
even_indexed = None
assert even_indexed == [2, 4]

# 7. l에 j = [5, 6, 7, 8]을 이어붙여 l에 할당해주세요.
j = [5, 6, 7, 8]
assert l == [1, 2, 3, 4, 5, 6, 7, 8]

# 8. l 내에서 최대값과 최소값을 각각 `max_val`, `min_val`에 할당해주세요
max_val = None
min_val = None
assert max_val == 8
assert min_val == 1

# 9. l에는 1이 등장한 횟수를 `count_1`에 할당해주세요.
count_1 = None
assert count_1 == 1

# 10. l 내에서 3의 위치를 `index_3`에 할당해주세요.
index_3 = None
assert index_3 == 2

# 11. l에서 3을 지워보세요.
# 새로운 변수가 아닌 l 내에서 3을 지워보세요.
# TODO
assert 3 not in l

# 12. l에 다시 3을 같은 자리에 넣어보세요.
# TODO
assert l[2] == 3

# 13. l을 뒤집은 `reversed_l`을 만들어주세요.
reversed_l = None
assert reversed_l == [8, 7, 6, 5, 4, 3, 2, 1]

# 14. 위에서 뒤집은 l을 다시 뒤집어보세요.
assert l == [1, 2, 3, 4, 5, 6, 7, 8]

# 15. l의 맨 끝에 원소 5를 추가해보세요.
# TODO
assert l[-1] == 5
assert l.count(5) == 2

# 16. l의 모든 원소를 없애버리세요.
# TODO
assert l == []

print("✅ 모든 리스트 테스트 통과!")

"""📦 Tuple (튜플)
- 순서가 있지만, 변경 불가능한 자료형 (immutable) 입니다. 한 번 객체를 생성하면 구성요소를 바꿀 수 없습니다.
- 리스트보다 메모리 효율이 좋고, 안전한 데이터 저장에 적합합니다.
"""

my_tuple = (10, 20, 'cherry')
print(f"\n튜플 예시: {my_tuple}, 타입: {type(my_tuple)}")
print(f"튜플 두 번째 요소: {my_tuple[1]}")
# my_tuple.append(30) # 주석 해제 시 오류 발생: 'tuple' object has no attribute 'append'

"""### ⌨️ **실습 4**: `tuple`에 내장된 함수 사용해보기

None 부분을 지시사항에 맞춰 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)   
정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
"""

# 초기 튜플
t = (1, 2, 3, 4)

# TODO
# 1. t의 원소 개수를 `length`에 할당해주세요.
length = None
assert length == 4

# 2. t에 1이 들어있나요? 1이 있는지 없는지 `has_1`에 할당해주세요.
has_1 = None
assert has_1 is True

# 3. t에 5가 들어있나요? 5가 있는지 없는지 `has_5`에 할당해주세요.
has_5 = None
assert has_5 is False

# 4. t을 이어붙일 수 있나요? (출력값: [1, 2, 3, 4, 1, 2, 3, 4])
# 이어 붙일 수 있다면 `doubled_t`에 할당해주세요
doubled_t = None
assert doubled_t == (1, 2, 3, 4, 1, 2, 3, 4)

# 5. t 내의 2, 3만 가진 `subtuple_2_3`를 만들어주세요.
subtuple_2_3 = None
assert subtuple_2_3 == (2, 3)

# 6. t에 u = (5, 6, 7, 8)를 이어붙일 수 있나요? 아니면 새로운 변수에 할당해야하나요?
# 새로운 변수에 할당해야하면 `combined`에 할당해주세요.
u = (5, 6, 7, 8)
combined = None
assert combined == (1, 2, 3, 4, 5, 6, 7, 8)

# 7. t 내에서 최대값과 최소값을 각각 max_val, min_val에 할당해주세요.
max_val = None
min_val = None
assert max_val == 4
assert min_val == 1

# 8. t에 1이 등장한 횟수를 `count_1`에 할당해주세요.
count_1 = None
assert count_1 == 1

# 9. t 내에서 3의 위치를 할당해주세요.
index_3 = None
assert index_3 == 2

# 10. t에서 3을 지울 수 있나요? (불가능하므로 예외 처리)
try:
    t.remove(3)
    assert False, "튜플에서 remove가 작동하면 안 됩니다."
except AttributeError:
    pass  # 정상적으로 예외 발생

# 11. t을 뒤집은 결과를 `reversed_t`를 할당해주세요.
reversed_t = None
assert reversed_t == (4, 3, 2, 1)

print("✅ 모든 튜플 테스트 통과!")

"""🧮 Set (세트)
- 순서 없음, 중복 허용 안됩니다. Java의 HashSet과 유사합니다.
- 집합 연산에 유용: 합집합, 교집합, 차집합 등
"""

my_set = {1, 2, 3, 2, 1}
print(f"\n세트 예시: {my_set}, 타입: {type(my_set)}") # 중복이 제거됨을 확인
my_set.add(4)
print(f"요소 추가 후 세트: {my_set}")

"""### ⌨️ **실습 5**: `set`에 내장된 함수 사용해보기


None 부분을 지시사항에 맞춰 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)   
정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
"""

# 초기 집합
s = {1, 2, 3, 4}

# TODO
# 1. s의 원소수를 `length`에 할당해주세요.
length = None
assert length == 4

# 2. s에 1이 들어있나요? 1이 있는지 없는지 `has_1`에 할당해주세요.
has_1 = None
assert has_1 is True

# 3. s에 5가 들어있나요? 5가 있는지 없는지 `has_5`에 할당해주세요.
has_5 = None
assert has_5 is False

# 4. s을 이어붙일 수 있나요? (불가능 — 집합은 덧셈 연산 불가)
try:
    result = s + s
    assert False, "집합은 + 연산이 불가능해야 합니다."
except TypeError:
    pass  # 정상적으로 예외 발생

# 5. s에서 2, 3만 출력할 수 있나요? (인덱싱이 가능한가요?)
try:
    subset = s[1:3]
    assert False, "집합은 인덱싱이 불가능해야 합니다."
except TypeError:
    pass  # 정상적으로 예외 발생

# 6. s 내에서 최대값과 최소값을 각각 `max_val`, `min_val`에 할당해주세요.
max_val = None
min_val = None
assert max_val == 4
assert min_val == 1

# 7. s에서 3을 지울 수 있나요?
s = None
assert 3 not in s

s2 = {3, 4, 5, 6}
# 8. s와 s2의 교집합 `intersection`을 만들어주세요.
intersection = None
assert intersection == {4}

# 9. s와 s2의 합집합 `union`을 만들어주세요.
union = None
assert union == {1, 2, 3, 4, 5, 6}

# 10. s와 s2의 차집합(s - s2) `difference`를 만들어주세요.
difference = None
assert difference == {1, 2}

# 11. s와 s2의 대칭차집합 `symmetric_diff`를 만들어주세요.
symmetric_diff = None
assert symmetric_diff == {1, 2, 3, 5, 6}

print("✅ 모든 집합(set) 테스트 통과!")

"""🗂️ Dict (딕셔너리)
- 키-값 쌍으로 구성된 자료형으로 Java의 HashMap과 유사합니다.
- 순서 없음 (Python 3.7 이후부터는 삽입 순서 유지)
"""

my_dict = {'name': '김영희', 'age': 25, 'city': '서울'}
print(f"\n딕셔너리 예시: {my_dict}, 타입: {type(my_dict)}")
print(f"딕셔너리에서 'name' 키의 값: {my_dict['name']}")
my_dict['age'] = 26 # 값 변경
my_dict['job'] = '엔지니어' # 새 키-값 추가
print(f"수정 및 추가 후 딕셔너리: {my_dict}")

"""Python에는 `dict`에 부가적인 기능을 탑재한 빌트인 딕셔너리가 추가로 존재합니다. 자주 사용되는 두 가지 `dict`가 있는데 바로 `defaultdict`와 `Counter`입니다.
- **`defaultdict`**: 기본값을 지정할 수 있는 딕셔너리로,  키가 존재하지 않을 때 KeyError 대신 지정된 기본값을 자동으로 생성합니다.
- **`Counter`**: 리스트나 문자열 등 반복 가능한 객체의 요소 개수를 자동으로 세어주는 딕셔너리로 가장 많이 등장한 요소를 쉽게 파악할 수 있음.

"""

from collections import defaultdict, Counter

# defaultdict 예시
dd = defaultdict(int)
# 아직 `apple`이라는 key값에 해당하는 value를 만들어주지 않았으나
# += 1 연산이 가능함.
dd['apple'] += 1
dd['banana'] += 2
print("defaultdict 결과:", dict(dd))  # {'apple': 1, 'banana': 2}

# Counter 예시
fruits = ['apple', 'banana', 'apple', 'cheese', 'banana', 'banana']
counter = Counter(fruits)
print("Counter 결과:", dict(counter))  # {'apple': 2, 'banana': 3, 'cheese': 1}

"""### ⌨️ **실습 6**: `dict`에 내장된 함수 사용해보기

None 부분을 지시사항에 맞춰 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)   
정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
"""

# 초기 딕셔너리
d = {
    1: "apple",
    2: "banana",
    3: "cheese",
}

# 1. d에는 몇 개의 원소가 들어있나요?
length = None
assert length == 3

# 2. d의 key들을 list에 할당해주세요
keys = None
assert keys == [1, 2, 3]

# 3. d에 4라는 key가 있나요?
has_key_4 = None
assert has_key_4 is False

# 4. d[4]는 오류 없이 출력될 수 있을까요?
# 오류 없이 key가 존재하면 value를 반환하고, 없으면 None을 반환하는 방법
# https://docs.python.org/ko/3.13/library/stdtypes.html#dict.get
value_4 = None
assert value_4 is None

# 5. d와 d2를 합쳐보세요.
d2 = {
    4: "dragonfruit"
}
merged = None
assert merged == {
    1: "apple",
    2: "banana",
    3: "cheese",
    4: "dragonfruit"
}

print("✅ 모든 딕셔너리 테스트 통과!")

"""## 1.3 조건문/반복문 사용하기

`if`문의 가장 기본적인 사용방법은 다음과 같습니다.
`if`문 안에는 항상 `boolean`으로 해석 가능한 값이 들어가야합니다.
"""

score = 85

if score >= 90:
    print("학점: A")
elif score >= 80:
    print("학점: B")
elif score >= 70:
    print("학점: C")
else:
    print("학점: D")

# 논리 연산자 사용 예시
age = 20
has_card = True

if age >= 19 and has_card:
    print("입장 가능합니다.")
else:
    print("입장 불가능합니다.")

# for 루프: 순회 가능한(iterable) 객체의 요소를 하나씩 순회합니다.
# Java의 enhanced for loop (for-each)와 유사합니다.
fruits = ["apple", "banana", "cherry"]
print("\n--- 과일 목록 ---")
for fruit in fruits:
    print(fruit)

# range() 함수와 함께 사용하는 for 루프: 특정 횟수만큼 반복할 때 유용합니다.
# Java의 for (int i = 0; i < n; i++)와 유사합니다.
print("\n--- 0부터 4까지 출력 ---")
for i in range(5): # 0부터 4까지 (5는 포함 안됨)
    print(i)

print("\n--- 2부터 10까지 짝수 출력 ---")
for i in range(2, 11, 2): # 시작 값, 끝 값 (포함 안됨), 스텝
    print(i)

# while 루프: 조건이 True인 동안 반복합니다.
print("\n--- 카운트 다운 ---")
count = 5
while count > 0:
    print(count)
    count -= 1
print("발사!")

# break와 continue
print("\n--- break와 continue ---")
for i in range(10):
    if i == 3:
        continue # 현재 반복 건너뛰고 다음 반복으로
    if i == 7:
        break # 루프 완전히 종료
    print(i)

"""리스트 컴프리헨션 (List Comprehension)
- 반복문을 간결하게 표현하는 Python의 강력한 기능
- Java의 Stream API의 map, filter와 유사한 개념으로 볼 수 있습니다.
- 🌟굉장히 아주 자주 매우🌟 등장하기 때문에 익숙해져야합니다.
- https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
"""

print("\n--- 리스트 컴프리헨션 ---")
squares = [x**2 for x in range(10)]
print(f"0부터 9까지 제곱: {squares}")

even_numbers = [x for x in range(20) if x % 2 == 0]
print(f"0부터 19까지 짝수: {even_numbers}")

"""🔗 `itertools`: 반복을 더 강력하게!
itertools는 반복(iteration)을 더 유연하고 강력하게 만들어주는 파이썬 표준 라이브러리입니다. 특히 조합, 순열, 누적합 등 다양한 패턴을 쉽게 구현할 수 있어요.

🔧 주요 함수
- `product()`:	데카르트 곱 (중첩 반복)
- `permutations()`:	순열 생성
- `combinations()`:	조합 생성
- `accumulate()`:	누적합 계산
- `groupby()`:	조건에 따라 그룹화
"""

from itertools import product, permutations, combinations, accumulate

# product: 모든 조합 (중첩 반복)
print("\n--- product ---")
for p in product([1, 2], ['A', 'B']):
    print(p)

# permutations: 순열
print("\n--- permutations ---")
for p in permutations([1, 2, 3], 2):
    print(p)

# combinations: 조합
print("\n--- combinations ---")
for c in combinations([1, 2, 3], 2):
    print(c)

# accumulate: 누적합
print("\n--- accumulate ---")
import operator
nums = [1, 2, 3, 4]
print("누적합:", list(accumulate(nums)))
print("누적곱:", list(accumulate(nums, func=operator.mul)))

"""## 1.4 함수 사용하기 (function)"""

# 기본적인 함수 정의 및 호출
def greet():
  """간단한 환영 메시지를 출력하는 함수"""
  print("안녕하세요!")

greet() # 함수 호출

# 매개변수가 있는 함수
def greet_name(name):
  """이름을 받아 환영 메시지를 출력하는 함수"""
  print(f"안녕하세요, {name}님!")

greet_name(name="제니") # 매개변수 전달하여 호출

# 반환 값이 있는 함수
def add(a, b):
  """두 숫자를 더하고 결과를 반환하는 함수"""
  return a + b

result = add(a=5, b=3)
print(f"5 + 3 = {result}")

"""### 📝 **참고**: PEP

Python은 `;`을 사용하지 않고 tab을 기준으로 코드를 나누기 때문에 상대적으로 다른 프로그래밍 언어에 비해 작성 자유도가 높고 난이도가 낮은 편입니다. 그러다보니 개발자마다 작성하는 스타일이 달라 같은 언어임에도 불구하고 가독성이 배우 떨어질 대가 많습니다.

이를 방지하기 위해 Python 사용자들은 **Python Enhancement Proposals(PEP)**를 제안하였습니다. 여기에는 문법적으로는 오류가 없으나, 상대적인 가독성과 생산성을 위해 Python '권장' 작성요령이 담겨져 있습니다. 이 중 가독성 (Style Guide)를 중심으로 작성된 것이 PEP 8인데요, 참고하면 좋습니다.

다음은 제가 아주 자주 강조하는 사용자들이 지켰으면하는 세 가지 작성요령입니다.

#### 1. 띄어쓰기
```python
# ❌ 노우..
a=1
a+=1
x=a * 2-1

# 🙏 제발
a = 1
a += 1
x = a*2 - 1
```

#### 2. Line Break 위치
```python
# ❌ 노우..
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)

# 🙏 제발
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

#### 3. Keyword Arguments 사용하기
마주하는 함수가 도대체 무슨 함수인지도 모르겠는데 keyword argument를 작성하지 않으면 흐름을 이해하는데 시간이 걸립니다. 이를 단축시키기 위해 다음과 같은 사안을 권장합니다.

```python
def do_something(user_id, verbose):
  ...
  
# ❌ 노우..
do_something(42, True)

# 🙏 제발
do_something(user_id=42, verbose=True)
```
"""

# 기본 매개변수가 있는 함수
def greet_language(name, lang="Python"):
  """이름과 언어를 받아 환영 메시지를 출력하는 함수 (기본값 설정)"""
  print(f"{lang}을 사용하시는 {name}님, 안녕하세요!")

greet_language(name="KIM") # 기본 매개변수 사용
greet_language(name="CHOI", lang="Java") # 기본 매개변수 재정의

# 가변 인자 (*args) - Java의 varargs와 유사
def sum_all(*args):
  """모든 입력 숫자의 합계를 반환하는 함수"""
  total = 0
  for num in args:
    total += num
  return total

print(f"1, 2, 3의 합계: {sum_all(1, 2, 3)}")
print(f"1, 2, 3, 4, 5의 합계: {sum_all(1, 2, 3, 4, 5)}")

# 키워드 인자 (**kwargs)
def print_info(**kwargs):
  """키-값 쌍으로 정보를 받아 출력하는 함수"""
  for key, value in kwargs.items():
    print(f"{key}: {value}")

print_info(name="LEE", age=2, city="LA")

# 람다 함수 (Lambda Function) - 간단한 익명 함수
# Java의 람다 표현식과 유사
square = lambda x: x * x
print(f"5의 제곱 (람다 사용): {square(5)}")

# 중첩 함수 (Nested Function) 및 클로저 (Closure)
def outer_function(x):
  def inner_function(y):
    return x + y # 외부 함수의 변수 x에 접근

  return inner_function

add_five = outer_function(5)
print(f"5에 3을 더한 결과 (클로저 사용): {add_five(3)}")

# Docstring (함수 설명) - Java의 Javadoc과 유사
def multiply(a, b):
  """
  두 숫자를 곱하는 함수.

  Args:
    a: 첫 번째 숫자
    b: 두 번째 숫자

  Returns:
    두 숫자의 곱
  """
  return a * b

print(f"함수 설명 확인: {multiply.__doc__}")

"""### ⌨️ **실습 7**: 조건문/반복문/함수 응용해보기

**문자열 속 숫자 구하기**: 문자열이 주어졌을 때 문자열 안에 포함된 숫자를 합한 결과를 반환하는 함수를 만들어주세요.
"""

# 문자열 s에 포함된 모든 숫자(digit)를 더해서 반환하는 함수입니다.
# 예: "a1b2c3" → 1 + 2 + 3 = 6
# TODO: None 부분을 직접 채워보세요 :)
# 정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
def sum_of_digits_in_strnig(s: str) -> int:
    # 숫자인 문자만 골라서 정수로 변환한 뒤 모두 더하세요
    result = None  # TODO
    return result

assert sum_of_digits_in_strnig(s="123") == 6
assert sum_of_digits_in_strnig(s="a1b2c3") == 6
assert sum_of_digits_in_strnig(s="abc") == 0
print("✅ 모든 테스트를 통과했습니다!")

"""## 1.5 Python을 이용한 객체지향프로그래밍"""

# 클래스 정의
class Dog:
  # 생성자 (Java의 생성자와 유사)
  def __init__(self, name, breed):
    self.name = name # 인스턴스 변수 (속성)
    self.breed = breed

  # 메서드 (Java의 메서드와 유사)
  def bark(self):
    print(f"{self.name}가 멍멍 짖습니다!")

  def __str__(self):
    # 객체를 문자열로 표현할 때 사용 (Java의 toString()과 유사)
    return f"이름: {self.name}, 품종: {self.breed}"

# 객체 생성
my_dog = Dog(name="바둑이", breed="진돗개")

# 속성 접근
print(f"우리 강아지 이름: {my_dog.name}")
print(f"우리 강아지 품종: {my_dog.breed}")

# 메서드 호출
my_dog.bark()

# 객체 출력 (toString()과 유사)
print(my_dog)

# 상속 (Inheritance)
class Puppy(Dog):
  def __init__(self, name, breed, age):
    # 부모 클래스의 생성자 호출 (Java의 super()와 유사)
    super().__init__(name, breed)
    self.age = age

  # 메서드 오버라이딩 (Method Overriding)
  def bark(self):
    print(f"{self.name}가 낑낑거립니다!")

  def __str__(self):
    return f"이름: {self.name}, 품종: {self.breed}, 나이: {self.age}개월"

# 자식 클래스 객체 생성
my_puppy = Puppy(name="초코", breed="푸들", age=3)

# 상속된 메서드 및 오버라이딩된 메서드 호출
my_puppy.bark()
print(my_puppy)

# 캡슐화 (Encapsulation) - Python은 명시적인 private 키워드는 없지만, 관례적으로 변수 이름 앞에 `_` 또는 `__`를 붙여 내부적으로 사용함을 나타냅니다.
class BankAccount:
  def __init__(self, balance):
    self.__balance = balance # private 변수 (관례)

  def deposit(self, amount):
    if amount > 0:
      self.__balance += amount
      print(f"{amount}원 입금되었습니다. 현재 잔액: {self.__balance}")
    else:
      print("유효하지 않은 금액입니다.")

  def withdraw(self, amount):
    if amount > 0 and amount <= self.__balance:
      self.__balance -= amount
      print(f"{amount}원 출금되었습니다. 현재 잔액: {self.__balance}")
    else:
      print("잔액이 부족하거나 유효하지 않은 금액입니다.")

  def get_balance(self):
    return self.__balance

# 캡슐화 예시
account = BankAccount(balance=10000)
account.deposit(amount=5000)
account.withdraw(amount=2000)
# print(account.__balance) # 직접 접근은 어렵습니다 (Name mangling)
print(f"현재 잔액: {account.get_balance()}")

"""### ⌨️ **실습 8**: `class` 만들어보기

🎯 **목표**:   
Student 클래스를 활용하여 학생들의 점수 데이터를 분석합니다.

🧩 **문제 설명**:
클래스 정의
- Student 클래스는 다음 속성을 가집니다:
- 이름 (`name: str`)
- 국어 점수 (`korean: int`)
- 영어 점수 (`english: int`)
- 수학 점수 (`math: int`)
- `get_average()` 메서드를 통해 평균 점수를 계산할 수 있습니다.

요구사항
1.	함수: `check_pass(student: Student) -> str`
  - 	평균 점수가 75점 이상이면 "합격", 아니면 "불합격" 반환
2.	함수: `analyze_students(students: list[Student], threshold: int) -> tuple[list[str], list[str]]`
  - 모든 학생의 합격/불합격 여부를 분석
  - 총점이 threshold점 이상인 학생을 우수 학생으로 선정
  - 반환값: (합격자 이름 리스트, 우수 학생 이름 리스트)

"""

from typing import List, Tuple

# None 부분을 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)
# 정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
class Student:
    def __init__(self, name: str, korean: int, english: int, math: int) -> None:
        # 학생 이름과 과목별 점수를 저장합니다.
        return None

    def get_total(self) -> int:
        # 총점을 계산하는 메서드입니다.
        return None

    def get_average(self) -> float:
        # 평균 점수를 계산하는 메서드입니다.
        return None


def check_pass(student: Student) -> str:
    # 학생 평균 점수가 75점 이상이면 "합격", 아니면 "불합격"을 반환합니다.
    return None


def analyze_students(students: List[Student], threshold: int) -> Tuple[List[str], List[str]]:
    # 여러 학생 정보를 받아 합격자와 우수자를 분류합니다.
    # threshold 이상 총점을 받은 학생은 우수자로 간주합니다.
    return None


# 아래는 채점코드입니다.
# 수정하지말고 진행해주세요 :)
students: List[Student] = [
    Student(name="뷔", korean=90, english=95, math=100),   # 평균 95.0, 총점 285
    Student(name="정국", korean=60, english=70, math=65),  # 평균 65.0, 총점 195
    Student(name="지민", korean=80, english=90, math=85),  # 평균 85.0, 총점 255
    Student(name="슈가", korean=75, english=70, math=80),  # 평균 75.0, 총점 225
]

passed, excellent = analyze_students(students, threshold=250)

assert set(passed) == {"지민", "뷔", "슈가"}, "합격자 리스트 오류"
assert set(excellent) == {"지민", "뷔"}, "우수 학생 리스트 오류"
assert check_pass(students[1]) == "불합격", "불합격자 판별 오류"
assert check_pass(students[2]) == "합격", "합격자 판별 오류"

print("✅ 모든 테스트를 통과했습니다!")

"""### 📝 **참고**: 사실 모든 것은 객체다

Python의 모든 기본 자료형(int, str, list, dict 등)은 사실 클래스(class) 로 정의되어 있고, 그 내부에 정의된 특수 메서드들(소위 매직 메서드 또는 덧셈 연산자 오버로딩용 메서드)을 통해 우리가 사용하는 연산자나 함수가 동작하는 것입니다.

```python
print(type(10))        # <class 'int'>
print(type("hello"))   # <class 'str'>
print(type([1, 2, 3]))  # <class 'list'>
```

이처럼 int, str, list, dict, float 등은 전부 class로 정의되어 있으며, 우리가 사용하는 수많은 기능들은 그 내부의 특수한 메서드들을 통해 구현되어 있습니다.

🪄 Magic Method란?

매직 메서드(Magic Method) 또는 덧셈 연산자 오버로딩용 메서드는 이름 앞뒤에 __ (double underscore)를 붙인 Python 메서드들입니다. 예를 들어:
-	`__init__`: 생성자 (객체가 생성될 때 호출됨)
-	`__str__`: 문자열로 표현할 때 사용 (print 등)
-	`__add__`: + 연산자 동작을 정의
-	`__len__`: len() 함수 호출 시 동작
-	`__getitem__`: 인덱싱 (`obj[key]`|)
-	`__eq__`: == 연산자 오버라이딩

이런 매직 메서드들은 Python의 핵심 문법을 클래스 수준에서 재정의하거나 확장할 수 있게 해줍니다.

예시:
```python
a = 10
b = 5
print(a + b)            # 15
print(a.__add__(b))     # 15, 동일한 결과
```

Custom Class에 적용해보기
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # (4, 6)
```

이처럼 사실 모든 자료형 또한 객체라는 것을 알았습니다. 우리는 앞으로 python을 다양하게 활용하다보면 magic method를 생각보다 직접 짜서 사용하게 되는 경우들이 있습니다. 참고하면 좋은 [자료](https://docs.python.org/3/reference/datamodel.html#basic-customization)

# 2. 데이터 분석도구: NumPy & Pandas

**학습 목표**
  - NumPy를 활용해 다차원 배열을 생성하고 수치 연산을 수행할 수 있다.
  - Pandas를 이용해 데이터프레임을 생성하고, 필터링, 그룹화, 통계 분석 등의 기초적인 데이터 처리 작업을 수행할 수 있다.
  - 실습을 통해 데이터 분석에 필요한 핵심 라이브러리 사용법을 익힌다.

**학습 개념**:
  - NumPy: 대규모 수치 데이터를 빠르게 처리할 수 있는 배열 기반 라이브러리
  - Pandas: 표 형식의 데이터를 다루는 데 특화된 라이브러리
  
**진행하는 실습 요약**
  - `numpy` 배열 생성 및 기본연산
  - `pandas`의 기초적인 데이터 다루기 메소드 활용

## 2.1 `numpy`: 한 번에 많은 수를 다룰 수 있는 라이브러리
"""

import numpy as np

# Numpy의 기본: 배열 생성
arr = np.array([1, 2, 3, 4, 5])
print("1차원 배열:", arr)

# 다차원 배열 생성
arr2d = np.array([[10, 20, 30], [40, 50, 60]])
print("2차원 배열:\n", arr2d)

# 랜덤 정수 생성 (예: 50~100 사이 점수 5개)
random_scores = np.random.randint(low=50, high=101, size=5)
print("랜덤 점수 5개:", random_scores)

"""### ⌨️ **실습 9**: `numpy`와 친해지기 1

다음 요구사항에 맞춰 배열을 생성해주세요.
- None 부분을 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)   
- 정답을 확인하는 assert 코드는 수정하지말고 진행해주세요

"""

# 1. 3x3 단위행렬 x를 만들어주세요
import numpy as np

x = np.array([[1, 0, 0],
              [0, 1, 0],
              [0, 0, 1]])
assert x.shape == (3, 3)
assert np.array_equal(x, np.identity(3))
print(f"x : {x}")

x = np.identity(3)
assert x.shape == (3, 3)
assert np.array_equal(x, np.identity(3))
print(f"x : {x}")

x = np.eye(3)
assert x.shape == (3, 3)
assert np.array_equal(x, np.identity(3))
print(f"x : {x}")

# # 2. 표준정규분포로부터 추출된 숫자들의 배열 3x3 y를 만들어주세요
'''표준정규분포?
특징: 평균이 0, 표준 편차가 1
'''
# np.random.randn() : 표준정규분포로부터 무작위 표본 추출하여 배열을 생성하는 함수임

y = np.random.randn(3, 3)
assert y.shape == (3, 3)
print(f"y : {y}")

# 3. x의 1행 3열 원소를 1로 변경해주세요 (0-based index 기준)
x[0, 2] = 1
assert x[0, 2] == 1
print(f"x : {x}")

# 4. x와 y의 행렬곱인 z를 구해주세요
z = x @ y
assert z.shape == (3, 3)
print(f"z : {z}")

# 5. x를 복사하여 자료형을 bool로 변경한 x_bool을 만들어주세요
# astype() : NumPy 배열의 자료형 변경할 때 쓰는 메서드
x_bool = x.astype(bool)
assert x_bool.dtype == bool
print(f"x_bool : {x_bool}")

# 6. x를 복사하여 자료형을 int로 변경한 x_int를 만들어주세요
x_int = x.astype(int)
assert x_int.dtype == int
print(f"x_int : {x_int}")

# 7. x를 복사하여 1.1을 곱한 x_float을 만들어주세요
x_float = x * 1.1
assert np.allclose(x_float, x.astype(float) * 1.1)
print(f"x_float : {x_float}")

# 8. %whos Magic Command를 통해 변수목록 및 상세정보를 확인해보세요
# (Jupyter 또는 Colab 환경에서 아래 명령어를 셀에 단독으로 입력하세요)
# %whos

# Commented out IPython magic to ensure Python compatibility.
# %whos

"""### ⌨️ **실습 10**: `numpy`와 친해지기 2

다음 요구사항에 맞춰 배열을 생성해주세요.
- None 부분을 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)   
- 정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
"""

import numpy as np

# 1. 길이가 3이고 원소가 1, 2, 3을 포함하는 배열 v를 만들어주세요
v = np.array([1, 2, 3,])
assert v.shape == (3,)
assert np.array_equal(v, [1, 2, 3])
print(f" 1. v: {v}")

# 2. 벡터 v를 복제하여 만든 다음과 같은 행렬 V를 만들어주세요
# [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
# 행렬 복제할때는 np.tile(A, rpes) 사용.
# A : 반복하려는 배열
# reps : 횟수 또는 모양. 튜플 형태 (n_rows, n_cols)로 지정시 행, 열 방향으로 반복
V = np.tile(v, (3, 1))
assert V.shape == (3, 3)
assert np.array_equal(V, [[1, 2, 3], [1, 2, 3], [1, 2, 3]])
print(f" 2. V: {V}")

# 3. V를 일렬로 만들어 V_vector로 만들어주세요
V_vector = np.tile(v, 3)
assert V_vector.shape == (9,)
assert np.array_equal(V_vector, [1, 2, 3, 1, 2, 3, 1, 2, 3])
print(f" 3. V_vector: {V_vector}")

# 4. 0부터 2π까지 균등한 간격의 길이가 100인 배열 theta를 만들어주세요
# np.linspace(시작, 끝, 간격)
theta = np.linspace(0, 2 * np.pi, 100)
assert theta.shape == (100,)
assert np.isclose(theta[0], 0)
assert np.isclose(theta[-1], 2 * np.pi)
print(f" 4. theta: {theta}")

# 5. theta의 각 원소에 삼각함수 sin함수를 적용한 sin_theta 배열을 만들어주세요
sin_theta = np.sin(theta)
assert sin_theta.shape == (100,)
assert np.isclose(sin_theta[0], 0)
assert np.isclose(sin_theta[25], 1, atol=0.1)  # π/2 근처
print(f" 5. sin_theta: {sin_theta}")


# 다음 코드를 통해 시각화해보세요
import matplotlib.pyplot as plt
plt.plot(theta, sin_theta)
plt.title("Sine Curve")
plt.xlabel("θ (radians)")
plt.ylabel("sin(θ)")

"""## 2.2 `pandas`: 배열을 엑셀로!

Pandas는 Python에서 **표 형태(엑셀처럼)**의 데이터를 다루기 쉽게 해주는 데이터 분석 라이브러리입니다.
  - pan(el) + da(ta) → pandas
  - 구조화된 데이터를 생성, 탐색, 분석, 전처리하는 데 매우 유용
  - 엑셀, CSV, DB, 웹 등 다양한 형식과 연동 가능

오늘은 가장 기초적인 용례만 사용해보고, 추후 실습모듈 3에서 더 많이 배워볼 예정입니다!
"""

import pandas as pd

# 딕셔너리 기반으로 DataFrame 생성
data = {
    "Name": ["Alice", "Bob", "Charlie"],
    "Age": [25, 30, 35],
    "Score": [85.5, 90.3, 78.9]
}

df = pd.DataFrame(data)
df

# DataFrame: 2차원 표 구조
print("\n2. DataFrame 타입:", type(df))

# Series: DataFrame의 열 하나
age_series = df["Age"]
print("Series (Age):\n", age_series)
print("Series 타입:", type(age_series))

# Column 접근
print("\n3-1. Name 열:\n", df["Name"])

# Row 접근 by index (정수 위치 기반)
# iloc (integer-location based indexing): 이름에서 알 수 있듯이 정수 위치를 기반으로 데이터를 선택
print("\n3-2. 1번째 행 (iloc):\n", df.iloc[0])  # Alice

# Row 접근 by label (index label 기반, 지금은 숫자와 같음)
# loc (label-based indexing): 인덱스 레이블을 기반으로 데이터를 선택
print("\n3-3. 1번째 행 (loc):\n", df.loc[0])

# iloc는 "위치"로 접근하고, loc는 "이름" (레이블)으로 접근

# 여러 행/열 추출
print("\n3-4. Name과 Score 열만 추출:\n", df[["Name", "Score"]])

print("\n4-1. 요약 정보")
print(df.info())

'''RangeIndex: 3 entries, 0 to 2 >> DataFrame의 인덱스 정보

RangeIndex: 인덱스가 0부터 시작하여 순차적으로 증가하는 형태임을 의미
3 entries: DataFrame에 총 3개의 행이 있다는 뜻
0 to 2: 인덱스 범위가 0부터 2까지라는 것을 보여줌'''

'''Dtype: 열의 데이터 타입입니다.
object: 일반적으로 문자열이나 혼합된 데이터 타입일 때 표시됩니다. 'Name' 열이 문자열이므로 object로 표시되었습니다.
int64: 64비트 정수형 데이터 타입입니다. 'Age' 열이 정수이므로 int64로 표시되었습니다.
float64: 64비트 부동소수점(실수)형 데이터 타입입니다. 'Score' 열이 소수점을 포함하므로 float64로 표시되었습니다.'''

print("\n4-2. 통계 요약")
print(df.describe())

print("\n4-3. 데이터 크기 (행, 열):", df.shape)

print("\n4-4. 컬럼 이름들:", df.columns.tolist())
# df.columns는 DataFrame의 열 이름들을 담고 있는 pandas Index 객체를
# tolist() 메서드는 pandas의 Series나 Index 객체에 포함된 요소들을 표준 파이썬 리스트로 변환
print("\n4-4. 컬럼 이름들:", df.columns)
# Index(['Name', 'Age', 'Score'], dtype='object')

print("\n4-5. 인덱스:", df.index)

print("\n4-6. 상위 2개 행 보기")
print(df.head(2))

print("\n4-7. Score 평균:", df["Score"].mean())

print("\n4-8. 나이 기준 정렬")
print(df.sort_values(by="Age"))

"""### ⌨️ **실습 11**: `pandas`와 친해지기

pandas.DataFrame은 pandas 라이브러리의 정수입니다. 앞으로도 다양한 데이터를 DataFrame으로 변환할 일이 많습니다. DataFrame은 주어진 예시 말고도 다양한 방법으로 instance를 생성할 수 있습니다.

다음은 위에서 생성한 dataframe과 같은 데이터를 다른 방법으로 DataFrame으로 만들어봅시다.

1. `List[Dict]` 형태의 데이터를 만들어봅시다.
2. `List[List]` 형태의 데이터를 통해 만들어봅시다.
3. `numpy.ndarray` 형태의 데이터를 통해 만들어봅시다.
"""

import pandas as pd
import numpy as np

# None 부분을 직접 채우며 테스트코드가 동작하도록 문제를 풀어보세요 :)
# 정답을 확인하는 assert 코드는 수정하지말고 진행해주세요
# 기준이 되는 DataFrame
df = pd.DataFrame({
    "Name": ["Alice", "Bob", "Charlie"],
    "Age": [25, 30, 35],
    "Score": [85.5, 90.3, 78.9]
})

# 1. List[Dict] 형태의 데이터를 통해 DataFrame을 만들어봅시다.
alice = {"Name": "Alice", "Age": 25, "Score": 85.5}
bob = {"Name": "Bob", "Age": 30, "Score": 90.3}
charlie = {"Name": "Charlie", "Age": 35, "Score": 78.9}

df_1 = pd.DataFrame([alice, bob, charlie])
assert df.equals(df_1), "두 데이터가 다릅니다. column / index / data-type 등을 확인해보세요."
print(f"df_1 : \n{df_1}")

# 2. List[List] 형태의 데이터를 통해 DataFrame을 만들어봅시다.
data = [
    ["Alice", 25, 85.5],
    ["Bob", 30, 90.3],
    ["Charlie", 35, 78.9]
]
columns = ["Name", "Age", "Score"]

df_2 = pd.DataFrame(data, columns=columns)
assert df.equals(df_2), "두 데이터가 다릅니다. column / index / data-type 등을 확인해보세요."
print(f"df_2 : \n{df_2}")

# 3. numpy.ndarray 형태의 데이터를 통해 DataFrame을 만들어봅시다.
# ndarray는 NumPy의 데이터 구조. 정식 명칭은 "N-dimensional array"의 줄임말
# assertion code에서 에러가 나는 경우, `df`와 `df_3`의 차이를 한 번 살펴봐보세요 :)
names = ["Alice", "Bob", "Charlie"]
nums = np.array([
    [25, 85.5],
    [30, 90.3],
    [35, 78.9]
])

df_3 = pd.DataFrame({
    "Name": names,
    "Age": (nums[:, 0]).astype(int),
    "Score": nums[:, 1]
})
df_3.info()
df.info()

assert df.equals(df_3), "두 데이터가 다릅니다. column / index / data-type 등을 확인해보세요."
print(f"df_3 : \n{df_3}")

print("✅ 모든 DataFrame 테스트 통과!")

"""## 마치며

이상으로 가장 기본적인 Python 기초에 대해 학습하고 Data Science에서 가장 많이 사용되는 `numpy`, `pandas` 라이브러리에 대해 배웠습니다.

사실 `numpy`, `pandas`는 글로 배우기보다, 실제로 많이 사용해보면서 용례를 익히는 것이 가장 빠르게 배우는 방법입니다. 과제에서 조금 더 깊게 사용해보도록 합시다.
"""