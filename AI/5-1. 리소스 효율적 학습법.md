# 파인튜닝 및 AI모델 활용
# "리소스 효율적 AI모델"

## CONTENTS

### 1. 컴퓨터의 수 체계
1. 고정소수점
2. 부동소수점
3. 연산과 복잡도

### 2. 모델 경량화와 효율적 파인튜닝
1. 모델 경량화의 필요성
2. Quantization/Pruning/Distillation
3. LoRA/QLoRA

--------------------

# 0. 학습 시작(Overview)

## 학습 목표

### 컴퓨터는 숫자를 어떻게 이해할까?
* 고정소수점/부동소수점 이진 수 체계 및 연산 과정

### 컴퓨터내 연산은 얼마일까?
* 연산/데이터 크기별 하드웨어 복잡도 및 에너지 소비

### 모델압축 어디까지 가능한가?
* Quantization, pruning 및 distillation

### 파인튜닝? 파라메터 효율적 파인튜닝?
* 쉽게 적용가능한 파인튜닝의 효과 분석

--------------------

# 0. 학습 시작

## 산업 현장 사례

* 테슬라는 자율주행 전용 FSD 칩을 개발해 차량 내부에서 AI추론 직접 수행
* 모델은 INT8 양자화를 적용해 곱셈, 누산 연산을 정수 기반으로 처리하여 전력 소모와 지연 최소화
* 대용량 신경망도 차량 SoC에서 실시간으로 동작 가능

![테슬라 FSD 칩 이미지]

<그림\_테슬라 FSD 칩에서 합성곱 연산을 병렬화 양자화하여 효율을 높이는 CNN 최적화 구조 이미지>

**출처**: fuse 기사(https://fuse.wikichip.org/news/2707/inside-teslas-neural-processor-in-the-fsd-chip/)

--------------------

# 0. 학습 시작

## 내 일상 속에서 찾아볼 수 있는 사례

* 최근 삼성은 온디바이스 AI 언어 모델을 통해 갤럭시 기기에서 번역, 요약과 같은 처리 진행
* 대규모 언어모델을 온디바이스로 적용시 양자화 기법으로 항당 메모리와 전력 축소

![Galaxy AI OnDevice AI 이미지]

<그림\_갤럭시 온디바이스 에서 사진>

**출처**: 삼성 Tech Blog(https://semiconductor.samsung.com/news-events/tech-blog/beyond-the-cloud-a-deep-dive-into-on-device-generative-ai/?utm_source=chatgpt.com)

--------------------

# 1. 컴퓨터의 수 체계

--------------------

# 1-1. 고정소수점 수 체계

--------------------

# 1-1. 수 체계 (Number System)

## 십진수 (Decimal numbers)

1000's column → 1 's column
100's column → 10 's column

$$5374_{10} = 5 \times 10^3 + 3 \times 10^2 + 7 \times 10^1 + 4 \times 10^0$$

five thousands | three hundreds | seven tens | four ones

## 이진수 (Decimal numbers)

8's column → 1's column
4's column → 2's column

$$1101_2 = 1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 = 13_{10}$$

one eight | one four | no two | one one

--------------------

# 1-1. 이진 수 체계

![Binary System 이미지]

--------------------

# 1-1. 수 체계의 변환

## 이진수 → 십진수

* 십진수로 $10011_2$ 변환하기
* $16 \times 1 + 8 \times 0 + 4 \times 0 + 2 \times 1 + 1 \times 1 = 19_{10}$

## 십진수 → 이진수

* 이진수로 $47_{10}$ 변환하기
* $32 \times 1 + 16 \times 0 + 8 \times 1 + 4 \times 1 + 2 \times 1 + 1 \times 1 = 101111_2$

--------------------

# 1-1. 2의 거듭제곱 (Power of Two)

## $2^9$까지 외워두면 편리함

* $2^0 = 1$
* $2^1 = 2$
* $2^2 = 4$
* $2^3 = 8$
* $2^4 = 16$
* $2^5 = 32$
* $2^6 = 64$
* $2^7 = 128$

* $2^8 = 256$
* $2^9 = 512$
* $2^{10} = 1024$
* $2^{11} = 2048$
* $2^{12} = 4096$
* $2^{13} = 8192$
* $2^{14} = 16384$
* $2^{15} = 32768$

--------------------

# 1-1. 2의 거듭제곱 (Power of Two)

## 보다 큰 수를 쉽게 어림짐작 할 수 있음

* $2^{10} = 1$ kilo $\approx$ 1000 (1024)
* $2^{20} = 1$ mega $\approx$ 1 million (1,048,576)
* $2^{30} = 1$ giga $\approx$ 1 billion (1,073,741,824)

* $2^{24}$ 의 크기는?
  - $2^4 \times 2^{20} \approx$ 16 million

* 32-bit 변수가 표현할 수 있는 패턴의 가지수는?
  - $2^2 \times 2^{30} \approx$ 4 billion

--------------------

# 1-1. 16진수 (Hexadecimal Numbers)

| Hex Digit | Decimal Equivalent | Binary Equivalent |
|-----------|-------------------|-------------------|
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| 3 | 3 | 0011 |
| 4 | 4 | 0100 |
| 5 | 5 | 0101 |
| 6 | 6 | 0110 |
| 7 | 7 | 0111 |
| 8 | 8 | 1000 |
| 9 | 9 | 1001 |
| A | 10 | 1010 |
| B | 11 | 1011 |
| C | 12 | 1100 |
| D | 13 | 1101 |
| E | 14 | 1110 |
| F | 15 | 1111 |

--------------------

# 1-1. 16진수 (Hexadecimal Numbers)

## 16진수 → 이진수

* 이진수로 $4AF_{16}$ (0x4AF) 변환하기
* $0100\ 1010\ 1111_2$

## 십진수 → 16진수

* 십진수로 0x4AF 변환하기
* $16^2 \times 4 + 16^1 \times 10 + 16^0 \times 15 = 1199_{10}$

--------------------

# 1-1. Bits, Bytes, Nibbles...

```
10010110
most           least
significant    significant
bit            bit

       byte
   10010110
       nibble

CEBF9AD7
most              least
significant       significant
byte              byte
```

* **Most Significant Bit (MSB)**: 이진수에서 가장 왼쪽에 있는 비트, 가장 큰 자리값을 가짐.
* **Least Significant Bit (LSB)**: 이진수에서 가장 오른쪽에 있는 비트, 가장 작은 자리값을 가짐.
* **Nibble**: 4비트(half byte)로 이루어진 데이터 단위.

--------------------

# 1-1. 이진수의 값과 범위

## 0과 자연수를 표현하는 N-자리(N-digit) 십진수

* 가능한 표현의 수? $10^N$
* 범위? $[0, 10^N - 1]$
* 3-digit 십진수 예시
  - $10^3 = 1000$ 가지 표현 → $[0, 999]$

## 0과 자연수를 표현하는 N-자리(N-digit) 이진수

* 가능한 표현의 수? $2^N$
* 범위? $[0, 2^N - 1]$
* 3-digit 십진수 예시
  - $2^3 = 8$ 가지 표현 → $[0, 7]$

--------------------

# 1-1. 덧셈 (Addition)

## 십진수의 덧셈

```
    11 ← carries
  3734
+ 5168
------
  8902
```

## 이진수의 덧셈

```
    11 ← carries
  1011
+ 0011
------
  1110
```

--------------------

# 1-1. 덧셈 (Addition)

## 4-bit 이진수 덧셈 예시

```
    1
  1001
+ 0101
------
  1110
```

```
    111
  1011
+ 0110
------
 10001

Carry-out
```

--------------------

# 1-1. 부호 있는 수 체계 (Signed Number System)

## 부호-크기 표현 방식 (signed-magnitude representation)

* 최상위 비트(MSB)를 부호 비트로 사용하여, 0이면 양수, 10이면 음수를 나타내고,
  나머지 비트는 절댓값(크기)을 표현하는 방식.

## 2의 보수 표현 방식 (two's complement representation)

* 음수를 표현할 때 해당 수의 절댓값을 이진수로 쓰고,
  모든 비트를 반전(1의 보수)한 뒤 1을 더하는 방식.

--------------------

# 1-1. 부호-크기 표현 방식 (Signed-Magnitude Representation)

## 1 sign bit, N - 1 magnitude bit

* 최상위 자리에 sign bit 할당 (most significant bit)
  - 양수 (positive number) → sign bit = 0
  - 음수 (negative number) → sign bit = 1

$$A: \{a_{N-1}, a_{N-2}, \cdots a_2, a_1, a_0\}$$

$$A = (-1)^{a_{n-1}} \sum_{i=0}^{n-2} a_i 2^i$$

## 4-bit 부호-크기 표현 방식 예시

* $+6 = 0110$
* $-6 = 1110$

## N-bit 부호-크기 표현의 범위

* $[-(2^{N-1} - 1), 2^{N-1} - 1]$

--------------------

# 1-1. 부호-크기 표현 방식 (Signed-Magnitude Representation)

## 기존 덧셈에 문제 발생

* $-6 + 6$ 예시

```
  1110
+ 0110
------
 10100
```

* 0을 표현하는 방식에 두 가지가 있음 (±0)
  - 1000
  - 0000

--------------------

# 1-1. 2의 보수 표현 방식 (Two's Complement Representation)

## 최상위 자리가 $-2^{N-1}$ 값을 표현

$$A = a_{n-1}(-2^{n-1}) + \sum_{i=0}^{n-2} a_i 2^i$$

* 양의 방향으로 가장 큰 4-bit 표현: 0111
* 음의 방향으로 가장 큰 4-bit 표현: 1000

* 여전히 최상위 자리가 부호를 표시 (0 → 양수, 1 → 음수)

## N-bit 2의 보수 표현의 범위

* $[-2^{N-1}, 2^{N-1} - 1]$

--------------------

# 1-1. 2의 보수 표현 방식 (Two's Complement Representation)

## 기존 덧셈이 정상적으로 동작

* $6 + (-6)$

```
    111
   0110
 + 1010
--------
  10000
```

* $-2 + 3$

```
    111
   1110
 + 0011
--------
  10001
```

--------------------

# 1-1. 2의 보수 표현 방식 (Two's Complement Representation)

## 2의 보수 표현에서 부호반전

* 모든 bit을 반전 (inversion)
* $+1$

* $3_{10} = 0011_2$ 부호반전 예시

```
  1100
+ 0001
------
  1101 = -3₁₀
```

--------------------

# 1-1. 비트 폭 확장 (Increasing Bit Width)

## N-bit 수를 M-bit 수로 확장 (M > N)

* 부호 확장 (sign extension): 최상위 비트를 복사해 상위 비트를 채움 (값을 일정하게 유지)
  - 값 3의 4-bit 표현 = 0011 → 부호 확장 된 8-bit 표현 = **0000**0011
  - 값 -5의 4-bit 표현 =1011 → 부호 확장 된 8-bit 표현 = **1111**1011

* 제로 확장 (zero extension): 상위 비트를 모두 0으로 채움 (패턴을 일정하게 유지)
  - 값 3의 4-bit 표현 = 0011 → 제로 확장 된 8-bit 표현 = **0000**0011
  - 값 -5의 4-bit 표현 = 1011→ 제로 확장 된 8-bit 표현 = **0000**1011 = $11_{10}$

--------------------

# 1-1. 이진 수 체계 정리

![이진수 체계 비교 이미지]

**Unsigned** (부호 없음)
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111

**Two's Complement** (2의 보수)
1000 1001 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111

**Sign/Magnitude** (부호-크기)
1111 1110 1101 1100 1011 1010 1001 0000/1000 0001 0010 0011 0100 0101 0110 0111

--------------------

# 1-1. 이진 수 체계 정리

## C언어에서 정의된 정수 자료형 (data type)

| 자료형 | 크기 | 값의 표현범위 |
|--------|------|--------------|
| unsigned char | 1B | $0 \sim + 255$ |
| unsigned short | 2B | $0 \sim + 65,535$ |
| unsigned int | 4B* | $0 \sim + 4,294,967,295$ |
| unsigned long | 4B* | $0 \sim + 4,294,967,295$ |
| unsigned long long | 8B | $0 \sim + 18,466,744,073,709,551,615$ |
| char | 1B | $-128 \sim + 127$ |
| short | 2B | $-32,768 \sim + 32,767$ |
| int | 4B* | $-2,147,483,648 \sim + 2,147,483,647$ |
| long | 4B* | $-2,147,483,648 \sim + 2,147,483,647$ |
| long long | 8B | $-9,223,372,036,854,775,808 \sim + 9,223,372,036,854,775,807$ |

--------------------

# 1-1. 이진 수 체계 정리

## int와 long의 역사

* 8-bit/16-bit 컴퓨터 시절부터 정의된 자료형 (1983년 정의된 C89 자료형)
  - C언어는 1972년 출시, 인텔 16-bit 80286 (1982년), 인텔 32-bit 80386 (1985년), 인텔 64-bit IA-64 (2001년)

* 1983년 정의된 최초의 C89 자료형
  - char : 최소 1B인 정수형
  - short (int): 최소 2B인 정수형으로 적어도 $-32,768 \sim + 32,767$ 범위를 표현할 수 있음
  - int : short 보다 크고 최소 2B인 정수형으로 적어도 $-32,768 \sim + 32,767$ 범위를 표현할 수 있음
  - long (int): 최소 4B인 정수형으로 적어도 $-2,147,486,648 \sim + 2,147,483,647$ 범위를 표현할 수 있음

* 64-bit 구조의 등장으로 1999년 C99 표준에서 추가 정의
  ▸ long long (int): 8B 정수형

--------------------

# 1-1. 이진 수 체계 정리

## 컴퓨터의 발전과 함께 혼란이 시작됨

* int 자료형
  - 가장 효율적으로 처리될 수 있는 정수 타입을 목표로 정의됨
  - 컴퓨터 구조에 따라서 다른 크기였음 (16-bit, 32-bit 등)
  - 64-bit 구조가 등장하면서 혼란을 막기위해 int 자료형은 32-bit 길이로 고정
  - 엄밀하게 c언어에서 int는 최소 2B 범위를 표현할 정수형으로 32-bit 컴퓨터까지는 구조에 따라 크기가 달라질 수
    있으나, 64-bit 구조 이후부터는 4B로 길이가 고정되는 자료형

* long 자료형
  - 이로 인해 long이 애매해짐
  - long long은 8B로 명확하게 정의됨
  - 16-bit 이하 CPU는 더이상 존재하지 않으므로 사실상 int 자료형은 4B 길이라 봐도 무방
  - 근데, long은 (과거 int처럼) 컴퓨터/OS 구조에 따라서 4B 혹은 8B로 사용되고 있음에 주의!

--------------------

# 1-1. 이진 수 체계 정리

## 크로스 플랫폼 개발 시 혼란 필요

* Windows가 포함된 환경이면 가급적 long 사용하지 말고, int와 long long 사용 권장 (혹은 int32_t, int64_t)

| OS | Application Bit (binary) | long size |
|----|-------------------------|-----------|
| Windows (x86-64) | 32 bit | 4 byte |
| | 64 bit | **4 byte** |
| OS X (x86-64) | 32 bit | 4 byte |
| | 64 bit | 8 byte |
| Linux (x86-64) | 32 bit | 4 byte |
| | 64 bit | 8 byte |
| Aix (PowerPC) | 32 bit | 4 byte |
| | 64 bit | 8 byte |
| HP-UX (IA-64) | 32 bit | 4 byte |
| | 64 bit | 8 byte |
| Solaris (Sparc) | 32 bit | 4 byte |
| | 64 bit | 8 byte |

--------------------

# 1-1. 고정소수점 수 체계 (Fixed-Point Number System)

## N-bit 패턴이 꼭 정수일 필요는 없음

* 정수부(fractional part)와 소수부(integral part)를 N-bit 패턴에서 함께 표현 할 수 있음
  - K-bit 정수부, M-bit 소수부 ($K + M = N$)
  - 정수부와 소수부 사이에 이진 소수점 (binary point)

$$(x_{K-1}x_{K-2} \cdots x_1x_0 . x_{-1}x_{-2} \cdots x_{-M})_2$$

**정수부** | **소수부**

$$X = x_{K-1}2^{K-1} + x_{K-2}2^{K-2} + \cdots + x_1 2^1 + x_0 2^0 + x_{-1} 2^{-1} + \cdots + x_{-M} 2^{-M}$$

$$= \sum_{i=-M}^{K-1} x_i 2^i$$

--------------------

# 1-1. 고정소수점 수 체계 (Fixed-Point Number System)

## 이진 소수점 위치는 실제 저장하지 않음!

* 사용자(프로그래머)가 제한 없이 해당 위치를 정할 수 있음 → HW는 모든 N-bit 정수(integer)로 판단
  - 즉, 실제 의도한 값은 $2^M$배 차이가 있음 (scaling factor)

* 덧셈과 뺄셈은 이진과 동일하게 동작!
  - $aX \pm aY = a(X \pm Y)$ ($a =$ scaling factor)
  - (4, 4) 8-bit 고정소수점 에서 (4-bit 정수부, 4-bit 소수부, scaling factor = $2^{-4}$)

$$aX_I = 2^{-4} \times 56_{10} = 0011.1000_2 = 3.5_{10} = X_{FX}$$

$$aY_I = 2^{-4} \times 20_{10} = 0001.0100_2 = 1.25_{10} = Y_{FX}$$

$$X_I + Y_I = 76_{10} = 01001100_2 \to a(X_I + Y_I) = 2^{-4} \times 76_{10} = 0100.1100_2 = 4.75_{10} = X_{FX} + Y_{FX}$$

**실제 HW 수행** | **동일 고정소수점 해석**

--------------------

# 1-1. 고정소수점 수 체계 (Fixed-Point Number System)

## 이진 소수점 위치는 실제 저장하지 않음!

* 곱셈과 나눗셈은 scaling factor 체크! (HW는 정수 입력이라 가정하고 동작하기에 사용자의 의도가 중요!)
  - $aX \times aY = a^2(X \times Y) \neq a(X \times Y)$
  - (4, 4) 8-bit 고정소수점 에서 (4-bit 정수부, 4-bit 소수부, scaling factor = $2^{-4}$)

$$aX_I = 2^{-4} \times 24_{10} = 0001.1000_2 = 1.5_{10} = X_{FX}$$

$$aY_I = 2^{-4} \times 8_{10} = 0000.1000_2 = 0.5_{10} = Y_{FX}$$

$$X_I \times Y_I = 192_{10} = 11000000_2 \to a(X_I \times Y_I) = 2^{-4} \times 192_{10} = 1100.0000_2 = 12_{10}$$

**실제 HW 수행** | **= $2^4 \times (X_{FX} \times Y_{FX})$**
 | **동일 고정소수점 해석**

$$X_I \times Y_I \times a = 192_{10} \times 2^{-4} = 00001100_2 \to a(X_I \times Y_I \times a) = 2^{-4} \times 12_{10} = 0000.1100_2 = 0.75_{10} = X_{FX} \times Y_{FX}$$

**실제 HW 수행** | **동일 고정소수점 해석**
**(scaling factor 고려)**

--------------------

# 1-1. 고정소수점 수 체계 (Fixed-Point Number System)

## 이진 소수점 위치는 실제 저장하지 않음!

* 곱셈과 나눗셈은 scaling factor 체크! (HW는 정수 입력이라 가정하고 동작하기에 사용자의 의도가 중요!)
  - $aX \div aY = X \div Y \neq a(X \div Y)$
  - (4, 4) 8-bit 고정소수점 에서 (4-bit 정수부, 4-bit 소수부, scaling factor = $2^{-4}$)

$$aX_I = 2^{-4} \times 24_{10} = 0001.1000_2 = 1.5_{10} = X_{FX}$$

$$aY_I = 2^{-4} \times 8_{10} = 0000.1000_2 = 0.5_{10} = Y_{FX}$$

$$X_I \div Y_I = 3_{10} = 00000011_2 \to a(X_I \div Y_I) = 2^{-4} \times 3_{10} = 0000.0011_2 = 0.1875_{10} = 2^{-4} \times (X_{FX} \div Y_{FX})$$

**실제 HW 수행** | **동일 고정소수점 해석**

$$(X_I \div Y_I) \div a = 3_{10} \div 2^{-4} = 00110000_2 \to a((X_I \div Y_I) \div a) = 2^{-4} \times 48_{10} = 0011.0000_2 = 3_{10} = X_{FX} \div Y_{FX}$$

**실제 HW 수행** | **동일 고정소수점 해석**
**(scaling factor 고려)**

--------------------

# 1-2. 부동소수점 수 체계

--------------------

# 1-2. 부동소수점 수 체계 (Floating-Point Number System)

## 부동소수점

* 지수를 활용하여 수를 표기
  - 가수(mantissa or significand), 밑(base or radix), 그리고 지수(exponent)로 나누어 수를 표기
  - 예시) $1.23 \times 10^3$ (소수점의 위치가 3칸 오른쪽)
        $2.3 \times 10^{-5}$ (소수점 위치가 5칸 왼쪽)

* 소수점이 고정되지 않고 동등 따라니는 것으로 해석!

$$1.23 \times 10^3$$

**가수** | **지수** | **밑**

--------------------

# 부동소수점 수 체계 (Floating-Point Number System)

## 정해진 자리 수만 사용해서 부동소수점 "잘" 표현하기

* 가수는 고정소수점 체계를 사용 해야함
  - $1234.5 \times 10^5 = 123.45 \times 10^6 = 12.345 \times 10^7 = 1.2345 \times 10^8$

* 언제나 ■.■■■■ × 10■ 형태로만 표현하기로 약속 → **정규화** (normalization)

## 유효숫자 그 다음은 어떻게 처리할까? (rounding scheme)

* 반올림 (round to nearest)
* 올림 (round toward +inf)
* 버림 (round toward -inf)
* 절삭 (round toward zero)
* 오류를 최소화 하기 위한 다양한 rounding 기법이 존재

--------------------

# 1-2. 부동소수점 수 체계 (Floating-Point Number System)

## 아주 크거나 아주 작은 수를 효과적으로 표현해보자!

* 고정소수점 표현을 활용할 경우에 너무 많은 비트를 필요로 함
  - 64-bit signed long long 타입 (2의 보수): $-9,223,372,036,854,775,808 \sim + 9,223,372,036,854,775,807$

* 지수를 활용한다면? 큰/작은 수를 더 적은 문자로 표현 → 대신 유효숫자의 개념을 도입!
  - 64-bit signed long long 타입 (2의 보수): $-9.22 \times 10^{18} \sim + 9.22 \times 10^{18}$ (정확함을 보장하지 않음)

--------------------


이미지 40까지 진행
