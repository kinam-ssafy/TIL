## 🧠 CPU(Central Processing Unit)란? - 컴퓨터의 두뇌

### 쉬운 비유로 이해하기
```
컴퓨터 = 사무실
CPU = 직원 (일꾼)
레지스터 = 책상 위 (바로 쓸 수 있는 공간)
메모리 = 서랍 (가져오는데 시간 걸림)
하드디스크 = 창고 (가져오는데 엄청 오래 걸림)
```

### CPU의 3가지 핵심 임무
1. **계산하기** - 덧셈, 뺄셈, 비교 등
2. **판단하기** - "만약 A라면 B를 해라"
3. **제어하기** - 다른 부품들한테 명령 내리기

---

## ⚙️ CPU의 3대 구성요소

### 1. 제어장치 (Control Unit) - "지휘관"
- **역할**: 명령어를 해석하고 다른 부품들에게 지시
- **비유**: 공사현장의 현장감독

### 2. ALU (산술논리장치) - "계산기"
- **역할**: 모든 계산과 논리 연산 담당
- **할 수 있는 일**:
  ```
  산술: +, -, ×, ÷
  논리: AND, OR, NOT
  비교: 크다, 작다, 같다
  ```

### 3. 레지스터 - "책상 위 공간"
- **역할**: 현재 작업 중인 데이터 임시 보관
- **특징**: 가장 빠른 저장공간

---

## 🏃‍♂️ 레지스터가 빠른 이유

### 속도 비교 (실제 데이터!)
```
레지스터:    1 사이클     ⚡ (1초)
L1 캐시:     2-4 사이클   💨 (3초)  
메모리:      100 사이클   🚶‍♂️ (100초)
SSD:         10,000 사이클 🐌 (3시간)
```

**왜 이렇게 빠른가?**
- CPU 내부에 있어서 바로바로 접근 가능
- 전선 길이가 짧음 = 전기 신호가 빨리 도달

---

## 📋 레지스터 종류 (x86 기준)

### 범용 레지스터 - "자유롭게 쓸 수 있는 공간"
```
RAX - 계산 결과 주로 저장 (Accumulator)
RBX - 데이터 주소 저장 (Base)
RCX - 반복 횟수 카운터 (Counter)  
RDX - 입출력 데이터 (Data)
RSI - 복사할 때 원본 주소 (Source Index)
RDI - 복사할 때 목적지 주소 (Destination Index)
```

### 특수 목적 레지스터 - "특별한 용도"
```
RIP - 다음에 실행할 명령어 위치 (Instruction Pointer)
RSP - 스택 맨 위 주소 (Stack Pointer)
RBP - 함수 호출시 기준점 (Base Pointer)
RFLAGS - 계산 결과 상태 정보 (플래그들)
```

---

## 🔄 CPU 동작 원리 - 4단계 사이클

CPU는 이 4단계를 **무한 반복**합니다:

```
1. Fetch (가져와) 
   ↓
2. Decode (해석해)
   ↓  
3. Execute (실행해)
   ↓
4. Store (저장해)
   ↑_______________|
```

### 구체적인 예시: `ADD RAX, RBX`

**1. Fetch**: 메모리에서 "ADD RAX, RBX" 명령어 가져오기
**2. Decode**: "아, RAX와 RBX를 더하라는 거구나!"
**3. Execute**: ALU가 실제로 덧셈 수행
**4. Store**: 결과를 RAX에 저장

---

## 🎯 실제 동작 예시

### 간단한 계산: A = B + C

**C 코드:**
```c
int A, B = 5, C = 3;
A = B + C;
```

**어셈블리로 변환되면:**
```assembly
MOV RAX, 5      ; B(5)를 RAX에 저장
MOV RBX, 3      ; C(3)을 RBX에 저장  
ADD RAX, RBX    ; RAX = RAX + RBX (5 + 3 = 8)
MOV A, RAX      ; 결과(8)를 변수 A에 저장
```

### 스택 동작 예시

**함수 호출할 때:**
```assembly
PUSH RBP        ; 현재 함수 정보 저장
MOV RBP, RSP    ; 새 함수 시작점 설정
; ... 함수 내용 실행 ...
POP RBP         ; 원래 함수로 돌아가기
RET             ; 복귀
```

---

## 🚀 성능 향상 기법들

### 1. 파이프라이닝 - "공장 라인"
여러 명령어를 동시에 처리:
```
시간1: [명령1-Fetch]
시간2: [명령2-Fetch] [명령1-Decode]  
시간3: [명령3-Fetch] [명령2-Decode] [명령1-Execute]
시간4: [명령4-Fetch] [명령3-Decode] [명령2-Execute] [명령1-Store]
```
기존 방식: 한 명이 모든 작업을 다 함.

파이프라이닝 방식: 공장 라인처럼 분업


### 2. 캐시 활용
- **지역성 원리**: 한 번 쓴 데이터는 다시 쓸 확률 높음
- **캐시 적중률**: 95% 이상 (안 그러면 성능 급락)

---





