# REST API

## 들어가기 앞서

REST API를 이해하기 위해서는 다음 개념들을 알아야 함:
- **HTTP 프로토콜**: 웹에서 데이터를 주고받는 통신 규약
- **클라이언트-서버 구조**: 요청하는 쪽(클라이언트)과 응답하는 쪽(서버)의 역할 분리
- **URI(Uniform Resource Identifier)**: 인터넷 자원을 식별하는 고유 주소
- **HTTP Method**: GET, POST, PUT, DELETE 등 HTTP 요청의 동작 방식

---

## REST란?

**REST(Representational State Transfer)**는 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 아키텍처 스타일을 의미함.

### REST의 핵심 개념

1. **HTTP URI**를 통해 자원(Resource)을 명시
2. **HTTP Method**를 통해 해당 자원에 대한 CRUD Operation을 적용
3. 자원의 표현(Representation)을 통해 상태를 전달

**예시:**
```
GET /users/123          -> 123번 사용자 정보 조회
POST /users             -> 새로운 사용자 생성
PUT /users/123          -> 123번 사용자 정보 수정
DELETE /users/123       -> 123번 사용자 삭제
```

---

## REST의 구성 요소

REST는 3가지 핵심 요소로 구성됨:

1. **자원(Resource)**: HTTP URI로 표현
   - 모든 자원은 고유한 URI를 가짐
   - 예: `/users`, `/posts/1`, `/comments`

2. **행위(Verb)**: HTTP Method로 표현
   - GET: 조회(Read)
   - POST: 생성(Create)
   - PUT/PATCH: 수정(Update)
   - DELETE: 삭제(Delete)

3. **표현(Representation)**: HTTP Message Payload
   - JSON, XML, HTML 등의 형식으로 데이터 전달
   - 주로 JSON 형식 사용 (가독성과 범용성)

---

## REST의 6가지 설계 원칙

### 1. 균일한 인터페이스 (Uniform Interface)
- 동일한 리소스에 대한 모든 요청은 동일하게 표시되어야 함
- URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터페이스로 수행

### 2. 클라이언트-서버 구조 (Client-Server)
- 클라이언트와 서버는 서로 독립적
- 클라이언트는 URI만 알면 됨
- 서버는 HTTP를 통해 데이터만 전달

### 3. 무상태성 (Stateless)
- 각 요청은 독립적이며 이전 요청과 무관
- 서버는 클라이언트의 상태 정보를 저장하지 않음
- 각 요청에 필요한 모든 정보를 포함해야 함

### 4. 캐시 처리 가능 (Cacheable)
- HTTP의 캐싱 기능 활용 가능
- 응답에 캐싱 가능 여부 정보 포함
- 클라이언트 성능 향상 및 서버 확장성 증대

### 5. 계층화 시스템 (Layered System)
- 클라이언트-서버 사이에 여러 계층(프록시, 게이트웨이 등) 존재 가능
- 클라이언트는 직접 연결된 서버인지 중개 서버인지 알 수 없음
- 보안, 로드 밸런싱, 캐싱 등을 위한 중간 서버 배치 가능

### 6. 주문형 코드 (Code-On-Demand, 선택사항)
- 서버가 클라이언트에 실행 코드를 전송할 수 있음
- 자바 애플릿, 자바스크립트 등

---

## REST API란?

**REST API**는 REST 아키텍처 스타일의 설계 원칙을 따르는 API를 의미함.

### REST API의 특징

- HTTP 프로토콜을 그대로 활용하여 별도 인프라 불필요
- HTTP 표준을 따르는 모든 플랫폼에서 사용 가능
- API 메시지만으로 의도하는 바를 명확히 파악 가능

---

## REST API 설계 규칙

### 1. URI는 명사를 사용, 소문자 권장
```
❌ Bad: http://api.example.com/Running
✅ Good: http://api.example.com/run
```

### 2. 마지막에 슬래시(/) 미포함
```
❌ Bad: http://api.example.com/users/
✅ Good: http://api.example.com/users
```

### 3. 언더바(_) 대신 하이픈(-) 사용
```
❌ Bad: http://api.example.com/user_profile
✅ Good: http://api.example.com/user-profile
```

### 4. 파일 확장자 미포함
```
❌ Bad: http://api.example.com/photo.jpg
✅ Good: http://api.example.com/photo
```

### 5. 행위를 URI에 포함하지 않음
```
❌ Bad: http://api.example.com/delete-user/1
✅ Good: DELETE http://api.example.com/users/1
```

### 6. 계층 관계 표현
```
✅ Good: /users/123/posts          -> 123번 사용자의 게시글 목록
✅ Good: /users/123/posts/5        -> 123번 사용자의 5번 게시글
```

---

## REST API 사용 예시

### 사용자 관리 API

```
GET    /users              -> 모든 사용자 목록 조회
GET    /users/123          -> 123번 사용자 조회
POST   /users              -> 새 사용자 생성
PUT    /users/123          -> 123번 사용자 전체 수정
PATCH  /users/123          -> 123번 사용자 일부 수정
DELETE /users/123          -> 123번 사용자 삭제
```

### 요청 및 응답 형식

**요청 (POST /users)**
```json
{
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25
}
```

**응답 (201 Created)**
```json
{
  "id": 124,
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25,
  "created_at": "2025-11-03T10:30:00Z"
}
```

---

## REST API의 장점

### 1. 기존 인프라 활용
- HTTP 프로토콜 인프라를 그대로 사용
- 별도의 인프라 구축 불필요

### 2. 플랫폼 독립적
- HTTP 표준을 따르는 모든 플랫폼에서 사용 가능
- 다양한 클라이언트 환경 지원 (웹, 모바일, IoT 등)

### 3. 명확한 의도 전달
- URI와 HTTP Method만으로 API 의도 파악 가능
- 직관적이고 이해하기 쉬운 구조

### 4. 서버-클라이언트 역할 분리
- 독립적인 개발 및 유지보수 가능
- 서버는 비즈니스 로직에 집중
- 클라이언트는 사용자 인터페이스에 집중

### 5. 확장성
- 무상태성으로 인한 수평 확장 용이
- 캐싱 활용으로 성능 향상
- 계층화 시스템으로 로드 밸런싱, 보안 강화 가능

### 6. 표준화된 통신
- HTTP 표준 활용으로 다양한 추가 기능 활용
- 보안(HTTPS), 인증(OAuth), 캐싱 등

---

## REST API의 단점

### 1. 표준 부재
- REST 자체는 명확한 표준이 아닌 아키텍처 스타일
- 구현 방식이 제각각일 수 있음
- 팀마다 설계 규칙을 정의해야 함

### 2. HTTP Method 제한
- HTTP Method 형태가 제한적 (GET, POST, PUT, DELETE 등)
- 복잡한 비즈니스 로직 표현에 한계

### 3. 구형 브라우저 호환성
- PUT, DELETE 등을 지원하지 않는 구형 브라우저 존재
- 해결책: POST로 통일하거나 별도 처리 필요

### 4. 헤더 정보 처리 복잡성
- 인증, 캐싱 등 많은 정보가 헤더에 포함
- URL보다 디버깅 및 테스트가 복잡

---

## REST API가 필요한 이유

### 1. 분산 시스템 통신
- 서로 다른 시스템 간 데이터 교환이 필요
- 예: 웹 프론트엔드 ↔ 백엔드 서버
- 예: 모바일 앱 ↔ 백엔드 서버

### 2. 마이크로서비스 아키텍처
- 여러 서비스 간 통신 필요
- 각 서비스는 독립적인 REST API 제공
- 서비스 간 느슨한 결합(Loose Coupling) 실현

### 3. 다양한 클라이언트 지원
- 하나의 백엔드로 웹, 모바일, IoT 등 다양한 클라이언트 지원
- 플랫폼별 별도 구현 불필요

### 4. 유지보수성
- 서버와 클라이언트 독립적 개발 가능
- API 버전 관리를 통한 하위 호환성 유지
- 명확한 인터페이스로 협업 용이

### 5. 재사용성
- 동일한 API를 여러 클라이언트에서 재사용
- 써드파티 개발자에게 API 제공 가능 (Open API)

---

## RESTful이란?

**RESTful**은 REST의 설계 원칙을 올바르게 지킨 시스템을 의미함.

### RESTful한 시스템의 조건
- REST API 설계 규칙을 올바르게 준수
- 자원, 행위, 표현을 명확히 분리
- HTTP Method를 용도에 맞게 사용

### RESTful하지 못한 경우
```
❌ 모든 CRUD를 POST로만 처리
❌ URI에 행위 포함: /api/deleteUser
❌ 명사 대신 동사 사용: /api/getUsers
```

---

## REST API vs 다른 API 방식

### SOAP (Simple Object Access Protocol)
- XML 기반의 엄격한 프로토콜
- 복잡하고 무거움
- 엔터프라이즈 환경에서 주로 사용

### GraphQL
- 클라이언트가 필요한 데이터만 요청
- 단일 엔드포인트 사용
- Over-fetching, Under-fetching 문제 해결

### REST API
- HTTP 기반의 유연한 아키텍처 스타일
- 간단하고 직관적
- 가장 널리 사용되는 웹 API 방식

---

## 실무 적용 시 고려사항

### 1. 버전 관리
```
/api/v1/users
/api/v2/users
```

### 2. 페이징 처리
```
GET /users?page=1&size=20
```

### 3. 필터링 및 정렬
```
GET /users?status=active&sort=created_at
```

### 4. HTTP 상태 코드 활용
- 200: 성공
- 201: 생성 성공
- 400: 잘못된 요청
- 401: 인증 실패
- 404: 리소스 없음
- 500: 서버 오류

### 5. 보안
- HTTPS 사용 필수
- OAuth 2.0, JWT 등 인증 방식 적용
- API 키 관리

---

## 정리

REST API는 **HTTP 프로토콜을 활용하여 자원(URI)과 행위(HTTP Method)를 분리**하는 아키텍처 스타일임.

**핵심 특징:**
- 무상태성으로 확장성 우수
- 클라이언트-서버 독립성
- 플랫폼 독립적
- 직관적이고 이해하기 쉬운 구조

**사용 이유:**
- 분산 시스템 간 통신
- 다양한 클라이언트 지원
- 마이크로서비스 아키텍처
- 유지보수 및 재사용성

REST API는 현대 웹 개발에서 가장 널리 사용되는 API 설계 방식이며, HTTP의 장점을 최대한 활용하여 효율적이고 확장 가능한 시스템 구축을 가능하게 함.