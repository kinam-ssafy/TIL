# 구조 패턴 (Structural Patterns)

## 어댑터 패턴 (Adapter Pattern)

### 핵심 개념
호환되지 않는 인터페이스를 가진 객체들을 함께 동작시키기 위한 **변환기** 패턴

### 구조
```
Client → Target(interface) ← Adapter → Adaptee
         (원하는 형태)      (변환기)   (기존 클래스)
```

### 구성 요소 & 역할

| 요소 | 역할 |
|------|------|
| **Target** | 클라이언트가 사용하는 인터페이스 |
| **Adapter** | Target을 구현하며 Adaptee를 감싸서 변환 |
| **Adaptee** | 변환이 필요한 기존 클래스 |
| **Client** | Target 인터페이스를 통해 작업 수행 |

### 사용 시점

| 상황 | 설명 |
|------|------|
| 레거시 코드 통합 | 오래된 코드를 새 시스템에 연결 |
| 외부 라이브러리 | 서드파티 라이브러리 인터페이스 변환 |
| 인터페이스 불일치 | 기존 클래스 수정 없이 호환 |

### 장단점

| 장점 | 단점 |
|------|------|
| 기존 코드 수정 없이 호환 | 새 클래스 추가로 복잡도 증가 |
| 단일 책임 원칙 준수 | 때로는 직접 수정이 더 간단 |
| 개방-폐쇄 원칙 준수 | |

---

## 데코레이터 패턴 (Decorator Pattern)

### 핵심 개념
객체에 **동적으로 새로운 기능을 추가**하는 패턴 (기존 코드 변경 없이 확장)

### 구조
```
Client → Component ← ConcreteComponent
            ↑
            └─ Decorator ← ConcreteDecorator
               (감싸기)
```

### 구성 요소 & 역할

| 요소 | 역할 |
|------|------|
| **Component** | 기본 기능을 정의하는 인터페이스 |
| **ConcreteComponent** | 기본 기능 구현 클래스 |
| **Decorator** | Component를 감싸는 추상 클래스 |
| **ConcreteDecorator** | 실제 추가 기능 구현 |

### 사용 시점

| 상황 | 설명 |
|------|------|
| 동적 기능 추가 | 런타임에 객체에 기능 추가/제거 |
| 상속의 대안 | 상속 없이 기능 확장 |
| 조합 가능한 기능 | 여러 기능을 자유롭게 조합 |

### 장단점

| 장점 | 단점 |
|------|------|
| 런타임에 동적으로 기능 추가/제거 | 작은 객체들이 많이 생성되어 복잡 |
| 기능 조합의 유연성 | 디버깅 어려움 |
| 단일 책임 원칙 준수 | 데코레이터 순서가 중요할 수 있음 |

---

## 프록시 패턴 (Proxy Pattern)

### 핵심 개념
실제 객체에 대한 **대리자 역할**을 하며 접근을 **제어**하거나 기능 추가

### 구조
```
Client → Subject ← Proxy → RealSubject
         (공통)    (대리)   (실제 객체)
```

### 구성 요소 & 역할

| 요소 | 역할 |
|------|------|
| **Subject** | Proxy와 RealSubject의 공통 인터페이스 |
| **RealSubject** | 실제 작업을 수행하는 객체 |
| **Proxy** | RealSubject를 감싸고 접근 제어 |

### 프록시 종류

| 종류 | 목적 | 사용 예시 |
|------|------|----------|
| **가상 프록시** | 지연 로딩 | 대용량 이미지 로딩 |
| **보호 프록시** | 접근 제어 | 권한 검사 |
| **원격 프록시** | 원격 객체 대리 | RMI, 웹 서비스 |
| **캐싱 프록시** | 결과 캐싱 | DB 쿼리 결과 저장 |

### 사용 시점

| 상황 | 설명 |
|------|------|
| 지연 로딩 | 필요할 때만 실제 객체 생성 |
| 접근 제어 | 권한 검사 후 실제 객체 접근 |
| 로깅/캐싱 | 실제 작업 전후로 부가 기능 |

### 장단점

| 장점 | 단점 |
|------|------|
| 실제 객체 생성 시점 제어 | 코드 복잡도 증가 |
| 접근 제어로 보안 강화 | 응답 시간 지연 가능 |
| 실제 객체 수정 없이 기능 추가 | |

---

## 구조 패턴 비교

| 패턴 | 목적 | 관계 | 주요 용도 |
|------|------|------|----------|
| **어댑터** | 인터페이스 **변환** | 다른 인터페이스 → 호환 | 레거시 통합 |
| **데코레이터** | 기능 **확장** | 같은 인터페이스 + 기능 추가 | 동적 기능 조합 |
| **프록시** | 접근 **제어** | 같은 인터페이스 + 접근 관리 | 지연 로딩, 보안 |

### 선택 가이드

| 상황 | 선택 패턴 |
|------|-----------|
| 인터페이스가 맞지 않음 | 어댑터 |
| 기능을 동적으로 추가하고 싶음 | 데코레이터 |
| 객체 생성/접근을 제어하고 싶음 | 프록시 |
| 여러 기능을 조합하고 싶음 | 데코레이터 |
| 권한 검사가 필요함 | 프록시 |

---

# 생성 & 행위 패턴

## 빌더 패턴 (Builder Pattern)

### 핵심 개념
복잡한 객체의 생성 과정을 **단계별로 분리**하여 가독성 높게 객체 생성

### 구조
```
Client → Builder.set1()
              .set2()
              .build() → Product
```

### 구성 요소 & 역할

| 요소 | 역할 |
|------|------|
| **Builder** | 객체 생성 단계를 정의하는 인터페이스 |
| **ConcreteBuilder** | 실제 객체 조립 로직 구현 |
| **Product** | 최종 생성되는 복잡한 객체 |

### 사용 시점

| 상황 | 사용 이유 |
|------|----------|
| 생성자 매개변수 4개 이상 | 가독성 향상 |
| 선택적 매개변수 많음 | 선택적 설정 용이 |
| 불변 객체 필요 | 생성 후 변경 불가 보장 |

### 구현 핵심

| 구성 | 내용 |
|------|------|
| **생성자** | private (외부 직접 생성 차단) |
| **Builder** | static 내부 클래스 |
| **필수 매개변수** | Builder 생성자에 |
| **선택 매개변수** | 메서드로 (return this) |
| **최종 생성** | build() 메서드 |

### 장단점

| 장점 | 단점 |
|------|------|
| 가독성 향상 | 코드량 증가 |
| 불변 객체 생성 | 작은 객체엔 과도 |
| 메서드 체이닝 | 성능 오버헤드 |
| 선택적 매개변수 처리 용이 | |

---

## 커맨드 패턴 (Command Pattern)

### 핵심 개념
요청(작업)을 **객체로 캡슐화**하여 실행 취소, 로깅, 큐잉 지원

### 구조
```
Client → Command 생성
       → Invoker.execute()
       → Command.execute()
       → Receiver.action()
```

### 구성 요소 & 역할

| 요소 | 역할 |
|------|------|
| **Command** | 명령 인터페이스 (execute, undo) |
| **ConcreteCommand** | 실제 명령 구현, Receiver 호출 |
| **Receiver** | 실제 작업을 수행하는 객체 |
| **Invoker** | 명령을 실행하는 객체 |
| **Client** | Command 생성 및 Receiver 설정 |

### 사용 시점

| 상황 | 설명 |
|------|------|
| 실행 취소(Undo) | 이전 상태로 되돌리기 |
| 요청 큐잉 | 작업을 큐에 저장 후 순차 실행 |
| 로깅/기록 | 모든 작업 기록 남기기 |
| 매크로 | 여러 명령을 묶어서 실행 |

### 구현 핵심

| 핵심 | 내용 |
|------|------|
| **Command** | Receiver를 참조 |
| **execute()** | Receiver 메서드 호출 |
| **undo()** | 반대 동작 수행 |
| **Invoker** | History 스택으로 관리 |

### 장단점

| 장점 | 단점 |
|------|------|
| 실행 취소/재실행 가능 | 명령마다 클래스 생성 |
| 요청과 실행 분리 | 단순 작업엔 과도 |
| 명령 조합 가능 (매크로) | |
| 명령 큐잉/로깅 | |

---

## 빌더 vs 커맨드 비교

| 구분 | 빌더 | 커맨드 |
|------|------|--------|
| **분류** | 생성 패턴 | 행위 패턴 |
| **목적** | 객체 생성 | 요청 캡슐화 |
| **초점** | 복잡한 객체 조립 | 작업을 객체로 만들어 제어 |
| **핵심 메서드** | build() | execute(), undo() |
| **사용 시점** | 생성자 매개변수 많음 | 작업 취소/기록 필요 |

### 판단 기준

| 질문 | YES → 패턴 |
|------|-----------|
| 생성자 매개변수 4개 이상? | 빌더 |
| 선택적 매개변수 많음? | 빌더 |
| 불변 객체 필요? | 빌더 |
| Undo 기능 필요? | 커맨드 |
| 작업 큐잉 필요? | 커맨드 |
| 작업 로깅 필요? | 커맨드 |