# 1. 기본 개념
## 논리적 주소 vs 물리적 주소

### 논리적 주소 (가상 주소)
- **프로세스마다 독립적으로 가지는 주소 공간**
- 각 프로세스마다 0번지부터 시작
- CPU가 보는 주소
- 프로그래머가 작성한 코드에서 사용하는 주소

### 물리적 주소
- **메모리에 실제로 올라가는 위치**
- 메모리의 낮은 주소: 운영체제
- 메모리의 높은 주소: 사용자 프로세스

### 왜 두 가지 주소가 필요할까?
```
문제 상황:
- 여러 프로그램이 동시에 실행됨
- 각 프로그램은 0번지부터 시작한다고 가정하고 작성됨
- 실제 메모리에서는 다른 위치에 배치되어야 함

해결책:
- 프로그램은 논리적 주소 사용 (0번지부터)
- 실행할 때 물리적 주소로 변환
```

## 2. 주소 바인딩 (Address Binding)

**프로세스의 논리적 주소를 물리적 주소로 연결하는 작업**

### 컴파일 타임 바인딩
- **컴파일할 때 물리적 주소가 결정됨**
- 프로세스가 들어갈 위치를 미리 알고 있음
- 논리적 주소 = 물리적 주소

**문제점**:
- 주소가 고정되어 비효율적
- 위치 변경 시 재컴파일 필요

### 로드 타임 바인딩
- **프로그램을 메모리에 올릴 때 주소가 결정됨**
- 컴파일러가 재배치 가능한 코드 생성
- 논리적 주소 ≠ 물리적 주소

**문제점**:
- 로딩할 때 모든 주소를 바꿔야 함
- 시간이 오래 걸림

### 실행 타임 바인딩
- **프로그램 실행 중에도 주소 변경 가능**
- CPU가 주소 참조할 때마다 변환
- **현재 대부분 시스템에서 사용**

## 3. MMU (Memory Management Unit)

### MMU란?
**논리적 주소를 물리적 주소로 변환해주는 하드웨어 장치**

### MMU 구성 요소

#### Base Register (기준 레지스터)
- 프로세스가 시작되는 물리적 주소의 최솟값
- 모든 논리적 주소에 더해짐

#### Limit Register (한계 레지스터)
- 프로세스의 크기 (논리적 주소의 범위)
- 잘못된 메모리 접근 방지

### MMU 동작 과정
```
1. CPU가 논리적 주소 요청 (예: 346번지)
2. Limit Register와 비교 → 범위 확인
3. 범위 벗어나면 → Trap 발생 (프로세스 강제 종료)
4. 범위 안이면 → Base Register 값 더하기
5. 물리적 주소 생성 → 메모리 접근
```

## 4. 메모리 할당 방식

### 연속 할당

#### 고정 분할
**메모리를 미리 정해진 크기로 나누어 사용**

```
메모리 구조:
┌─────────────┐
│ 운영체제    │
├─────────────┤
│ 100KB 구역  │
├─────────────┤
│ 200KB 구역  │
├─────────────┤
│ 300KB 구역  │
└─────────────┘
```

**장점**: 구현 단순  
**단점**: 내부 파편화 (구역보다 작은 프로그램 → 공간 낭비)

#### 가변 분할
**프로세스 크기에 맞춰 동적으로 할당**

**할당 방법**:
- **First Fit**: 첫 번째로 들어갈 수 있는 곳에 배치
- **Best Fit**: 가장 크기가 비슷한 곳에 배치
- **Worst Fit**: 가장 큰 공간에 배치

**문제점**: 외부 파편화 (작은 조각들이 여기저기 흩어짐)

### 비연속 할당

## 5. 페이징 (Paging)

### 페이징이 필요한 이유
```
기존 문제점:
- 큰 프로세스를 연속된 공간에 배치하기 어려움
- 외부 파편화로 메모리 낭비

페이징 해결책:
- 메모리를 작은 조각으로 나누기
- 프로세스도 같은 크기로 나누기
- 흩어져서 배치해도 됨
```

### 페이징 기본 개념

#### 페이지 (Page)
- **논리 메모리를 나눈 고정 크기 블록**
- 보통 4KB 크기

#### 프레임 (Frame)
- **물리 메모리를 나눈 고정 크기 블록**
- 페이지와 같은 크기

#### 페이지 테이블 (Page Table)
- 각 페이지가 어느 프레임에 있는지 기록하는 표

### 페이징 주소 변환

#### 논리 주소 구조
```
논리 주소 = 페이지 번호 + 페이지 내 오프셋

예시 (4KB 페이지):
논리 주소 16384 → 페이지 4, 오프셋 0
논리 주소 16500 → 페이지 4, 오프셋 116
```

#### 변환 과정
```
1. 논리 주소를 페이지 번호와 오프셋으로 분리
2. 페이지 테이블에서 해당 프레임 번호 찾기
3. 프레임 번호 + 오프셋 = 물리적 주소
```

### 페이징의 장단점

**장점**:
- 외부 파편화 해결
- 메모리 관리 단순화

**단점**:
- 내부 파편화 (마지막 페이지가 꽉 차지 않을 수 있음)
- 페이지 테이블 공간 필요

## 6. 세그멘테이션 (Segmentation)

### 세그멘테이션 개념
**프로그램을 논리적 의미 단위로 나누어 관리**

#### 세그먼트 종류
```
세그먼트 0: Code 영역 (실행 코드)
세그먼트 1: Data 영역 (전역 변수)
세그먼트 2: Stack 영역 (지역 변수)
세그먼트 3: Heap 영역 (동적 할당)
```

### 세그먼트 테이블
각 세그먼트의 시작 주소와 크기를 저장

```
세그먼트 번호 | 기준 주소 | 한계값
    0       |   1000   |  2000
    1       |   4000   |  1000
    2       |   8000   |  3000
```

### 페이징 vs 세그멘테이션

| 구분 | 페이징 | 세그멘테이션 |
|------|--------|-------------|
| **분할 기준** | 물리적 (고정 크기) | 논리적 (가변 크기) |
| **파편화** | 내부 파편화 | 외부 파편화 |
| **보호/공유** | 어려움 | 쉬움 (의미 단위) |

## 7. 가상 메모리 (Virtual Memory) 

### 가상 메모리가 필요한 이유
```
문제 상황:
- 물리 메모리는 제한적 (8GB, 16GB 등)
- 실행하려는 프로그램들의 총 크기 > 물리 메모리

해결 아이디어:
- 프로그램 전체를 메모리에 올릴 필요 없음
- 현재 사용하는 부분만 메모리에 유지
- 사용하지 않는 부분은 디스크에 저장
```

### 요구 페이징 (Demand Paging)

#### 기본 동작
```
1. 프로세스 시작: 아무 페이지도 메모리에 없음
2. 페이지 접근 시도: 페이지 폴트 발생
3. 운영체제: 디스크에서 해당 페이지를 메모리로 가져옴
4. 실행 계속
```

#### 페이지 폴트 처리 과정
```
1. 하드웨어가 페이지 폴트 인터럽트 발생
2. 운영체제가 제어권 획득
3. 잘못된 접근인지 확인 (보호 위반 등)
4. 빈 프레임 찾기
5. 디스크에서 페이지 읽어오기
6. 페이지 테이블 업데이트
7. 명령어 다시 실행
```

### Valid/Invalid 비트
페이지 테이블의 각 엔트리에 있는 비트
- **Valid (v)**: 해당 페이지가 메모리에 있음
- **Invalid (i)**: 해당 페이지가 메모리에 없음 (디스크에 있음)

## 8. 페이지 교체 알고리즘

### 페이지 교체가 필요한 상황
```
상황: 페이지 폴트 발생 + 메모리 가득 참
해결: 기존 페이지 하나를 디스크로 내보내고 새 페이지 가져오기
문제: 어떤 페이지를 내보낼 것인가?
```

### FIFO (First-In-First-Out)
**가장 먼저 들어온 페이지를 교체**

```
예시:
메모리에 페이지 순서: A → B → C
새 페이지 D 필요 → A를 내보내고 D 가져오기
결과: B → C → D
```

**장점**: 구현 단순  
**단점**: 자주 사용하는 페이지도 교체될 수 있음

### LRU (Least Recently Used)
**가장 오래 전에 사용된 페이지를 교체**

```
예시:
최근 사용 순서: C (방금 전) → B (조금 전) → A (오래 전)
새 페이지 D 필요 → A를 내보내고 D 가져오기
```

**장점**: 일반적으로 좋은 성능  
**단점**: 구현 복잡, 오버헤드

### Clock 알고리즘
**LRU의 근사 알고리즘 (Second Chance)**

#### 참조 비트 사용
- 페이지 접근 시 참조 비트 = 1
- 교체 대상 선택 시 참조 비트 확인

#### 동작 과정
```
1. 포인터가 가리키는 페이지 확인
2. 참조 비트 = 1이면 → 0으로 바꾸고 다음으로
3. 참조 비트 = 0이면 → 해당 페이지 교체
4. 원형으로 계속 진행
```

## 9. TLB (Translation Lookaside Buffer)

### TLB가 필요한 이유
```
문제점:
- 페이지 테이블은 메모리에 저장됨
- 주소 변환할 때마다 메모리 접근 2번 필요
  1) 페이지 테이블 접근
  2) 실제 데이터 접근
- 속도가 느려짐

해결책:
- 최근 사용한 페이지 테이블 엔트리를 캐시에 저장
- 이 캐시가 TLB
```

### TLB 동작
```
1. 논리 주소 입력
2. TLB에서 해당 페이지 번호 검색
3. TLB 히트 → 바로 물리 주소 얻음
4. TLB 미스 → 페이지 테이블 접근 → TLB 업데이트
```

### TLB 효과
```
TLB 히트율 90%인 경우:
- TLB 히트: 1 사이클
- TLB 미스: 20 사이클 (페이지 테이블 접근)

평균 시간 = 0.9 × 1 + 0.1 × 20 = 2.9 사이클
TLB 없었다면: 20 사이클
→ 약 7배 빨라짐
```

## 10. 메모리 관리 기법들

### Dynamic Loading (동적 로딩)
- **필요할 때만 메모리에 올리는 기법**
- 처음에는 main 함수만 메모리에 로드
- 다른 함수 호출 시 그때 로드

**장점**: 메모리 절약

### Dynamic Linking (동적 연결)
- **라이브러리 연결을 실행 시점까지 지연**
- 실행 파일에 라이브러리 코드 포함 안 됨
- 여러 프로그램이 같은 라이브러리 공유 가능

**정적 연결 vs 동적 연결**:
- 정적: 실행 파일 크기 큼, 메모리 낭비
- 동적: 실행 파일 작음, 메모리 절약

### Swapping (스와핑)
- **메모리와 디스크 간 프로세스 전체를 옮기는 기법**
- 메모리 부족 시 일부 프로세스를 디스크로 내보냄
- 나중에 다시 메모리로 가져옴

## 핵심 정리

### 메모리 관리의 목표
1. **효율성**: 메모리 공간 효율적 사용
2. **보호**: 프로세스 간 메모리 영역 보호  
3. **확장**: 물리 메모리보다 큰 프로그램 실행

### 주요 기법 흐름
```
1단계: 주소 바인딩 (논리 → 물리 주소 변환)
2단계: 연속 할당 (고정/가변 분할)
3단계: 페이징 (외부 파편화 해결)
4단계: 가상 메모리 (메모리 크기 제한 극복)
5단계: 페이지 교체 (메모리 부족 시 대응)
```

### 기억해야 할 내용들
- **MMU**: 주소 변환 하드웨어
- **페이징**: 고정 크기로 나누어 관리
- **가상 메모리**: 필요한 부분만 메모리에
- **TLB**: 주소 변환 속도 향상
