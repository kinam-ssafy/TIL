# 시스템 콜 & OS 구조

## 들어가기 전에

### 운영체제의 역할
- 하드웨어 자원 관리
- 응용 프로그램 실행 환경 제공
- 사용자와 하드웨어 사이의 중재자

### 보호의 필요성
- 사용자 프로그램이 하드웨어를 직접 제어하면 위험함
- 다른 프로세스의 메모리 침범 가능
- 시스템 전체가 불안정해질 수 있음

---

## 1. 이중 동작 모드 (Dual Mode)

### 개념
CPU가 두 가지 실행 모드로 동작하여 시스템을 보호함

### 모드의 종류

#### (1) 사용자 모드 (User Mode)
```
특징:
- 일반 응용 프로그램이 실행되는 모드
- 제한된 명령어만 실행 가능
- 하드웨어에 직접 접근 불가
- 다른 프로세스 메모리 접근 불가

실행 가능:
- 일반 연산 (덧셈, 곱셈 등)
- 메모리 읽기/쓰기 (자신의 영역만)
- 함수 호출

실행 불가능:
- I/O 명령어
- 인터럽트 제어
- 타이머 설정
- 메모리 보호 설정 변경
```

#### (2) 커널 모드 (Kernel Mode)
```
특징:
- 운영체제가 실행되는 모드
- 모든 명령어 실행 가능
- 하드웨어 직접 제어 가능
- 시스템 전체 메모리 접근 가능

실행 가능:
- 모든 CPU 명령어
- I/O 제어
- 메모리 관리
- 프로세스 관리
- 인터럽트 처리
```

### 모드 비트 (Mode Bit)

```
CPU 내부 레지스터의 1비트:

모드 비트 = 0 → 커널 모드
모드 비트 = 1 → 사용자 모드

하드웨어가 명령어 실행 전에 확인:
- 특권 명령어인데 사용자 모드? → 트랩 발생
- 커널 모드? → 실행 허용
```

### 모드 전환

```
사용자 모드 → 커널 모드:
- 시스템 콜
- 인터럽트
- 예외 (Exception)

커널 모드 → 사용자 모드:
- 시스템 콜 완료
- 프로세스 재개
```

---

## 2. 시스템 콜 (System Call)

### 정의
사용자 프로그램이 운영체제의 서비스를 요청하는 인터페이스

### 시스템 콜이 필요한 이유

```
문제 상황:
- 사용자 프로그램이 파일을 읽고 싶음
- 하지만 사용자 모드에서는 I/O 명령어 실행 불가

해결:
- 운영체제에게 "파일 읽어주세요" 요청
- 이 요청 메커니즘이 시스템 콜
```

### 시스템 콜의 특징
- 프로그래밍 언어의 함수처럼 보이지만 실제로는 특별한 동작
- 커널 모드로 전환하는 유일한 방법
- 보안과 안정성을 위한 통제된 진입점

---

## 3. 시스템 콜 동작 과정

### 전체 흐름

```
1. 사용자 프로그램에서 시스템 콜 호출
   예: read(fd, buffer, size)

2. 라이브러리 함수 실행
   (시스템 콜 래퍼 함수)

3. 시스템 콜 번호를 레지스터에 저장
   예: read = 시스템 콜 번호 0

4. 소프트웨어 인터럽트 발생 (trap)
   특별한 명령어 실행: int 0x80 (Linux x86)

5. 모드 비트 변경 (1 → 0)
   사용자 모드 → 커널 모드

6. 인터럽트 벡터 테이블 참조
   시스템 콜 핸들러 주소 찾기

7. 커널의 시스템 콜 핸들러 실행
   시스템 콜 번호에 따라 해당 함수 호출

8. 운영체제가 실제 작업 수행
   (파일 읽기, 메모리 할당 등)

9. 결과를 레지스터에 저장

10. 모드 비트 변경 (0 → 1)
    커널 모드 → 사용자 모드

11. 사용자 프로그램으로 복귀
    결과 값 반환
```

### 상세 예시: read() 시스템 콜

```c
// 사용자 프로그램
char buffer[100];
int n = read(fd, buffer, 100);

→ 내부 동작:

1. read() 라이브러리 함수 호출
2. 시스템 콜 번호(0) 레지스터에 저장
3. 인자들(fd, buffer, 100) 레지스터에 저장
4. trap 명령어 실행
5. [커널 모드 진입]
6. sys_read() 커널 함수 실행
   - 파일 디스크립터 확인
   - 권한 검사
   - 디스크에서 데이터 읽기
   - 버퍼에 복사
7. 반환 값 설정 (읽은 바이트 수)
8. [사용자 모드 복귀]
9. n에 결과 저장
```

---

## 4. 시스템 콜의 종류

### (1) 프로세스 제어

```
fork()      - 새 프로세스 생성
exec()      - 프로그램 실행
exit()      - 프로세스 종료
wait()      - 자식 프로세스 대기
getpid()    - 프로세스 ID 얻기
kill()      - 시그널 전송
```

**예시**
```c
pid_t pid = fork();  // 프로세스 복제
if (pid == 0) {
    // 자식 프로세스
    exec("/bin/ls", ...);
} else {
    // 부모 프로세스
    wait(&status);  // 자식 종료 대기
}
```

### (2) 파일 관리

```
open()      - 파일 열기
read()      - 파일 읽기
write()     - 파일 쓰기
close()     - 파일 닫기
lseek()     - 파일 포인터 이동
stat()      - 파일 정보 얻기
```

**예시**
```c
int fd = open("file.txt", O_RDONLY);
char buffer[100];
int n = read(fd, buffer, 100);
close(fd);
```

### (3) 메모리 관리

```
brk()       - 힙 크기 변경
mmap()      - 메모리 매핑
munmap()    - 메모리 매핑 해제
mprotect()  - 메모리 보호 속성 변경
```

**예시**
```c
void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
// 메모리 사용
munmap(ptr, size);
```

### (4) 장치 관리

```
ioctl()     - 장치 제어
read()      - 장치에서 읽기
write()     - 장치에 쓰기
```

### (5) 정보 유지 관리

```
time()      - 현재 시간
getpid()    - 프로세스 ID
alarm()     - 알람 설정
sleep()     - 프로세스 대기
```

### (6) 통신

```
pipe()      - 파이프 생성
socket()    - 소켓 생성
send()      - 데이터 전송
recv()      - 데이터 수신
```

---

## 5. 시스템 콜 구현 방식

### (1) 시스템 콜 번호

```
운영체제는 각 시스템 콜에 고유 번호 할당:

Linux x86-64:
0  : read
1  : write
2  : open
3  : close
...
59 : execve
60 : exit
```

### (2) 시스템 콜 테이블

```
커널 내부의 함수 포인터 배열:

sys_call_table[0] = sys_read
sys_call_table[1] = sys_write
sys_call_table[2] = sys_open
...

시스템 콜 핸들러:
번호 n이 들어오면 sys_call_table[n] 실행
```

### (3) 인자 전달 방법

#### 방법 1: 레지스터
```
가장 빠른 방법:
- 인자를 CPU 레지스터에 저장
- 개수 제한 있음 (레지스터 개수만큼)

예시 (x86-64):
rax : 시스템 콜 번호
rdi : 첫 번째 인자
rsi : 두 번째 인자
rdx : 세 번째 인자
...
```

#### 방법 2: 메모리 블록
```
많은 인자가 필요한 경우:
- 메모리에 인자 저장
- 메모리 주소를 레지스터에 저장
```

#### 방법 3: 스택
```
인자를 스택에 push
커널이 스택에서 pop
```

---

## 6. 운영체제 구조

### (1) 단순 구조 (Monolithic Structure)

#### 특징
운영체제의 모든 기능이 하나의 큰 프로그램

```
구조:
┌─────────────────────────┐
│                         │
│   모든 OS 기능          │
│   (파일, 메모리,        │
│    프로세스, I/O 등)    │
│                         │
└─────────────────────────┘
        커널 공간
─────────────────────────────
        사용자 공간
```

#### 장점
- 빠른 성능 (함수 호출만)
- 구현 단순

#### 단점
- 유지보수 어려움
- 한 부분의 버그가 전체 영향
- 확장성 낮음

#### 예시
- MS-DOS (초기)
- 초기 UNIX

---

### (2) 계층 구조 (Layered Approach)

#### 특징
운영체제를 여러 계층으로 나누어 구현

```
구조:
┌─────────────────────────┐
│ Layer N: 사용자 인터페이스│
├─────────────────────────┤
│ Layer N-1: 응용 프로그램  │
├─────────────────────────┤
│ Layer 3: I/O 관리        │
├─────────────────────────┤
│ Layer 2: 메모리 관리      │
├─────────────────────────┤
│ Layer 1: 프로세스 스케줄링│
├─────────────────────────┤
│ Layer 0: 하드웨어        │
└─────────────────────────┘

각 계층은 바로 아래 계층의 서비스만 사용
```

#### 장점
- 모듈화로 유지보수 용이
- 각 계층 독립적 개발/테스트 가능
- 구조가 명확함

#### 단점
- 계층 정의 어려움
- 성능 오버헤드 (계층 간 호출)

---

### (3) 마이크로커널 (Microkernel)

#### 특징
커널을 최소한으로 유지하고 나머지는 사용자 공간에서 실행

```
구조:
┌─────────────────────────┐
│  파일 시스템  │ 디바이스  │
│   서버       │  드라이버 │ 사용자 공간
├─────────────┼───────────┤
│             │           │
│ 마이크로커널 │           │
│ (IPC, 스케줄링,메모리)   │ 커널 공간
└─────────────────────────┘

핵심 기능만 커널에 유지:
- 프로세스 간 통신 (IPC)
- 기본 프로세스/스레드 관리
- 메모리 관리
- 기본 스케줄링
```

#### 장점
- 확장성 높음
- 안정성 높음 (커널 코드 최소화)
- 이식성 좋음
- 보안성 향상

#### 단점
- 성능 오버헤드 (사용자↔커널 전환 빈번)
- 구현 복잡

#### 예시
- Minix
- QNX
- macOS (Darwin - 일부 마이크로커널 특성)

---

### (4) 모듈 구조 (Modular Approach)

#### 특징
현대 운영체제가 주로 사용하는 방식

```
구조:
         ┌─────────┐
         │  Core   │
         │ Kernel  │
         └────┬────┘
              │
    ┌─────────┼─────────┐
    │         │         │
┌───┴───┐ ┌──┴───┐ ┌───┴───┐
│ 파일  │ │스케줄│ │ 네트워크│ 모듈
│시스템 │ │ 링   │ │ 스택   │
└───────┘ └──────┘ └────────┘

모듈:
- 필요할 때 동적 로드/언로드
- 커널에 기능 추가/제거 가능
```

#### 장점
- 유연성 높음 (모듈 추가/제거)
- 성능 좋음 (커널 공간에서 실행)
- 유지보수 용이

#### 단점
- 모듈 간 의존성 관리 필요

#### 예시
- Linux (Loadable Kernel Modules)
- Solaris

---

## 7. 하이브리드 구조

### 현대 운영체제의 접근

대부분의 현대 OS는 여러 구조를 결합함

#### Linux
```
기본: 모놀리식 구조
+ 모듈 구조 (동적 로딩)

특징:
- 핵심 기능은 커널에
- 확장 기능은 모듈로
- 빠른 성능 + 유연성
```

#### Windows NT
```
기본: 하이브리드 구조
- 마이크로커널 아이디어 차용
- 성능을 위해 일부 커널에 포함

계층:
HAL (Hardware Abstraction Layer)
Kernel
Executive Services
```

#### macOS
```
Darwin 커널:
- Mach 마이크로커널 (IPC, 메모리)
+ BSD 커널 (파일, 네트워크)
+ I/O Kit (드라이버 프레임워크)
```

---

## 8. 가상 머신 (Virtual Machine)

### 개념
하드웨어를 가상화하여 여러 운영체제를 동시 실행

```
구조:
┌────────┬────────┬────────┐
│ OS 1   │ OS 2   │ OS 3   │ 게스트 OS
├────────┴────────┴────────┤
│   Virtual Machine Monitor │ 하이퍼바이저
│      (Hypervisor)         │
├───────────────────────────┤
│       하드웨어            │
└───────────────────────────┘
```

### Type 1 하이퍼바이저 (Bare Metal)
```
하드웨어 위에 직접 설치:
- VMware ESXi
- Xen
- Hyper-V

장점: 높은 성능
```

### Type 2 하이퍼바이저 (Hosted)
```
호스트 OS 위에서 실행:
- VMware Workstation
- VirtualBox
- Parallels

장점: 설치 쉬움
```

---

## 9. 컨테이너 (Container)

### 개념
OS 레벨 가상화 - 커널 공유, 프로세스 격리

```
구조:
┌────────┬────────┬────────┐
│App 1   │App 2   │App 3   │
├────────┼────────┼────────┤
│Container Runtime          │
├───────────────────────────┤
│      Host OS Kernel       │
├───────────────────────────┤
│       하드웨어            │
└───────────────────────────┘
```

### VM vs Container

```
Virtual Machine:
- 각자 OS 커널 보유
- 무거움 (GB 단위)
- 완전한 격리
- 시작 느림 (분 단위)

Container:
- 호스트 커널 공유
- 가벼움 (MB 단위)
- 프로세스 수준 격리
- 시작 빠름 (초 단위)
```

### 예시
- Docker
- Kubernetes (오케스트레이션)
- LXC

---

## 10. 시스템 콜 vs 라이브러리 함수

### 차이점

```
시스템 콜:
- 커널 서비스 요청
- 모드 전환 발생
- 느림 (오버헤드)
- 예: read(), write(), fork()

라이브러리 함수:
- 사용자 공간에서 실행
- 모드 전환 없음
- 빠름
- 예: strlen(), printf() 일부
```

### printf()의 동작

```c
printf("Hello, World!\n");

내부 동작:
1. 사용자 공간에서 문자열 포맷팅
2. 버퍼에 저장
3. 버퍼가 차면 write() 시스템 콜 호출
4. 커널이 실제 출력 수행

→ printf() = 라이브러리 함수 + 시스템 콜
```

---

## 11. 핵심 정리

### 이중 모드의 목적
```
보호와 안정성:
- 사용자 모드: 제한된 권한
- 커널 모드: 모든 권한
- 시스템 콜로만 전환 가능
```

### 시스템 콜의 본질
```
1. 사용자 프로그램이 OS 서비스 요청
2. 소프트웨어 인터럽트 (trap) 발생
3. 모드 전환 (사용자 → 커널)
4. 커널이 작업 수행
5. 모드 전환 (커널 → 사용자)
6. 결과 반환
```

### 시스템 콜 과정
```
프로그램 → 라이브러리 함수 → trap → 커널 → 실제 작업 → 반환
```

### OS 구조 선택
```
단순 구조: 빠르지만 유지보수 어려움
계층 구조: 명확하지만 성능 저하
마이크로커널: 안정적이지만 느림
모듈 구조: 유연하고 빠름 (현대 OS)
```

### 현대 OS 트렌드
```
- 하이브리드 구조 (여러 장점 결합)
- 가상화 (VM, 컨테이너)
- 모듈화 (동적 로딩)
- 보안 강화 (격리, 샌드박싱)
```