# 교착 상태 (Deadlock)

## 1. 기본 개념 이해

### 사전적 의미
**교착 상태(膠着狀態)**: 서로 대립하는 상황이 팽팽하게 맞서서 어느 쪽도 양보하지 않아 일이 진전되지 않는 상태

### 운영체제에서의 정의
두 개 이상의 프로세스가 **서로가 가진 자원을 기다리면서 무한정 대기하는 상태**

각 프로세스가 필요한 자원을 다른 프로세스가 점유하고 있어서, **어떤 프로세스도 진행할 수 없는 상황**을 의미함

## 2. 실생활 예시로 이해하기

### 교차로 상황
네 방향에서 온 차들이 모두 교차로 중앙에 진입하여 서로를 막는 상황
- 각 차량이 자신의 위치(자원)를 점유한 채로
- 다른 차량이 비켜줄 때까지 기다림
- 결과: 아무도 움직일 수 없음

### 회의실 예약 시나리오
- A팀: 회의실1 사용 중, 회의실2 기다림
- B팀: 회의실2 사용 중, 회의실1 기다림
- 결과: 양 팀 모두 무한정 대기

### 식당에서의 젓가락 문제
- 고객A: 왼쪽 젓가락 들고 오른쪽 젓가락 기다림
- 고객B: 오른쪽 젓가락 들고 왼쪽 젓가락 기다림
- 결과: 둘 다 식사할 수 없음

## 3. 데드락 발생 조건 (필요충분조건)

**4가지 조건이 모두 동시에 만족되어야 데드락 발생**

### 1. 상호 배제 (Mutual Exclusion)
**자원을 한 번에 하나의 프로세스만 사용할 수 있음**

#### 특징
- 공유 불가능한 자원에만 적용됨
- 프린터, 파일, 메모리 영역 등

#### 예시
```
프린터 자원:
- 프로세스 A가 사용 중이면
- 프로세스 B는 대기해야 함
- 동시 사용 불가능
```

### 2. 점유 대기 (Hold and Wait)
**자원을 가진 채로 다른 자원을 기다림**

#### 특징
- 최소 하나의 자원을 점유한 상태
- 동시에 다른 프로세스가 점유한 자원을 요청

#### 예시
```
프로세스 A:
- 파일1을 열어둔 상태에서
- 파일2 접근을 기다림

프로세스 B:
- 파일2를 열어둔 상태에서  
- 파일1 접근을 기다림
```

### 3. 비선점 (No Preemption)
**다른 프로세스의 자원을 강제로 빼앗을 수 없음**

#### 특징
- 자원을 사용 중인 프로세스만이 자발적으로 반납 가능
- 운영체제나 다른 프로세스가 강제 회수 불가

#### 예시
```
프로세스가 파일을 연 상태에서:
- 다른 프로세스가 강제로 파일을 닫을 수 없음
- 사용 중인 프로세스가 스스로 닫아야 함
```

### 4. 순환 대기 (Circular Wait)
**프로세스들이 원형으로 서로의 자원을 기다림**

#### 특징
- 프로세스 체인이 원형 구조를 형성
- P1 → P2 → P3 → ... → Pn → P1

#### 예시
```
3개 프로세스의 순환 대기:
P1: R1 점유, R2 요청
P2: R2 점유, R3 요청  
P3: R3 점유, R1 요청

결과: P1 → P2 → P3 → P1 순환 구조
```

## 4. 데드락 처리 방법

### 1. 데드락 예방 (Prevention)
**4가지 조건 중 하나를 원천 차단하여 데드락 발생 자체를 방지**

#### 상호 배제 조건 제거
- **방법**: 자원을 공유 가능하게 만들기
- **한계**: 물리적으로 공유 불가능한 자원 존재 (프린터, 디스크 등)
- **적용**: 읽기 전용 파일 등 일부 자원에만 가능

#### 점유 대기 조건 제거
- **방법1**: 프로세스 시작 시 모든 필요 자원을 한 번에 요청
- **방법2**: 자원을 점유하지 않은 상태에서만 새로운 자원 요청 허용
- **장점**: 구현이 단순함
- **단점**: 자원 이용률 저하, 기아 현상 가능

#### 비선점 조건 제거
- **방법**: 다른 자원이 필요할 때 기존 자원을 모두 반납
- **적용**: CPU, 메모리 등 상태 저장/복구가 가능한 자원
- **한계**: 프린터 등 중간 결과 손실이 치명적인 자원에는 부적절

#### 순환 대기 조건 제거
- **방법**: 자원에 순서를 매겨 오름차순으로만 요청하도록 제한
- **예시**: R1 → R2 → R3 순서로만 자원 요청 허용
- **장점**: 효과적이고 널리 사용됨
- **단점**: 프로그래밍 제약 증가

### 2. 데드락 회피 (Avoidance)
**시스템의 상태를 모니터링하여 안전한 상태에서만 자원 할당**

#### 안전 상태 (Safe State)
- 모든 프로세스가 정상적으로 완료될 수 있는 실행 순서가 존재하는 상태
- 시스템이 데드락에 빠지지 않을 것을 보장

#### 불안전 상태 (Unsafe State)
- 안전 상태가 아닌 모든 상태
- 데드락이 발생할 가능성이 있음
- 불안전 상태 ≠ 데드락 상태

#### 은행원 알고리즘 (Banker's Algorithm)
다익스트라가 제안한 데드락 회피 알고리즘

**기본 아이디어**
- 은행원이 대출할 때 고객이 모든 대출금을 상환할 수 있는지 미리 확인
- 시스템이 자원을 할당할 때 안전 상태를 유지할 수 있는지 검사

**필요한 정보**
```
Available[]: 현재 사용 가능한 자원 수
Max[][]: 각 프로세스의 최대 자원 요구량
Allocation[][]: 각 프로세스에 현재 할당된 자원 수
Need[][]: 각 프로세스가 추가로 필요한 자원 수
Need[i][j] = Max[i][j] - Allocation[i][j]
```

**알고리즘 동작**
1. 자원 요청이 들어오면 임시로 할당한다고 가정
2. 할당 후 시스템이 안전 상태인지 검사
3. 안전하면 실제 할당, 불안전하면 대기

### 3. 데드락 탐지 및 복구 (Detection & Recovery)
**데드락 발생을 허용하되 주기적으로 탐지하여 복구**

#### 탐지 방법
**자원 할당 그래프 (Resource Allocation Graph)**
- 프로세스 → 자원: 자원 요청
- 자원 → 프로세스: 자원 할당
- 그래프에 사이클이 있으면 데드락 존재

**대기 그래프 (Wait-for Graph)**
- 단일 인스턴스 자원의 경우 사용
- P1 → P2: P1이 P2를 기다림
- 사이클 탐지로 데드락 확인

#### 복구 방법
**프로세스 종료**
- 모든 데드락 프로세스 종료 (극단적)
- 데드락 해결될 때까지 프로세스를 하나씩 종료

**자원 선점**
- 데드락 프로세스로부터 자원을 선점하여 다른 프로세스에게 할당
- 선점 대상 선택, 롤백, 기아 현상 방지 필요

### 4. 데드락 무시 (Ignore)
**타조 정책 - 데드락이 드물게 발생한다고 가정하고 무시**

#### 특징
- 가장 간단한 방법
- 데드락 처리 비용이 데드락으로 인한 손실보다 클 때 선택
- 대부분의 범용 운영체제가 채택 (Windows, Linux 등)

#### 근거
- 데드락은 실제로 매우 드물게 발생
- 예방/회피 기법은 성능 오버헤드가 큼
- 사용자가 강제 종료로 해결 가능

## 5. 고전적 동기화 문제: 식사하는 철학자

### 문제 상황
5명의 철학자가 원형 테이블에 앉아 있고, 각 철학자 사이에 포크가 하나씩 총 5개 있음

#### 규칙
- 철학자는 생각하거나 식사만 함
- 식사하려면 양쪽 포크를 모두 사용해야 함
- 다 먹으면 포크를 내려놓고 다시 생각함

#### 데드락 시나리오
```
모든 철학자가 동시에:
1. 왼쪽 포크를 집음
2. 오른쪽 포크를 기다림
결과: 모든 철학자가 무한 대기
```

### 해결 방법

#### 1. 비대칭적 해법
- 4명은 왼쪽 포크 먼저, 1명은 오른쪽 포크 먼저
- 순환 대기 조건 제거

#### 2. 동시 식사 제한
- 최대 4명만 동시에 식사 시도 허용
- 세마포어로 구현

#### 3. 조건 확인법
- 양쪽 포크가 모두 사용 가능할 때만 식사 시작
- 모니터나 뮤텍스로 구현

## 6. 실제 시스템에서의 데드락

### 데이터베이스 시스템
**트랜잭션 데드락**
```
Transaction 1: Lock A → Lock B 요청
Transaction 2: Lock B → Lock A 요청
해결: 타임아웃, 데드락 탐지 후 롤백
```

### 네트워크 시스템
**TCP 연결 데드락**
- 송신 버퍼와 수신 버퍼가 모두 가득 찬 상황
- 해결: 흐름 제어, 타임아웃 메커니즘

### 파일 시스템
**다중 파일 접근**
```
프로세스 A: file1.txt 열고 → file2.txt 대기
프로세스 B: file2.txt 열고 → file1.txt 대기
해결: 파일 순서 정렬 후 접근
```

## 7. 핵심 포인트 정리

### 데드락의 본질
- **순환 의존성**: 자원이나 프로세스 간의 순환 의존 관계
- **상호 대기**: 서로가 상대방의 행동을 기다리는 상황
- **진행 불가**: 외부 개입 없이는 해결 불가능

### 실무에서의 접근
1. **설계 단계**: 데드락 예방을 위한 자원 순서 정의
2. **구현 단계**: 타임아웃과 재시도 메커니즘 구현
3. **운영 단계**: 모니터링과 로깅으로 데드락 상황 감지

### 성능 vs 안전성 트레이드오프
- **엄격한 예방**: 안전하지만 성능 저하
- **회피 기법**: 균형 잡힌 접근, 복잡성 증가  
- **탐지/복구**: 성능 우선, 복구 오버헤드 존재
- **무시 정책**: 최고 성능, 위험 감수

데드락은 **동시성 프로그래밍의 근본적인 문제**로, 시스템 설계 시 반드시 고려해야 할 중요한 개념이다. 완벽한 해결책은 없으며, 시스템의 특성에 맞는 적절한 전략 선택이 핵심이다.