# 스케줄링 알고리즘 (Scheduling Algorithm)

## 스케줄링(Scheduling)이란

### 사전적 의미
"작업의 순서를 정하는 것"

### 운영체제에서의 의미
운영체제가 여러 프로세스나 작업 중에서 어떤 것을 먼저 실행할지 결정하는 방법을 의미함

CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에, 여러 프로세스가 동시에 실행을 원할 때 실행 순서를 결정해야 함

## 핵심 배경 지식

### 프로세스 상태(Process State)
- **New**: 프로세스가 생성된 상태
- **Ready**: CPU를 할당받기를 기다리는 상태
- **Running**: CPU를 할당받아 실행 중인 상태
- **Waiting**: I/O 작업 등을 기다리는 상태
- **Terminated**: 프로세스가 종료된 상태

### Context Switching
CPU가 한 프로세스에서 다른 프로세스로 제어권을 넘기는 과정
- 현재 프로세스의 상태를 PCB(Process Control Block)에 저장
- 새로운 프로세스의 상태를 PCB에서 복원

### CPU Burst와 I/O Burst
- **CPU Burst**: 프로세스가 CPU를 사용하는 시간
- **I/O Burst**: 프로세스가 입출력을 기다리는 시간

## 스케줄링의 목적

### 1. 공정성(Fairness)
모든 프로세스가 공평하게 CPU를 사용할 수 있도록 함

### 2. 효율성(Efficiency)
CPU 사용률을 최대화하고 시스템 자원을 효율적으로 활용

### 3. 응답 시간 최소화(Response Time)
사용자의 요청에 빠르게 응답

### 4. 처리량 최대화(Throughput)
단위 시간당 완료되는 프로세스 수를 최대화

## 성능 평가 지표

### 1. 응답 시간(Response Time)
프로세스가 처음 실행되기까지 걸리는 시간

### 2. 대기 시간(Waiting Time)
Ready Queue에서 기다리는 총 시간

### 3. 반환 시간(Turnaround Time)
프로세스가 생성되어 완료될 때까지의 총 시간
`반환 시간 = 대기 시간 + 실행 시간`

### 4. CPU 사용률(CPU Utilization)
전체 시간 중 CPU가 실제로 작업을 수행한 시간의 비율

## 스케줄링 알고리즘 분류

### 선점형(Preemptive) vs 비선점형(Non-preemptive)
- **선점형**: 실행 중인 프로세스를 강제로 중단시킬 수 있음
- **비선점형**: 실행 중인 프로세스를 중단시킬 수 없고, 프로세스가 자발적으로 CPU를 반납해야 함

## 주요 스케줄링 알고리즘

### 1. First-Come, First-Served (FCFS)

#### 개념
가장 먼저 도착한 프로세스를 가장 먼저 처리하는 방식

#### 특징
- 비선점형 스케줄링
- 구현이 간단함
- 선입선출(FIFO) 큐 구조 사용

#### 장점
- 구현이 단순함
- 공정함 (먼저 온 순서대로 처리)

#### 단점
- 평균 대기 시간이 길 수 있음
- **호위 효과(Convoy Effect)**: 실행 시간이 긴 프로세스 때문에 짧은 프로세스들이 오래 기다림

#### 예시
```
프로세스  도착시간  실행시간
P1        0       24
P2        1       3  
P3        2       3

실행 순서: P1 → P2 → P3
P1: 0-24 (대기시간: 0)
P2: 24-27 (대기시간: 23)
P3: 27-30 (대기시간: 25)
평균 대기시간: (0+23+25)/3 = 16
```

### 2. Shortest Job First (SJF)

#### 개념
CPU 버스트 시간이 가장 짧은 프로세스를 우선 실행하는 방식

#### 특징
- 비선점형과 선점형 버전 모두 존재
- 이론적으로 최적의 평균 대기 시간을 보장

#### 장점
- 평균 대기 시간이 최소화됨
- 짧은 작업들이 빠르게 처리됨

#### 단점
- 실행 시간을 미리 알기 어려움
- **기아 현상(Starvation)**: 긴 프로세스가 계속 뒤로 밀림

#### 예시
```
프로세스  도착시간  실행시간
P1        0       6
P2        0       8
P3        0       7
P4        0       3

SJF 순서: P4 → P1 → P3 → P2
P4: 0-3 (대기시간: 0)
P1: 3-9 (대기시간: 3)
P3: 9-16 (대기시간: 9)
P2: 16-24 (대기시간: 16)
평균 대기시간: (0+3+9+16)/4 = 7
```

### 3. Shortest Remaining Time First (SRTF)

#### 개념
SJF의 선점형 버전으로, 남은 실행 시간이 가장 짧은 프로세스를 실행

#### 특징
- 선점형 스케줄링
- 새로운 프로세스가 도착할 때마다 스케줄링 결정

#### 장점
- 평균 대기 시간이 더욱 짧아짐
- 응답성이 좋음

#### 단점
- 컨텍스트 스위칭 오버헤드 증가
- 기아 현상 발생 가능

### 4. Priority Scheduling

#### 개념
각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스를 먼저 실행

#### 특징
- 선점형과 비선점형 버전 모두 존재
- 우선순위는 내부적(메모리 요구량, 파일 수 등) 또는 외부적(프로세스 중요도, 비용 등) 기준으로 결정

#### 장점
- 중요한 작업을 우선 처리 가능
- 시스템의 요구사항에 맞게 조정 가능

#### 단점
- **기아 현상**: 낮은 우선순위 프로세스가 무한정 기다릴 수 있음
- **해결책**: Aging 기법 - 시간이 지날수록 우선순위를 점진적으로 높임

#### 예시
```
프로세스  도착시간  실행시간  우선순위(낮을수록 높음)
P1        0       10       3
P2        0       1        1
P3        0       2        4
P4        0       1        5
P5        0       5        2

실행 순서: P2 → P5 → P1 → P3 → P4
```

### 5. Round Robin (RR)

#### 개념
각 프로세스에게 동일한 시간 할당량(Time Quantum)을 주고, 시간이 끝나면 다음 프로세스로 전환

#### 특징
- 선점형 스케줄링
- 시분할 시스템에서 주로 사용
- Time Quantum의 크기가 성능에 큰 영향을 미침

#### Time Quantum 선택
- **너무 작으면**: 컨텍스트 스위칭 오버헤드 증가
- **너무 크면**: FCFS와 유사하게 동작

#### 장점
- 모든 프로세스가 공평하게 CPU 사용
- 응답 시간이 빠름
- 기아 현상 없음

#### 단점
- 평균 대기 시간이 길 수 있음
- 컨텍스트 스위칭 오버헤드

#### 예시
```
프로세스  실행시간
P1        24
P2        3
P3        3
Time Quantum = 4

실행 순서: P1(4) → P2(3) → P3(3) → P1(4) → P1(4) → P1(4) → P1(4) → P1(4)
```

### 6. Multilevel Queue

#### 개념
프로세스를 여러 그룹으로 분류하여 각각 다른 큐에 배치하고, 큐마다 다른 스케줄링 알고리즘을 적용

#### 큐 분류 예시
- **System processes** (가장 높은 우선순위)
- **Interactive processes**
- **Interactive editing processes**  
- **Batch processes**
- **Student processes** (가장 낮은 우선순위)

#### 특징
- 큐 간에는 우선순위가 있음
- 각 큐 내에서는 독립적인 스케줄링 알고리즘 사용

#### 장점
- 프로세스 특성에 맞는 최적화 가능
- 시스템 요구사항에 유연하게 대응

#### 단점
- 낮은 우선순위 큐에서 기아 현상 발생 가능
- 설계가 복잡함

### 7. Multilevel Feedback Queue

#### 개념
Multilevel Queue의 확장으로, 프로세스가 큐 간에 이동할 수 있음

#### 동작 방식
1. 새로운 프로세스는 가장 높은 우선순위 큐에 진입
2. 할당된 시간 내에 완료되지 않으면 낮은 우선순위 큐로 이동
3. I/O 작업 후 복귀하는 프로세스는 높은 우선순위 큐로 이동

#### 일반적인 설정
- 높은 우선순위 큐: 작은 Time Quantum, RR 스케줄링
- 낮은 우선순위 큐: 큰 Time Quantum 또는 FCFS 스케줄링

#### 장점
- 대화형 프로세스와 배치 프로세스를 효과적으로 구분
- 적응적인 스케줄링
- I/O 집약적 프로세스에 높은 우선순위 부여

#### 단점
- 구현이 복잡함
- 매개변수 조정이 어려움

## 실시간 스케줄링 (Real-time Scheduling)

### 1. Rate Monotonic (RM)

#### 개념
주기가 짧은 태스크에 높은 우선순위를 부여하는 정적 우선순위 알고리즘

#### 특징
- 선점형 스케줄링
- 주기적 태스크에 사용
- 데드라인 = 주기

#### 스케줄링 가능 조건
n개 태스크에 대해: ∑(Ci/Ti) ≤ n(2^(1/n) - 1)
- Ci: 실행 시간
- Ti: 주기

### 2. Earliest Deadline First (EDF)

#### 개념
데드라인이 가장 가까운 태스크를 우선 실행하는 동적 우선순위 알고리즘

#### 특징
- 선점형 스케줄링
- 이론적으로 최적의 실시간 스케줄링 알고리즘

#### 스케줄링 가능 조건
∑(Ci/Ti) ≤ 1

## 스케줄링 알고리즘 비교

| 알고리즘 | 선점/비선점 | 장점 | 단점 | 적용 분야 |
|---------|------------|------|------|----------|
| FCFS | 비선점 | 간단, 공정 | 호위 효과 | 배치 시스템 |
| SJF | 비선점 | 최적 평균 대기시간 | 기아 현상, 예측 어려움 | 배치 시스템 |
| SRTF | 선점 | 응답성 좋음 | 오버헤드, 기아 현상 | 시분할 시스템 |
| Priority | 선택 가능 | 중요도 반영 | 기아 현상 | 범용 시스템 |
| RR | 선점 | 공정성, 응답성 | 오버헤드 | 시분할 시스템 |
| MLQ | 선점 | 프로세스 특성 반영 | 복잡성, 기아 현상 | 대형 시스템 |
| MLFQ | 선점 | 적응성, 효율성 | 구현 복잡 | 현대 OS |

## 현대 운영체제에서의 적용

### Linux CFS (Completely Fair Scheduler)
- 가상 런타임을 기반으로 한 공정한 스케줄링
- Red-Black Tree를 사용한 효율적인 구현

### Windows 스케줄러
- 32개 우선순위 레벨
- Round Robin과 Priority 스케줄링 조합

## 핵심 포인트 정리

1. **스케줄링은 CPU 효율성과 사용자 만족도의 균형을 맞추는 것**
2. **각 알고리즘은 고유한 장단점이 있어 시스템 특성에 맞게 선택해야 함**
3. **현대 시스템은 여러 알고리즘을 조합하여 사용함**
4. **실시간 시스템에서는 데드라인 보장이 가장 중요함**

스케줄링 알고리즘의 선택은 시스템의 목적, 프로세스의 특성, 성능 요구사항을 종합적으로 고려하여 결정해야 함



-----


## 모르는 단어들

## Context Switching 오버헤드

**CPU가 프로세스를 바꿀 때 드는 비용**을 의미함

- CPU가 프로세스 A에서 프로세스 B로 바꿀 때, A의 상태를 저장하고 B의 상태를 불러오는 작업이 필요
- 이 과정에서 **캐시 메모리 초기화, 레지스터 값 저장/복원** 등의 작업이 발생
- 이런 작업들은 **실제 프로그램 실행과는 관계없는 부가적인 작업**이라서 오버헤드라고 부름

**예시**: 책을 읽다가 다른 책으로 바꿀 때, 현재 페이지에 책갈피를 꽂고 새 책의 책갈피 위치를 찾는 시간

---

## 기아 현상 (Starvation)

**특정 프로세스가 계속해서 실행 기회를 얻지 못하는 현상**을 의미함

- 우선순위가 높은 프로세스들이 계속 들어오면, 우선순위가 낮은 프로세스는 **무한정 기다림**
- SJF 스케줄링에서 짧은 작업들이 계속 들어오면, 긴 작업은 **영원히 실행되지 못할 수 있음**

**예시**: 은행에서 VIP 고객들이 계속 오면, 일반 고객은 계속 기다려야 하는 상황

**해결책**: Aging 기법 - 기다린 시간이 길수록 우선순위를 점점 높여줌

---

## I/O 집약적 프로세스 (I/O Intensive Process)

**입출력 작업을 많이 하는 프로세스**를 의미함

- **I/O 작업**: 파일 읽기/쓰기, 네트워크 통신, 키보드 입력, 화면 출력 등
- CPU 연산보다는 **데이터를 주고받는 작업**이 대부분인 프로세스

**특징**:
- CPU를 조금 쓰고 I/O 대기 시간이 김
- 자주 대기 상태(Waiting)로 들어감
- 응답성이 중요함

**예시**:
- 텍스트 에디터 (키보드 입력, 파일 저장)
- 웹브라우저 (네트워크 통신)
- 동영상 플레이어 (파일 읽기, 화면 출력)

**반대 개념**: CPU 집약적 프로세스 - 계산 작업이 많은 프로세스 (과학 계산, 이미지 처리 등)

**스케줄링에서 중요한 이유**: I/O 집약적 프로세스는 높은 우선순위를 줘서 빠르게 처리하는 것이 전체 시스템 성능에 좋음


-----

## Red-Black Tree

**자가 균형 이진 탐색 트리**를 의미함

### 기본 개념
- 이진 탐색 트리의 한 종류
- 각 노드가 **빨간색** 또는 **검은색**을 가짐
- 특별한 규칙으로 트리의 균형을 자동으로 맞춤

### 핵심 규칙 (간단히)
1. 루트 노드는 검은색
2. 빨간 노드의 자식은 반드시 검은색
3. 모든 경로에서 검은 노드의 개수가 같음

### 왜 중요한가?
- 삽입/삭제/검색이 모두 **O(log n)** 시간 보장
- 최악의 경우에도 성능이 안정적임

### 실제 사용 예시
- **Linux CFS 스케줄러**: 실행 대기 중인 프로세스들을 관리
- C++ STL의 map, set
- Java의 TreeMap

**간단 비유**: 도서관 책장처럼 항상 정리된 상태를 유지하는 자료구조. 책을 넣거나 빼도 자동으로 정리됨

Linux에서는 가상 런타임이 작은 프로세스(더 적게 실행된 프로세스)가 트리의 왼쪽에 위치해서 빠르게 찾을 수 있음

