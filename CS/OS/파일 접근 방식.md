# 파일 접근 방식

## 들어가기 전에

### 파일 접근이란
파일에 저장된 데이터를 읽거나 쓰는 방법

### 파일 할당 방식과의 관계
- **파일 할당 방식**: 디스크에 파일을 어떻게 저장할 것인가
- **파일 접근 방식**: 저장된 파일의 데이터를 어떻게 읽을 것인가

```
저장 방식에 따라 접근 방식이 제한됨:
- 연속 할당 → 순차/직접 접근 모두 가능
- 연결 할당 → 순차 접근만 가능
- 인덱스 할당 → 순차/직접 접근 모두 가능
```

---

## 1. 순차 접근 (Sequential Access)

### 정의
파일의 데이터를 처음부터 순서대로 접근하는 방식

### 동작 원리
```
파일: [A][B][C][D][E]
          ↓
읽기 포인터가 순차적으로 이동
A 읽기 → B 읽기 → C 읽기 → D 읽기 → E 읽기
```

### 특징
- 파일을 **처음부터 끝까지** 순서대로 읽음
- 중간 데이터에 접근하려면 앞부분을 모두 거쳐야 함
- 읽기 포인터가 자동으로 다음 위치로 이동
- 테이프 저장 장치와 유사한 방식

### 연산
```
read_next()  - 다음 데이터 읽기
write_next() - 다음 위치에 쓰기
reset()      - 파일 처음으로 이동
```

### 장점
- 구현이 단순함
- 모든 파일 할당 방식에서 사용 가능
- 순차 처리에 최적화
- 버퍼링 효율적

### 단점
- 특정 위치 데이터 접근 느림
- 중간 데이터 수정 어려움
- 파일 전체를 읽어야 하는 경우 비효율적

### 사용 예시
```
로그 파일:
2025-01-01 10:00 - 시스템 시작
2025-01-01 10:05 - 사용자 로그인
2025-01-01 10:10 - 파일 생성
...

→ 처음부터 끝까지 순차적으로 읽음
```

### 적합한 응용
- 로그 파일 처리
- 백업/복원 작업
- 스트리밍 데이터 (음악, 동영상)
- 배치 처리 시스템
- 컴파일러 (소스 코드 순차 읽기)

---

## 2. 직접 접근 (Direct Access / Random Access)

### 정의
파일의 임의 위치에 바로 접근하는 방식

### 동작 원리
```
파일: [A][B][C][D][E]
       0  1  2  3  4  ← 블록 번호

위치 2번으로 직접 이동 → C 읽기
위치 4번으로 직접 이동 → E 읽기
```

### 특징
- 블록 번호나 오프셋으로 **직접 접근**
- 중간 과정 없이 원하는 위치로 바로 이동
- 읽기/쓰기 순서 자유로움
- 디스크와 같은 임의 접근 저장 장치 필요

### 연산
```
read(n)     - n번째 블록 읽기
write(n)    - n번째 블록 쓰기
position(n) - n번째 위치로 이동
```

### 장점
- 특정 위치 빠른 접근
- 데이터 수정 용이
- 효율적인 검색 가능
- 다중 사용자 환경에 적합

### 단점
- 구현 복잡함
- 연결 할당 방식에서는 사용 불가
- 블록 번호나 위치 관리 필요

### 사용 예시
```
데이터베이스 레코드:
ID 100: 홍길동, 서울, ...
ID 200: 김철수, 부산, ...
ID 300: 이영희, 대구, ...

→ ID 200 검색: 해당 레코드 위치로 직접 접근
```

### 적합한 응용
- 데이터베이스 시스템
- 가상 메모리 페이지 파일
- 멀티미디어 편집 (특정 프레임 접근)
- 인덱스 파일
- 임의 접근이 빈번한 응용 프로그램

---

## 3. 인덱스 순차 접근 (Indexed Sequential Access)

### 정의
인덱스를 이용하여 순차 접근과 직접 접근을 결합한 방식

### 구조
```
인덱스 파일:
┌──────┬──────┐
│ 키   │ 위치 │
├──────┼──────┤
│ 100  │  0   │
│ 200  │  5   │
│ 300  │ 10   │
└──────┴──────┘
     ↓
데이터 파일:
[레코드100][레코드101]...[레코드200][레코드201]...
    0         1            5         6
```

### 동작 원리
1. 인덱스에서 키 검색
2. 해당 위치로 직접 이동
3. 해당 위치부터 순차 접근

### 특징
- **인덱스**: 키와 블록 위치 매핑
- **데이터 파일**: 키 순서대로 정렬
- 인덱스를 통한 빠른 검색
- 정렬된 순서로 순차 처리 가능

### 연산
```
search_index(key)    - 인덱스에서 키 검색
read_sequential()    - 순차 읽기
insert(key, data)    - 삽입 (인덱스 갱신)
delete(key)          - 삭제 (인덱스 갱신)
```

### 장점
- 직접 접근과 순차 접근 장점 결합
- 범위 검색 효율적 (예: 100~200 사이)
- 정렬된 순서 유지
- 다양한 검색 패턴 지원

### 단점
- 인덱스 유지 오버헤드
- 삽입/삭제 시 인덱스 재구성 필요
- 추가 저장 공간 필요 (인덱스)
- 구현 복잡도 증가

### 다단계 인덱스
```
최상위 인덱스:
┌──────┬──────┐
│  키  │ 위치 │
├──────┼──────┤
│ 1000 │  0   │
│ 5000 │ 100  │
└──────┴──────┘
     ↓
1차 인덱스:
┌──────┬──────┐
│  100 │  0   │
│  200 │  5   │
│  300 │ 10   │
└──────┴──────┘
     ↓
데이터 파일
```

큰 파일에서 빠른 검색 가능

### 사용 예시
```
학생 정보 시스템:
인덱스: 학번 → 레코드 위치
학번 순으로 정렬된 데이터

검색: 학번 20231234 찾기
1. 인덱스에서 20231234 검색
2. 해당 위치로 이동
3. 레코드 읽기

범위 검색: 20231000~20231999
1. 인덱스에서 시작 위치 찾기
2. 순차적으로 읽기
```

### 적합한 응용
- 대용량 데이터베이스
- 정렬된 파일 처리
- 범위 검색이 필요한 시스템
- 트랜잭션 처리 시스템
- 파일 관리 시스템

---

## 4. 접근 방식 비교

### 성능 비교

| 접근 방식 | 순차 읽기 | 직접 읽기 | 삽입/삭제 | 저장 공간 |
|-----------|-----------|-----------|-----------|-----------|
| 순차 접근 | 빠름 | 느림 | 느림 | 적음 |
| 직접 접근 | 보통 | 빠름 | 보통 | 보통 |
| 인덱스 순차 | 빠름 | 빠름 | 느림 | 많음 (인덱스) |

### 파일 할당 방식과의 호환성

| 할당 방식 | 순차 접근 | 직접 접근 | 인덱스 순차 |
|-----------|-----------|-----------|-------------|
| 연속 할당 | ✓ | ✓ | ✓ |
| 연결 할당 | ✓ | ✗ | ✗ |
| 인덱스 할당 | ✓ | ✓ | ✓ |

---

## 5. 실제 시스템에서의 구현

### UNIX/Linux 파일 시스템

```c
// 순차 접근
FILE *fp = fopen("file.txt", "r");
while (fgets(buffer, SIZE, fp) != NULL) {
    // 순차적으로 읽기
}

// 직접 접근
fseek(fp, 100, SEEK_SET);  // 100번째 바이트로 이동
fread(buffer, SIZE, 1, fp);  // 읽기

// 임의 위치 쓰기
fseek(fp, 200, SEEK_SET);
fwrite(data, SIZE, 1, fp);
```

### 데이터베이스 시스템

```sql
-- 인덱스 생성 (인덱스 순차 접근)
CREATE INDEX idx_student_id ON students(student_id);

-- 직접 접근 (인덱스 사용)
SELECT * FROM students WHERE student_id = 20231234;

-- 범위 검색 (인덱스 순차)
SELECT * FROM students 
WHERE student_id BETWEEN 20231000 AND 20231999
ORDER BY student_id;
```

### 멀티미디어 파일

```
동영상 파일:
- 전체 재생: 순차 접근
- 특정 시간 이동: 직접 접근
- 챕터 이동: 인덱스 순차 접근

구현:
- 타임스탬프 인덱스 테이블 유지
- 키 프레임 위치 기록
- 빠른 탐색 지원
```

---

## 6. 선택 기준

### 순차 접근을 선택하는 경우
- 파일 전체를 처음부터 끝까지 처리
- 로그 분석, 백업, 스트리밍
- 메모리 제약이 있는 환경
- 단순한 구조가 필요한 경우

### 직접 접근을 선택하는 경우
- 특정 레코드 빠른 접근 필요
- 임의 위치 데이터 수정 빈번
- 대화형 응용 프로그램
- 실시간 시스템

### 인덱스 순차 접근을 선택하는 경우
- 직접 접근과 순차 접근 모두 필요
- 범위 검색이 빈번함
- 대용량 정렬된 데이터
- 복잡한 검색 패턴

---

## 7. 성능 최적화

### 버퍼링 (Buffering)
```
순차 접근 최적화:
- 여러 블록을 미리 읽어 버퍼에 저장
- 디스크 I/O 횟수 감소
- 연속된 데이터 읽기 빠름

예시:
한 번에 1블록 읽기: 1000번 I/O
한 번에 10블록 읽기: 100번 I/O
```

### 캐싱 (Caching)
```
직접 접근 최적화:
- 자주 사용하는 블록을 메모리에 유지
- 반복 접근 시 디스크 I/O 불필요

예시:
데이터베이스 페이지 캐시
파일 시스템 버퍼 캐시
```

### 인덱스 최적화
```
인덱스 순차 접근 최적화:
- B-트리, B+트리 인덱스 사용
- 인덱스를 메모리에 캐싱
- 다단계 인덱스로 검색 속도 향상

검색 복잡도:
선형 검색: O(n)
인덱스 검색: O(log n)
```

---

## 8. 핵심 정리

### 접근 방식의 특징

**순차 접근**
- 처음부터 순서대로 읽기
- 단순, 모든 할당 방식 지원
- 로그, 스트림, 백업에 적합

**직접 접근**
- 임의 위치 바로 접근
- 빠른 검색, 수정 용이
- 데이터베이스, 가상 메모리에 적합

**인덱스 순차 접근**
- 인덱스로 위치 찾고 순차 읽기
- 양쪽 장점 결합
- 대용량 정렬 데이터에 적합

### 선택의 기준
```
데이터 접근 패턴:
- 순차적 → 순차 접근
- 임의적 → 직접 접근
- 혼합형 → 인덱스 순차 접근

파일 할당 방식:
- 연결 할당 → 순차 접근만 가능
- 연속/인덱스 할당 → 모든 방식 가능

성능 요구사항:
- 단순, 저비용 → 순차 접근
- 빠른 접근 → 직접 접근
- 다양한 패턴 → 인덱스 순차 접근
```