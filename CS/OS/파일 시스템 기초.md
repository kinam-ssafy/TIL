# 파일 시스템 기초

## 1. 파일(File)의 정의

### 사전적 의미
서로 관련된 정보들의 집합

### 운영체제 관점
- 이름을 가진 데이터의 논리적 저장 단위
- 디스크의 특정 위치에 저장된 정보
- 프로그램이 읽고 쓸 수 있는 데이터 단위

---

## 2. 파일의 구성 요소

### 파일 데이터 (File Data)
실제 내용 (텍스트, 이미지, 실행 코드 등)

### 파일 속성 (File Attributes) - 메타데이터
```
- 파일 이름
- 파일 타입 (확장자)
- 파일 크기
- 생성 날짜/수정 날짜
- 접근 권한
- 소유자 정보
- 저장 위치 정보
```

---

## 3. 파일 시스템(File System)의 정의

디스크에 파일을 체계적으로 저장하고 관리하는 방법

### 주요 기능
- 파일과 디렉토리 생성, 삭제, 수정
- 파일 이름과 실제 저장 위치 매핑
- 저장 공간 할당 및 관리
- 파일 접근 권한 관리
- 데이터 무결성 보장

---

## 4. 디렉토리(Directory) 구조

### 정의
파일들을 그룹화하여 관리하는 특별한 파일

### 트리 구조 (Tree Structure)
```
루트 디렉토리
├── 디렉토리 A
│   ├── 파일 1
│   └── 서브 디렉토리
│       └── 파일 2
└── 디렉토리 B
    └── 파일 3
```

---

## 5. 파일 경로 (Path)

### 절대 경로 (Absolute Path)
루트 디렉토리부터 시작하는 전체 경로
```
Windows: C:\Users\Documents\file.txt
Linux:   /home/user/documents/file.txt
```

### 상대 경로 (Relative Path)
현재 작업 디렉토리를 기준으로 한 경로
```
현재 위치: /home/user/
상대 경로: documents/file.txt
상위 이동: ../other/file.txt
```

---

## 6. 디스크 저장 구조

### 블록(Block)
- 디스크의 최소 저장 단위
- 일반적으로 4KB 크기
- 파일은 하나 이상의 블록에 저장됨

```
디스크 블록 구조:
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │
└───┴───┴───┴───┴───┴───┴───┴───┘
```

---

## 7. 파일 할당 방법

### (1) 연속 할당 (Contiguous Allocation)

#### 특징
파일을 연속된 블록에 저장

```
파일 A (3블록):
┌───┬───┬───┬───┬───┬───┬───┬───┐
│   │ A │ A │ A │   │   │   │   │
└───┴───┴───┴───┴───┴───┴───┴───┘
    ↑시작    ↑끝

저장 정보:
- 시작 블록 번호: 1
- 블록 개수: 3
```

#### 장점
- 빠른 접근 속도
- 순차 접근 효율적
- 구현 단순

#### 단점
- 외부 단편화 발생
- 파일 크기 변경 어려움
- 공간 낭비 가능

---

### (2) 연결 할당 (Linked Allocation)

#### 특징
각 블록이 다음 블록의 위치를 포인터로 저장

```
파일 A (3블록):
┌───┬───┬───┬───┬───┬───┬───┬───┐
│   │A→3│   │A→7│   │   │   │ A │
└───┴───┴───┴───┴───┴───┴───┴───┘
      1       3               7

블록 1 → 블록 3 → 블록 7 → 끝
```

#### 장점
- 외부 단편화 없음
- 파일 크기 동적 확장 가능
- 빈 블록 효율적 활용

#### 단점
- 순차 접근만 가능 (직접 접근 불가)
- 포인터 저장 공간 필요
- 포인터 손상 시 데이터 유실

---

### (3) 인덱스 할당 (Indexed Allocation)

#### 특징
인덱스 블록에 모든 데이터 블록 위치 저장

```
인덱스 블록:
┌─────────┐
│블록 2   │
│블록 5   │
│블록 7   │
└─────────┘
     ↓
┌───┬───┬───┬───┬───┬───┬───┬───┐
│idx│   │ A │   │   │ A │   │ A │
└───┴───┴───┴───┴───┴───┴───┴───┘
  0       2           5       7
```

#### 장점
- 직접 접근 가능
- 외부 단편화 없음
- 파일 크기 변경 용이

#### 단점
- 인덱스 블록 공간 오버헤드
- 작은 파일도 인덱스 블록 필요
- 큰 파일은 다단계 인덱스 필요

---

## 8. 실제 파일 시스템 구현

### FAT (File Allocation Table)

#### 구조
연결 할당 방식 개선 - 포인터를 별도 테이블에 저장

```
FAT 테이블:
┌─────┬──────┐
│블록 │다음블록│
├─────┼──────┤
│  1  │  3   │
│  2  │  -   │
│  3  │  7   │
│  4  │  -   │
│  5  │  -   │
│  6  │  -   │
│  7  │ EOF  │
└─────┴──────┘

파일 정보:
- 시작 블록: 1
- FAT에서 연결 추적: 1→3→7→끝
```

#### 특징
- 포인터를 블록 밖에 저장하여 공간 효율적
- FAT 테이블을 메모리에 캐시하여 빠른 접근
- FAT12, FAT16, FAT32 버전 존재

---

### inode 방식 (UNIX/Linux)

#### 구조
인덱스 할당 방식 개선 - 다단계 인덱싱

```
inode 구조:
┌──────────────────┐
│ 메타데이터        │
│ - 크기, 권한     │
│ - 날짜, 소유자   │
├──────────────────┤
│ 직접 포인터 (12개)│
│ [0] → 블록       │
│ [1] → 블록       │
│ ...              │
│ [11] → 블록      │
├──────────────────┤
│ 간접 포인터      │
│ [12] → 1단계 간접│
│ [13] → 2단계 간접│
│ [14] → 3단계 간접│
└──────────────────┘
```

#### 다단계 인덱싱

**직접 포인터**: 작은 파일 (48KB)
```
inode → 블록1, 블록2, ..., 블록12
```

**1단계 간접**: 중간 파일 (~4MB)
```
inode → 간접블록 → [블록1, 블록2, ..., 블록1024]
```

**2단계 간접**: 큰 파일 (~4GB)
```
inode → 2차간접 → 간접블록들 → 실제 블록들
```

#### 장점
- 작은 파일: 빠른 접근 (직접 포인터)
- 큰 파일: 다단계로 확장 가능
- 파일 속성과 위치 정보 통합 관리

---

## 9. 디렉토리 구현

### 디렉토리 엔트리

디렉토리는 파일 목록을 저장하는 특수 파일

```
디렉토리 내용:
┌────────────┬────────┬─────────┐
│  파일 이름  │ inode  │  타입   │
├────────────┼────────┼─────────┤
│ file1.txt  │  100   │  파일   │
│ file2.pdf  │  200   │  파일   │
│ subdir     │  300   │디렉토리 │
└────────────┴────────┴─────────┘
```

### 파일 접근 과정

```
경로: /home/user/file.txt

1. 루트 디렉토리(/) 접근
   → home 디렉토리의 inode 번호 찾기

2. home 디렉토리 접근
   → user 디렉토리의 inode 번호 찾기

3. user 디렉토리 접근
   → file.txt의 inode 번호 찾기

4. file.txt의 inode 접근
   → 데이터 블록 위치 확인

5. 데이터 블록 읽기
```

---

## 10. 빈 공간 관리 (Free Space Management)

### (1) 비트맵 (Bitmap)

각 블록마다 1비트 할당

```
비트맵:
블록: 0  1  2  3  4  5  6  7
비트: 1  0  1  1  0  0  0  1

0 = 사용 중
1 = 비어있음
```

**장점**: 간단하고 빠름  
**단점**: 큰 디스크는 비트맵도 큼

### (2) 연결 리스트

빈 블록들을 링크로 연결

```
첫 번째 빈 블록: 1
블록1 → 블록4 → 블록5 → NULL
```

**장점**: 공간 효율적 (빈 공간이 적을 때)  
**단점**: 순차 탐색 필요

### (3) 그룹화

연속된 빈 블록을 그룹으로 관리

```
빈 공간 목록:
(시작: 10, 개수: 5)
(시작: 20, 개수: 3)
(시작: 50, 개수: 10)
```

---

## 11. 주요 파일 시스템 비교

### Windows
- **FAT32**: 호환성 우수, 4GB 파일 제한
- **NTFS**: 저널링, 큰 파일 지원, 보안 기능

### Linux
- **ext4**: 저널링, 안정성, 널리 사용
- **XFS**: 대용량 파일 처리 우수
- **Btrfs**: 스냅샷, 압축, 최신 기능

### macOS
- **APFS**: SSD 최적화, 암호화, 스냅샷

---

## 12. 핵심 정리

### 파일 시스템의 역할
1. 파일 저장 및 검색
2. 디렉토리 구조 관리
3. 저장 공간 할당 및 회수
4. 접근 권한 제어
5. 데이터 무결성 보장

### 할당 방식 비교

| 방식 | 접근 속도 | 공간 효율 | 크기 변경 | 단편화 |
|------|-----------|-----------|-----------|--------|
| 연속 할당 | 빠름 | 보통 | 어려움 | 외부 |
| 연결 할당 | 순차만 | 좋음 | 쉬움 | 없음 |
| 인덱스 할당 | 직접 가능 | 보통 | 쉬움 | 없음 |

### 실제 구현
- **FAT**: 연결 할당 + 별도 테이블
- **inode**: 인덱스 할당 + 다단계 구조