# Context Switching (문맥 교환)

## Context Switching이란

### 사전적 의미
"문맥 교환" - 하나의 작업에서 다른 작업으로 전환하는 과정

### 운영체제에서의 의미
CPU가 현재 실행 중인 프로세스에서 다른 프로세스로 실행 제어권을 넘기는 과정

멀티태스킹을 가능하게 하는 핵심 메커니즘으로, 여러 프로세스가 동시에 실행되는 것처럼 보이게 함

## Context란 무엇인가

### Context의 정의
프로세스가 실행되는 상황에서의 **모든 정보**를 의미함

### Context에 포함되는 정보

#### 1. CPU 레지스터 값
- **Program Counter (PC)**: 다음에 실행할 명령어의 주소
- **Stack Pointer (SP)**: 현재 스택의 위치
- **Base Register, Limit Register**: 메모리 보호를 위한 레지스터
- **General Purpose Registers**: 범용 레지스터들 (AX, BX, CX 등)
- **Status Register**: CPU 상태 정보

#### 2. 프로세스 상태 정보
- 프로세스 ID (PID)
- 프로세스 상태 (Ready, Running, Waiting 등)
- 우선순위
- 부모 프로세스 정보

#### 3. 메모리 관리 정보
- 페이지 테이블 포인터
- 메모리 할당 정보
- 가상 메모리 정보

#### 4. I/O 상태 정보
- 열린 파일 목록
- I/O 요청 상태
- 디바이스 할당 정보

## Context Switching이 발생하는 상황

### 1. 시간 할당량 만료 (Time Quantum Expiry)
- Round Robin 스케줄링에서 프로세스의 할당 시간이 끝남
- 타이머 인터럽트가 발생하여 스케줄러가 다른 프로세스를 선택

### 2. I/O 요청 (I/O Request)
- 프로세스가 파일 읽기, 네트워크 통신 등을 요청
- I/O 완료까지 기다려야 하므로 다른 프로세스에게 CPU 양보

### 3. 시스템 콜 (System Call)
- 프로세스가 운영체제 서비스를 요청
- 커널 모드로 전환되면서 다른 프로세스가 실행될 수 있음

### 4. 인터럽트 (Interrupt)
- 하드웨어 인터럽트 발생 (타이머, I/O 완료 등)
- 인터럽트 처리 후 다른 프로세스로 전환될 수 있음

### 5. 우선순위 선점 (Priority Preemption)
- 더 높은 우선순위의 프로세스가 Ready 상태가 됨
- 현재 프로세스를 중단하고 높은 우선순위 프로세스 실행

## Context Switching 과정

### 1단계: 현재 프로세스 상태 저장
```
1. 인터럽트나 시스템 콜 발생
2. CPU 레지스터 값들을 PCB에 저장
   - Program Counter 저장
   - 모든 범용 레지스터 저장
   - Stack Pointer 저장
   - 상태 레지스터 저장
3. 프로세스 상태를 Running → Ready/Waiting으로 변경
4. PCB를 해당 큐에 삽입
```

### 2단계: 다음 프로세스 선택
```
1. 스케줄러 알고리즘에 따라 다음 실행할 프로세스 선택
2. Ready Queue에서 선택된 프로세스의 PCB 가져오기
3. 선택된 프로세스 상태를 Ready → Running으로 변경
```

### 3단계: 새 프로세스 상태 복원
```
1. 새 프로세스의 PCB에서 레지스터 값들 복원
   - Program Counter 복원
   - 모든 범용 레지스터 복원
   - Stack Pointer 복원
   - 상태 레지스터 복원
2. 메모리 관리 정보 업데이트
3. 새 프로세스 실행 시작
```

## PCB (Process Control Block)

### PCB란
각 프로세스의 모든 정보를 저장하는 운영체제의 자료구조

### PCB의 구조
```
PCB {
    프로세스 ID (PID)
    프로세스 상태 (State)
    Program Counter
    CPU 레지스터들
    CPU 스케줄링 정보 (우선순위, 큐 포인터)
    메모리 관리 정보 (페이지 테이블 포인터)
    회계 정보 (CPU 사용 시간, 실행 시간)
    I/O 상태 정보 (할당된 I/O 디바이스, 파일 목록)
    부모/자식 프로세스 정보
}
```

## Context Switching의 오버헤드

### 직접적 오버헤드

#### 1. 레지스터 저장/복원 비용
- CPU 레지스터는 수십 개에서 수백 개
- 각각을 메모리에 저장하고 복원하는 시간

#### 2. 메모리 접근 비용
- PCB를 읽고 쓰기 위한 메모리 접근
- 페이지 테이블 교체 비용

#### 3. 스케줄러 실행 비용
- 다음 프로세스를 선택하는 알고리즘 실행 시간

### 간접적 오버헤드

#### 1. 캐시 미스 (Cache Miss)
**가장 큰 오버헤드 원인**

- **문제**: 새 프로세스는 이전 프로세스와 다른 메모리 영역 사용
- **결과**: 캐시에 있던 데이터가 무용지물이 됨
- **영향**: 메모리 접근이 10-100배 느려짐

#### 2. TLB (Translation Lookaside Buffer) 미스
- 가상 주소를 물리 주소로 변환하는 캐시 무효화
- 페이지 테이블 접근 횟수 증가

#### 3. 파이프라인 플러시 (Pipeline Flush)
- CPU 명령어 파이프라인 초기화
- 새로운 명령어로 파이프라인 재구성 필요

## 오버헤드 최소화 방법

### 1. 적절한 Time Quantum 설정
```
Time Quantum이 너무 작으면:
- Context Switching 횟수 증가
- 오버헤드 증가

Time Quantum이 너무 크면:
- 응답 시간 증가
- FCFS와 유사하게 동작

최적 값: 일반적으로 10-100ms
```

### 2. 스레드 사용
- 같은 프로세스 내 스레드 간 전환은 오버헤드가 적음
- Code, Data, Heap 영역을 공유하므로 캐시 무효화가 적음

### 3. 프로세서 친화성 (Processor Affinity)
- 프로세스를 특정 CPU 코어에 고정
- 해당 코어의 캐시 활용도 향상

### 4. 하드웨어 지원
- 빠른 레지스터 저장/복원 명령어
- 하드웨어 가상화 지원

## Context Switching 측정

### 시간 측정 방법
```c
#include <sys/time.h>

struct timeval start, end;
gettimeofday(&start, NULL);

// Context switching 발생하는 작업
sched_yield();  // 자발적으로 CPU 양보

gettimeofday(&end, NULL);
long microseconds = (end.tv_sec - start.tv_sec) * 1000000 + 
                   (end.tv_usec - start.tv_usec);
```

### 일반적인 Context Switching 시간
- **마이크로초(μs) 단위**: 1-10 μs
- **시스템에 따라 차이**: 하드웨어, OS, 캐시 크기에 따라 변동

## Thread vs Process Context Switching

### Process Context Switching
```
오버헤드가 큰 이유:
1. 완전히 다른 메모리 공간
2. 모든 캐시 무효화
3. 페이지 테이블 교체
4. 모든 레지스터 저장/복원
```

### Thread Context Switching
```
오버헤드가 작은 이유:
1. 같은 메모리 공간 공유
2. 캐시 대부분 유지
3. 페이지 테이블 공유
4. 일부 레지스터만 저장/복원 (Stack Pointer, Program Counter 등)
```

## 실제 사례 분석

### 웹 서버에서의 Context Switching
```
문제 상황:
- 많은 클라이언트 요청
- 각 요청마다 프로세스 생성
- 빈번한 Context Switching

해결책:
- 스레드 풀 사용
- 비동기 I/O 활용
- 이벤트 기반 아키텍처 도입
```

### 게임에서의 Context Switching
```
요구사항:
- 실시간 응답성
- 낮은 지연시간

최적화:
- 게임 로직을 하나의 프로세스에서 처리
- 렌더링, 사운드, 네트워크를 분리된 스레드로 처리
- Context Switching 최소화
```

## 모니터링 도구

### Linux에서 Context Switching 확인
```bash
# 시스템 전체 Context Switch 수
cat /proc/stat | grep ctxt

# 특정 프로세스의 Context Switch
cat /proc/PID/status | grep ctxt

# vmstat으로 실시간 모니터링
vmstat 1

# top 명령어의 cs 필드
top
```

### 성능 분석
```bash
# perf 도구 사용
perf record -e context-switches ./program
perf report

# strace로 시스템 콜 추적
strace -c ./program
```

## 최신 기술 동향

### 1. 하드웨어 가상화 지원
- Intel VT-x, AMD-V
- 가상머신 간 Context Switching 최적화

### 2. 컨테이너 기술
- Docker, Kubernetes
- 가벼운 가상화로 Context Switching 오버헤드 감소

### 3. 사용자 수준 스레드
- Go의 고루틴, Rust의 async/await
- OS 레벨 Context Switching 우회

## 핵심 포인트 정리

1. **Context Switching은 멀티태스킹의 핵심이지만 성능 비용이 큼**
2. **캐시 미스가 가장 큰 오버헤드 원인**
3. **적절한 Time Quantum 설정이 중요함**
4. **스레드 사용으로 오버헤드를 줄일 수 있음**
5. **현대 시스템은 하드웨어와 소프트웨어 최적화를 통해 비용을 최소화함**

Context Switching은 운영체제가 효율적으로 여러 작업을 처리하기 위해 반드시 필요한 과정이지만, 그 비용을 이해하고 최적화하는 것이 시스템 성능 향상의 핵심임