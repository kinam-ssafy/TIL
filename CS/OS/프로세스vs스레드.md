# 프로세스 vs 스레드

## 1. 기본 개념 이해

### 프로그램(Program)
- **사전적 의미**: 어떤 작업을 위해 실행할 수 있는 파일
- **특징**: 하드디스크에 저장되어 있는 정적인 상태의 코드 덩어리

### 프로세스(Process)
- **사전적 의미**: 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- **핵심 정의**: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
- **운영체제 관점**: 시스템 자원을 할당받는 작업의 단위

#### 프로세스가 할당받는 시스템 자원
- CPU 시간
- 독립된 메모리 영역 (Code, Data, Stack, Heap)
- 파일 디스크립터
- 프로세스 ID (PID)

### 스레드(Thread)
- **사전적 의미**: 프로세스 내에서 실행되는 여러 흐름의 단위
- **핵심 정의**: 프로세스가 할당받은 자원을 이용하는 실행의 단위
- **실행 관점**: 프로세스의 특정한 수행 경로

## 2. 메모리 구조의 차이

### 프로세스 메모리 구조
```
프로세스 A     프로세스 B
┌─────────┐   ┌─────────┐
│  Code   │   │  Code   │
├─────────┤   ├─────────┤
│  Data   │   │  Data   │
├─────────┤   ├─────────┤
│  Heap   │   │  Heap   │
├─────────┤   ├─────────┤
│  Stack  │   │  Stack  │
└─────────┘   └─────────┘
   독립적        독립적
```

### 스레드 메모리 구조
```
      하나의 프로세스
┌─────────────────────────┐
│         Code            │ ← 모든 스레드가 공유
├─────────────────────────┤
│         Data            │ ← 모든 스레드가 공유
├─────────────────────────┤
│         Heap            │ ← 모든 스레드가 공유
├─────────┬─────────┬─────┤
│ Stack1  │ Stack2  │Stack3│ ← 각 스레드별로 독립
└─────────┴─────────┴─────┘
  스레드1   스레드2   스레드3
```

## 3. 주요 특징 비교

### 프로세스의 특징
- **독립성**: 각각 독립된 메모리 영역을 할당받음
- **안전성**: 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않음
- **통신 방식**: IPC(Inter-Process Communication) 필요
  - 파이프(Pipe)
  - 소켓(Socket)
  - 공유 메모리(Shared Memory)
  - 메시지 큐(Message Queue)

### 스레드의 특징
- **공유성**: Code, Data, Heap 영역을 공유하고 Stack만 독립적으로 할당
- **효율성**: 메모리와 시스템 자원을 효율적으로 사용
- **통신 방식**: 공유 메모리를 통한 직접적인 데이터 교환 가능
- **위험성**: 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있음

## 4. Context Switching의 차이

### 프로세스 Context Switching
```
1. 현재 프로세스의 상태 저장
2. CPU 캐시 메모리 초기화 (무거운 작업)
3. 다음 프로세스의 상태 복원
4. 메모리 매핑 테이블 변경
```
**오버헤드**: 크다 (캐시 초기화, 메모리 매핑 변경 등)

### 스레드 Context Switching
```
1. 현재 스레드의 레지스터 상태 저장
2. 다음 스레드의 레지스터 상태 복원
3. Stack 포인터 변경
```
**오버헤드**: 작다 (레지스터와 Stack 정보만 변경)

## 5. 멀티 프로세스 vs 멀티 스레드

### 멀티 프로세스
**장점**
- 안정성: 하나의 프로세스가 죽어도 다른 프로세스에 영향 없음
- 독립성: 각 프로세스가 독립적으로 동작

**단점**
- 높은 메모리 사용량
- 큰 Context Switching 오버헤드
- 복잡한 IPC 통신

### 멀티 스레드
**장점**
- 자원 효율성: 메모리와 시스템 자원을 공유하여 효율적 사용
- 빠른 Context Switching
- 간단한 데이터 공유
- 응답성 향상

**단점**
- 동기화 문제 (Critical Section, Race Condition)
- 디버깅의 어려움
- 하나의 스레드 오류가 전체 프로세스에 영향

## 6. 동기화 문제와 해결책

### 주요 동기화 문제
- **Race Condition**: 여러 스레드가 동시에 공유 자원에 접근할 때 발생
- **Deadlock**: 두 개 이상의 스레드가 서로를 기다리며 무한 대기
- **Starvation**: 특정 스레드가 계속해서 자원을 할당받지 못하는 상황

### 해결책
- **Mutex (뮤텍스)**: 상호 배제를 통한 동기화
- **Semaphore (세마포어)**: 카운팅을 통한 자원 관리
- **Monitor**: 고수준 동기화 도구
- **Atomic Operation**: 원자적 연산 보장

## 7. 언제 어떤 방식을 사용할까?

### 멀티 프로세스를 선택하는 경우
- 안정성이 가장 중요한 시스템 (웹 서버의 프로세스 분리)
- 독립적인 작업들을 수행해야 하는 경우
- 하나의 작업 실패가 전체 시스템에 영향을 주면 안 되는 경우

### 멀티 스레드를 선택하는 경우
- 성능과 자원 효율성이 중요한 경우
- 데이터를 자주 공유해야 하는 작업들
- 빠른 응답 시간이 필요한 어플리케이션
- 대부분의 현대 어플리케이션

## 8. 실제 사용 예시

### 웹 브라우저
- **멀티 프로세스**: 각 탭이 별도의 프로세스로 실행 (Chrome)
- **멀티 스레드**: 각 탭 내에서 렌더링, 자바스크립트 실행 등을 스레드로 처리

### 게임
- **메인 스레드**: 게임 로직 처리
- **렌더링 스레드**: 그래픽 처리
- **사운드 스레드**: 오디오 처리
- **네트워크 스레드**: 통신 처리

멀티 스레드 방식이 현대 프로그래밍에서 선호되는 이유는 **자원 효율성**과 **성능** 때문이다. 하지만 **동기화 문제**를 반드시 고려해야 하며, 상황에 따라 적절한 방식을 선택하는 것이 중요하다.