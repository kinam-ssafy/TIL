# 프로세스 vs 스레드

## 1. 기본 개념 이해

### 프로그램(Program)
- **사전적 의미**: 어떤 작업을 위해 실행할 수 있는 파일
- **특징**: 하드디스크에 저장되어 있는 정적인 상태의 코드 덩어리

### 프로세스(Process)
- **사전적 의미**: 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- **핵심 정의**: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
- **운영체제 관점**: 시스템 자원을 할당받는 작업의 단위

#### 프로세스가 할당받는 시스템 자원
- CPU 시간
- 독립된 메모리 영역 (Code, Data, Stack, Heap)
- 파일 디스크립터
- 프로세스 ID (PID)

-----
### 파일 디스크립터(File Descriptor, FD)
- 운영체제가 열려있는 파일을 식별하기 위해 부여하는 번호
- 프로세스는 특정 파일에 접근할 때 파일 이름 대신 이 번호를 사용

### 프로세스 ID(Process ID, PID)
- 운영체제가 실행 중인 각각의 프로세스를 구별하기 위해 부여하는 고유 번호
- 프로세스가 종료되면 해당 PID는 다른 프로세스가 재사용 가능 (ex. 301호의 첫 번째 책상, 502호의 첫 번째 책상 등)

301호, 502호는 FD로,  첫 번째 책상은 PID로 이해
PID는 어떤 프로세스인지를 식별하고, FD는 해당 프로세스가 사용하는 파일을 식별
-----

## 스레드(Thread)
- **사전적 의미**: 프로세스 내에서 실행되는 여러 흐름의 단위
- **핵심 정의**: 프로세스가 할당받은 자원을 이용하는 실행의 단위
- **실행 관점**: 프로세스의 특정한 수행 경로

## 2. 메모리 구조의 차이

### 프로세스 메모리 구조
```
프로세스 A     프로세스 B
┌─────────┐   ┌─────────┐
│  Code   │   │  Code   │
├─────────┤   ├─────────┤
│  Data   │   │  Data   │
├─────────┤   ├─────────┤
│  Heap   │   │  Heap   │
├─────────┤   ├─────────┤
│  Stack  │   │  Stack  │
└─────────┘   └─────────┘
   독립적        독립적
```

### 스레드 메모리 구조
```
      하나의 프로세스
┌─────────────────────────┐
│         Code            │ ← 모든 스레드가 공유
├─────────────────────────┤
│         Data            │ ← 모든 스레드가 공유
├─────────────────────────┤
│         Heap            │ ← 모든 스레드가 공유
├─────────┬─────────┬─────┤
│ Stack1  │ Stack2  │Stack3│ ← 각 스레드별로 독립
└─────────┴─────────┴─────┘
  스레드1   스레드2   스레드3
```

---------------
**Code 영역**
- 코드 그 자체가 기계어 형태로 저장되는 공간. 프로그램이 시작되면 이 영역의 코드를 CPU가 순서대로 읽어서 실행
- 중간에 코드가 바뀌면 안 되므로 읽기 전용(Read-Only) 상태

**Data 영역**
- 전역 변수(Global variables)와 정적 변수(Static variables)가 저장되는 공간
- 프로그램 시작과 동시에 할당되고, 끌날 때 소멸

**Heap 영역**
- 프로그래머가 코드를 통해 직접 메모리를 할당하고 해제하는 공간. 동적 할당을 위한 영역
- 개발자가 직접 관리해야 하므로, 사용 후 메모리 해제하지 않으면 메모리 누수 발생

**Stack 영역**
- 함수의 호출 정보 관련된 데이터 저장되는 공간. 지역 변수(Local variables), 매개변수(Parameters) 포함
- LIFO(Last-In, First-Out)구조. 가장 나중에 들어온 데이터가 가장 먼저 나감
---------------




## 3. 주요 특징 비교

### 프로세스의 특징
- **독립성**: 각각 독립된 메모리 영역을 할당받음
- **안전성**: 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않음
- **통신 방식**: IPC(Inter-Process Communication) 필요
  - 파이프(Pipe)
  - 소켓(Socket)
  - 공유 메모리(Shared Memory)
  - 메시지 큐(Message Queue)

------
### IPC?
- 프로세스는 독립성과 안정성 때문에 프로세스 A가 끝났으니 B 실행해 같은 신호를 보낼 수 없음
- 따라서 IPC를 통해 서로 데이터를 교환하여 통신하게 함

**Pipe**
- 가장 간단한 1:1 통신 통로, 두 프로세스를 하나의 파이프로 연결
- 단방향 통신. 양방향 통신 하려면 파이프 2개 필요

**Socket**
- 파이프의 확장판. 인터넷을 통해 다른 컴퓨터에 있는 프로세스와도 통신 가능
- 양방향 통신. 가장 널리 쓰이는 IPC 방식

**Shared Memory**
- 가장 빠른 통신 방식. 하나의 공용 메모리 공간을 함께 사용
- 공용이다보니 데이터가 꼬이거나 충돌 위험 >> 지금 나만 쓸게 라고 알려주는 잠금장치(Mutex, Semaphore 등)가 반드시 필요

**Message Queue**
- 데이터를 메시지 단위로 관리하는 방식. 큐에 넣어두고 받는 쪽은 필요할 때 꺼내감
- 비동기 통신. 받는 쪽이 자신이 필요할 때만 꺼내 데이터 처리 가능함 FIFO 순서보장

------

프로세스와 스레드의 모든 장단점은 **"Code, Data, Heap 영역을 공유하는가?"** 라는 질문 하나로 귀결됨.



### ## 공유하기 때문에 얻는 것 (스레드의 장점)

1.  **자원의 효율성 (메모리 절약)**
    * 새로운 스레드를 만들어도 무거운 Code, Data, Heap 영역을 또 만들 필요가 없음. 가벼운 **Stack** 영역만 하나 더 추가하면 되므로, 프로세스를 새로 만드는 것보다 훨씬 적은 메모리를 사용.
2.  **빠른 생성 및 컨텍스트 스위칭**
    * 새로운 메모리 공간을 할당하고 초기화하는 복잡한 과정이 없어 스레드 생성이 매우 빠름.
    * 전환(Context Switching) 시에도 공유하는 메모리 영역은 그대로 두고, 각 스레드의 Stack과 레지스터 정보만 바꾸면 되므로 오버헤드가 적음.
3.  **손쉬운 통신**
    * 별도의 IPC 같은 복잡한 통신 기술 없이, **Data나 Heap 영역의 전역 변수나 객체를 통해** 서로 데이터를 쉽게 주고받을 수 있음. 마치 한 팀이 하나의 화이트보드를 보며 대화하는 것과 같음.



---

### ## 공유하기 때문에 잃는 것 (스레드의 단점)

1.  **안전성의 문제 (동기화)**
    * 하나의 자원(Data, Heap의 변수)에 여러 스레드가 동시에 접근하여 값을 바꾸려고 하면 데이터가 꼬이는 **충돌(Race Condition)**이 발생할 수 있음.
    * 이를 막기 위해 "이 자원은 지금 나만 쓸게!"라고 알려주는 **잠금장치(Mutex 등)가 필수적**이며, 이는 프로그래밍을 복잡하게 만듦.
2.  **하나의 스레드가 전체를 망친다**
    * 스레드는 한 프로세스라는 '운명 공동체'임. 따라서 **하나의 스레드에서 오류가 발생해 비정상적으로 종료되면, 그 프로세스 전체가 강제로 종료**될 수 있음.

---

### ## 결론: 공유의 양면성

| 특징 | 원인 | 결과 |
| :--- | :--- | :--- |
| **효율성 & 속도** | Code, Data, Heap **공유** | **높음** (자원 소모 적고, 속도 빠름) |
| **통신** | Code, Data, Heap **공유** | **쉬움** (데이터 직접 접근 가능) |
| **안정성** | Code, Data, Heap **공유** | **낮음** (하나의 오류가 전체에 영향) |

**스레드는 프로세스의 독립성을 희생한 대신, 자원의 효율성과 빠른 통신 능력을 얻은 모델**





### 스레드의 특징
- **공유성**: Code, Data, Heap 영역을 공유하고 Stack만 독립적으로 할당
- **효율성**: 메모리와 시스템 자원을 효율적으로 사용
- **통신 방식**: 공유 메모리를 통한 직접적인 데이터 교환 가능
- **위험성**: 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있음

## 4. Context Switching의 차이

### 프로세스 Context Switching
```
1. 현재 프로세스의 상태 저장
2. CPU 캐시 메모리 초기화 (무거운 작업)
3. 다음 프로세스의 상태 복원
4. 메모리 매핑 테이블 변경
```
**오버헤드**: 크다 (캐시 초기화, 메모리 매핑 변경 등)

### 스레드 Context Switching
```
1. 현재 스레드의 레지스터 상태 저장
2. 다음 스레드의 레지스터 상태 복원
3. Stack 포인터 변경
```
**오버헤드**: 작다 (레지스터와 Stack 정보만 변경)

## 5. 멀티 프로세스 vs 멀티 스레드

### 멀티 프로세스
**장점**
- 안정성: 하나의 프로세스가 죽어도 다른 프로세스에 영향 없음
- 독립성: 각 프로세스가 독립적으로 동작

**단점**
- 높은 메모리 사용량
- 큰 Context Switching 오버헤드
- 복잡한 IPC 통신

### 멀티 스레드
**장점**
- 자원 효율성: 메모리와 시스템 자원을 공유하여 효율적 사용
- 빠른 Context Switching
- 간단한 데이터 공유
- 응답성 향상

**단점**
- 동기화 문제 (Critical Section, Race Condition)
- 디버깅의 어려움
- 하나의 스레드 오류가 전체 프로세스에 영향

## 6. 동기화 문제와 해결책

### 주요 동기화 문제
- **Race Condition**: 여러 스레드가 동시에 공유 자원에 접근할 때 발생
- **Deadlock**: 두 개 이상의 스레드가 서로를 기다리며 무한 대기
- **Starvation**: 특정 스레드가 계속해서 자원을 할당받지 못하는 상황

### 해결책
- **Mutex (뮤텍스)**: 상호 배제를 통한 동기화
- **Semaphore (세마포어)**: 카운팅을 통한 자원 관리
- **Monitor**: 고수준 동기화 도구
- **Atomic Operation**: 원자적 연산 보장

## 7. 언제 어떤 방식을 사용할까?

### 멀티 프로세스를 선택하는 경우
- 안정성이 가장 중요한 시스템 (웹 서버의 프로세스 분리)
- 독립적인 작업들을 수행해야 하는 경우
- 하나의 작업 실패가 전체 시스템에 영향을 주면 안 되는 경우

### 멀티 스레드를 선택하는 경우
- 성능과 자원 효율성이 중요한 경우
- 데이터를 자주 공유해야 하는 작업들
- 빠른 응답 시간이 필요한 어플리케이션
- 대부분의 현대 어플리케이션

## 8. 실제 사용 예시

### 웹 브라우저
- **멀티 프로세스**: 각 탭이 별도의 프로세스로 실행 (Chrome)
- **멀티 스레드**: 각 탭 내에서 렌더링, 자바스크립트 실행 등을 스레드로 처리

### 게임
- **메인 스레드**: 게임 로직 처리
- **렌더링 스레드**: 그래픽 처리
- **사운드 스레드**: 오디오 처리
- **네트워크 스레드**: 통신 처리

멀티 스레드 방식이 현대 프로그래밍에서 선호되는 이유는 **자원 효율성**과 **성능** 때문이다. 하지만 **동기화 문제**를 반드시 고려해야 하며, 상황에 따라 적절한 방식을 선택하는 것이 중요하다.