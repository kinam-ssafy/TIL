# 입출력 시스템 & 디스크 스케줄링

## 들어가기 전에

### 입출력(I/O)이란
Input/Output의 약자로, 컴퓨터와 외부 장치 간의 데이터 전송을 의미함

### I/O 장치의 종류
- **저장 장치**: HDD, SSD, USB 메모리
- **입력 장치**: 키보드, 마우스, 스캐너
- **출력 장치**: 모니터, 프린터, 스피커
- **네트워크 장치**: 네트워크 카드, 모뎀

---

## 1. I/O 시스템의 필요성

### CPU와 I/O 장치의 속도 차이

```
속도 비교 (상대적):
CPU: 1ns (나노초)
메모리: 100ns
SSD: 100μs (마이크로초) = 100,000ns
HDD: 10ms (밀리초) = 10,000,000ns

→ HDD는 CPU보다 1000만 배 느림
```

### 발생하는 문제
- CPU가 I/O 완료를 기다리면 시간 낭비
- I/O 장치마다 다른 제어 방식 필요
- 동시 다발적인 I/O 요청 관리 필요

### I/O 시스템의 목표
- CPU와 I/O 장치의 속도 차이 극복
- 장치 독립성 제공
- 효율적인 I/O 처리
- 오류 처리 및 복구

---

## 2. I/O 하드웨어 구조

### I/O 장치 구성 요소

#### (1) 기계적 부분 (Device)
실제 I/O 작업을 수행하는 물리적 장치

#### (2) 전자적 부분 (Device Controller)
장치와 컴퓨터를 연결하는 전자 회로

```
구조:
┌─────────┐
│   CPU   │
└────┬────┘
     │ 시스템 버스
┌────┴────────────────────┐
│  ┌──────────────┐       │
│  │   메모리     │       │
│  └──────────────┘       │
│                         │
│  ┌──────────────┐       │
│  │ Controller 1 │───────┼─→ 디스크
│  └──────────────┘       │
│                         │
│  ┌──────────────┐       │
│  │ Controller 2 │───────┼─→ 키보드
│  └──────────────┘       │
└─────────────────────────┘
```

### Device Controller의 구성

**레지스터**
- 명령 레지스터: CPU가 명령 전달
- 상태 레지스터: 장치 상태 정보
- 데이터 레지스터: 데이터 입출력

**로컬 버퍼**
- 데이터를 임시 저장하는 공간
- CPU와 장치 간 속도 차이 완화

---

## 3. HDD (Hard Disk Drive) 구조

### 물리적 구조

```
디스크 구조:
        회전 축
         │
    ┌────┴────┐
    │  플래터  │  ← 자기 원판
    └─────────┘
         │
    ┌────┴────┐
    │  헤드   │  ← 읽기/쓰기 헤드
    └─────────┘
```

#### 주요 구성 요소

**플래터 (Platter)**
- 데이터를 저장하는 자기 원판
- 분당 5400~15000 RPM으로 회전

**헤드 (Head)**
- 데이터를 읽고 쓰는 자기 헤드
- 플래터 표면 위를 이동

**트랙 (Track)**
- 플래터의 동심원
- 각 트랙에 데이터 저장

**섹터 (Sector)**
- 트랙을 나눈 단위
- 보통 512바이트 또는 4KB

**실린더 (Cylinder)**
- 여러 플래터의 같은 위치 트랙들

```
플래터 위에서 본 모습:
┌─────────────────┐
│  ╱───╲ ╱───╲   │
│ ╱     ╳     ╲  │ ← 트랙들
│ ╲     ╱╲    ╱  │
│  ╲───╱  ╲──╱   │
└─────────────────┘
      섹터
```

### 디스크 주소 지정

```
블록 위치 = (실린더, 헤드, 섹터)

예시: (100, 2, 5)
- 실린더 100번
- 헤드 2번
- 섹터 5번
```

---

## 4. 디스크 접근 시간

### 총 접근 시간 구성

```
총 시간 = 탐색 시간 + 회전 지연 시간 + 전송 시간
```

### (1) 탐색 시간 (Seek Time)
헤드가 목표 트랙으로 이동하는 시간

```
헤드 이동:
현재 트랙 10 → 목표 트랙 100
이동 거리: 90 트랙
탐색 시간: 약 5~10ms
```

**가장 시간이 오래 걸리는 부분**

### (2) 회전 지연 시간 (Rotational Latency)
목표 섹터가 헤드 아래로 올 때까지 기다리는 시간

```
7200 RPM 디스크:
- 1회전: 60초 / 7200 = 8.33ms
- 평균 회전 지연: 4.17ms
```

### (3) 전송 시간 (Transfer Time)
실제 데이터를 읽거나 쓰는 시간

```
전송 시간 = 전송량 / 전송 속도

예시:
- 4KB 블록 읽기
- 전송 속도: 100MB/s
- 전송 시간: 0.04ms
```

### 시간 비교

```
일반적인 비율:
탐색 시간: 5ms (가장 큼)
회전 지연: 4ms
전송 시간: 0.04ms (가장 작음)

→ 탐색 시간을 줄이는 것이 핵심
```

---

## 5. I/O 처리 방법

### (1) 프로그래밍 I/O (Polling)

#### 동작 방식
CPU가 계속 상태 레지스터를 확인하면서 대기

```
while (상태 레지스터 == BUSY) {
    // 계속 확인
}
데이터 읽기
```

#### 장점
- 구현 단순
- 추가 하드웨어 불필요

#### 단점
- CPU 시간 낭비
- 다른 작업 수행 불가
- 비효율적

---

### (2) 인터럽트 기반 I/O

#### 동작 방식
```
1. CPU가 I/O 요청
2. CPU는 다른 작업 수행
3. I/O 완료 시 인터럽트 발생
4. CPU가 인터럽트 처리
```

#### 과정
```
시간 흐름:
CPU: [I/O요청]──[다른작업]──[인터럽트 처리]
                    ↑
I/O:        [데이터 전송 중]
```

#### 장점
- CPU 효율적 사용
- 동시 작업 가능

#### 단점
- 인터럽트 처리 오버헤드
- 많은 I/O 요청 시 인터럽트 빈발

---

### (3) DMA (Direct Memory Access)

#### 개념
CPU 개입 없이 I/O 장치가 직접 메모리에 접근

#### 동작 방식
```
1. CPU가 DMA 컨트롤러에 I/O 요청
   - 전송할 데이터 주소
   - 전송할 크기
   - 장치 정보

2. DMA가 직접 메모리↔장치 간 데이터 전송

3. 전송 완료 후 인터럽트 발생

4. CPU가 결과 처리
```

```
구조:
┌─────────┐
│   CPU   │ ① I/O 요청
└────┬────┘      ↓
     │      ┌────────┐
     │      │  DMA   │
     │      │Controller│
┌────┴─────┬┴────────┤
│  메모리   │←②─────┼──→ 디스크
└──────────┴─────────┘
             직접 전송
```

#### 장점
- CPU 거의 개입 안 함
- 대용량 데이터 전송 효율적
- 인터럽트 횟수 감소

#### 단점
- 추가 하드웨어 필요
- 버스 경쟁 가능

---

## 6. I/O 소프트웨어 계층

### 계층 구조

```
┌─────────────────────────┐
│   사용자 프로그램        │
├─────────────────────────┤
│ 장치 독립 I/O 소프트웨어 │
├─────────────────────────┤
│   디바이스 드라이버      │
├─────────────────────────┤
│  인터럽트 핸들러         │
├─────────────────────────┤
│      하드웨어            │
└─────────────────────────┘
```

### 각 계층의 역할

**(1) 인터럽트 핸들러**
- 인터럽트 발생 시 처리
- 대기 중인 프로세스 깨우기

**(2) 디바이스 드라이버**
- 특정 장치 제어
- 장치별 명령 변환
- 상태 관리

**(3) 장치 독립 I/O 소프트웨어**
- 공통 I/O 기능 제공
- 버퍼링, 캐싱
- 오류 처리
- 장치 명명 및 보호

**(4) 사용자 수준 I/O 소프트웨어**
- 라이브러리 함수
- read(), write() 등

---

## 7. 디스크 스케줄링 알고리즘

### 스케줄링의 목표
- **탐색 시간 최소화** (가장 중요)
- 응답 시간 개선
- 처리량 최대화
- 공정성 보장

### 디스크 요청 큐 예시
```
현재 헤드 위치: 53
요청 큐: [98, 183, 37, 122, 14, 124, 65, 67]
```

---

### (1) FCFS (First-Come, First-Served)

#### 개념
도착 순서대로 처리

#### 동작
```
헤드 이동 경로:
53 → 98 → 183 → 37 → 122 → 14 → 124 → 65 → 67

총 헤드 이동: 640 트랙
```

#### 장점
- 구현 단순
- 공정함

#### 단점
- 탐색 시간 많이 걸림
- 헤드 이동 거리 최적화 안 됨

---

### (2) SSTF (Shortest Seek Time First)

#### 개념
현재 헤드 위치에서 가장 가까운 요청 먼저 처리

#### 동작
```
헤드 위치: 53
가장 가까운: 65

헤드 이동 경로:
53 → 65 → 67 → 37 → 14 → 98 → 122 → 124 → 183

총 헤드 이동: 236 트랙
```

#### 장점
- 평균 탐색 시간 감소
- FCFS보다 효율적

#### 단점
- **기아 현상 발생 가능**
- 바깥쪽 트랙 요청은 계속 대기

---

### (3) SCAN (엘리베이터 알고리즘)

#### 개념
헤드가 한 방향으로 이동하며 요청 처리, 끝에 도달하면 반대 방향

#### 동작
```
헤드 위치: 53
방향: 오른쪽으로 시작

헤드 이동 경로:
53 → 65 → 67 → 98 → 122 → 124 → 183 → 199(끝)
                                         ↓
                              37 ← 14 ← 0(끝)

총 헤드 이동: 236 트랙
```

#### 특징
- 양방향 왕복 운동
- 디스크 끝까지 이동

#### 장점
- 기아 현상 없음
- 예측 가능한 대기 시간
- 안정적인 성능

#### 단점
- 끝 부분 요청 없어도 끝까지 이동
- 가운데 트랙이 유리함

---

### (4) C-SCAN (Circular SCAN)

#### 개념
한 방향으로만 서비스하고, 끝에 도달하면 처음으로 이동

#### 동작
```
헤드 위치: 53
방향: 오른쪽만 처리

헤드 이동 경로:
53 → 65 → 67 → 98 → 122 → 124 → 183 → 199(끝)
                                         ↓
0(시작) → 14 → 37

총 헤드 이동: 183 트랙 (실제 서비스)
           + 199 트랙 (복귀)
```

#### 장점
- 더 균등한 대기 시간
- SCAN보다 공정함
- 바깥쪽 트랙 불이익 감소

#### 단점
- 복귀 시간 낭비

---

### (5) LOOK & C-LOOK

#### 개념
SCAN/C-SCAN의 개선 - 끝까지 가지 않고 마지막 요청까지만 이동

#### LOOK 동작
```
헤드 위치: 53
방향: 오른쪽

헤드 이동 경로:
53 → 65 → 67 → 98 → 122 → 124 → 183
                                    ↓
                         37 ← 14

마지막 요청까지만 가고 방향 전환
```

#### C-LOOK 동작
```
53 → 65 → 67 → 98 → 122 → 124 → 183
                                    ↓
                         14 → 37

마지막 요청까지만 가고 첫 요청으로 이동
```

#### 장점
- 불필요한 헤드 이동 제거
- SCAN/C-SCAN보다 효율적

---

## 8. 스케줄링 알고리즘 비교

### 성능 비교

| 알고리즘 | 총 헤드 이동 | 최대 대기 | 기아 현상 |
|----------|--------------|-----------|-----------|
| FCFS | 640 | 높음 | 없음 |
| SSTF | 236 | 매우 높음 | 가능 |
| SCAN | 236 | 중간 | 없음 |
| C-SCAN | 382 | 낮음 | 없음 |
| LOOK | 208 | 중간 | 없음 |
| C-LOOK | 322 | 낮음 | 없음 |

### 선택 기준

**FCFS**
- 간단한 시스템
- I/O 요청 적은 경우

**SSTF**
- 성능이 최우선
- 기아 현상 문제없는 환경

**SCAN/LOOK**
- 범용적 사용
- 안정성과 성능 균형
- **가장 많이 사용됨**

**C-SCAN/C-LOOK**
- 공정성이 중요한 경우
- 실시간 시스템

---

## 9. SSD (Solid State Drive)

### HDD와의 차이

```
HDD:
- 회전하는 디스크
- 기계적 이동
- 느림 (ms 단위)
- 순차 접근 유리

SSD:
- 플래시 메모리
- 전자적 접근
- 빠름 (μs 단위)
- 임의 접근 가능
```

### SSD 특징

#### 장점
- 탐색 시간 거의 없음
- 임의 접근 빠름
- 소음, 발열 적음
- 충격에 강함

#### 단점
- 쓰기 횟수 제한
- 비싼 가격
- 용량 제한

### SSD 스케줄링

```
SSD에서는 디스크 스케줄링 불필요:
- 기계적 이동 없음
- 모든 위치 접근 시간 동일
- FCFS만으로도 충분
```

### 웨어 레벨링 (Wear Leveling)

```
문제: 같은 블록만 계속 쓰면 수명 단축

해결: 쓰기를 여러 블록에 분산
- 논리 주소 → 물리 주소 매핑
- FTL (Flash Translation Layer)
```

---

## 10. 성능 최적화 기법

### (1) 디스크 캐시

```
자주 접근하는 블록을 메모리에 캐싱:
- 읽기 캐시: 미리 읽기
- 쓰기 캐시: 지연 쓰기

효과:
- 디스크 접근 횟수 감소
- 응답 시간 개선
```

### (2) 블록 클러스터링

```
연속된 블록을 묶어서 처리:
- 여러 개 요청을 하나로 결합
- 헤드 이동 횟수 감소

예시:
블록 100, 101, 102 요청
→ 한 번에 처리
```

### (3) 미리 읽기 (Prefetching)

```
순차 접근 패턴 감지 시:
- 다음 블록 미리 읽기
- 캐시에 저장

효과:
- 순차 읽기 성능 향상
```

### (4) RAID

```
여러 디스크를 묶어 사용:
- RAID 0: 스트라이핑 (성능)
- RAID 1: 미러링 (안정성)
- RAID 5: 패리티 (균형)

효과:
- 성능 향상
- 안정성 향상
- 용량 확장
```

---

## 11. 핵심 정리

### I/O 시스템의 핵심

**계층 구조**
```
사용자 프로그램
    ↓
장치 독립 소프트웨어
    ↓
디바이스 드라이버
    ↓
하드웨어
```

**처리 방법**
- Polling: 간단, 비효율
- 인터럽트: 효율적, 오버헤드
- DMA: 대용량 전송 최적

### 디스크 접근 시간

```
총 시간 = 탐색 시간 + 회전 지연 + 전송 시간
         (가장 큼)   (중간)     (작음)

목표: 탐색 시간 최소화
```

### 스케줄링 알고리즘 선택

```
성능 우선: SSTF
안정성 + 성능: SCAN/LOOK (추천)
공정성: C-SCAN/C-LOOK
단순함: FCFS
```

### HDD vs SSD

```
HDD:
- 기계적, 느림
- 스케줄링 중요
- 대용량, 저렴

SSD:
- 전자적, 빠름
- 스케줄링 불필요
- 쓰기 수명 관리 중요
```