# 동기화 기법 (Synchronization)

## 동기화란

### 사전적 의미
"시간을 맞추는 것", "조화를 이루는 것"

### 운영체제에서의 의미
여러 프로세스나 스레드가 공유 자원에 접근할 때, **데이터의 일관성과 무결성을 보장**하기 위해 접근 순서를 조절하는 기법

멀티프로그래밍 환경에서 **동시성 제어**의 핵심 개념임

## 왜 동기화가 필요한가?

### 핵심 배경 지식

#### 공유 자원 (Shared Resource)
- 여러 프로세스나 스레드가 동시에 접근할 수 있는 자원
- 메모리, 파일, 데이터베이스, 프린터 등

#### 경쟁 상태 (Race Condition)
- 여러 프로세스가 동시에 공유 데이터를 조작할 때 실행 순서에 따라 결과가 달라지는 상황
- 예측할 수 없는 결과가 발생함

### 동기화 문제의 예시

#### 은행 계좌 문제
```
초기 잔액: 1000원

프로세스 A: 출금 500원        프로세스 B: 출금 300원
1. 잔액 읽기: 1000          1. 잔액 읽기: 1000
2. 계산: 1000-500=500       2. 계산: 1000-300=700  
3. 저장: 500               3. 저장: 700

결과: 실행 순서에 따라 최종 잔액이 500원 또는 700원이 됨
올바른 결과는 200원이어야 함
```

#### 웹사이트 조회수 문제
```
초기 조회수: 1000

사용자 A가 페이지 접속     사용자 B가 페이지 접속
1. 조회수 읽기: 1000      1. 조회수 읽기: 1000
2. 1 증가: 1001          2. 1 증가: 1001
3. 저장: 1001           3. 저장: 1001

결과: 두 명이 접속했는데 조회수는 1씩만 증가
```

## 임계 구역 (Critical Section)

### 정의
공유 자원에 접근하는 코드 부분으로, **한 번에 하나의 프로세스만 실행되어야 하는 영역**

### 프로그램 구조
```
do {
    [진입 구역]     // 임계구역 진입 허가 요청
    [임계 구역]     // 공유 자원 접근 (한 번에 하나만)
    [퇴장 구역]     // 임계구역 사용 완료 신호
    [나머지 구역]   // 일반적인 코드
} while(true);
```

### 임계 구역 문제 해결 조건

#### 1. 상호 배제 (Mutual Exclusion)
- 한 프로세스가 임계 구역을 실행 중이면 다른 프로세스는 진입할 수 없음
- 화장실에 한 사람만 들어갈 수 있는 것과 같음

#### 2. 진행 (Progress)  
- 임계 구역이 비어있으면 진입하려는 프로세스가 있을 때 진입을 허용해야 함
- 임계 구역 밖의 프로세스가 다른 프로세스의 진입을 막으면 안됨
- 화장실이 비어있는데 사용을 막으면 안됨

#### 3. 한정 대기 (Bounded Waiting)
- 프로세스가 임계 구역 진입을 요청한 후 무한정 기다리지 않아야 함
- 기아 현상 방지
- 화장실 대기줄에서 영원히 기다리면 안됨

## 동기화 기법들

### 1. 뮤텍스 (Mutex)

#### 개념
**Mut**ual **Ex**clusion의 줄임말로, 임계 구역에 하나의 프로세스만 들어갈 수 있도록 하는 동기화 객체

#### 동작 방식
- **Lock**: 임계 구역 진입 전 잠금 획득
- **Unlock**: 임계 구역 종료 후 잠금 해제

#### 특징
- **Binary Lock**: 잠김(1) 또는 열림(0) 상태만 존재
- **소유권**: Lock을 건 프로세스만 Unlock 가능
- **단순함**: 가장 기본적인 동기화 기법

#### 예시 상황
- 프린터 사용: 한 번에 하나의 작업만 인쇄 가능
- 파일 쓰기: 동시에 여러 프로세스가 같은 파일에 쓰면 안됨

### 2. 세마포어 (Semaphore)

#### 개념
네덜란드의 다익스트라(Dijkstra)가 제안한 동기화 도구
정수 값을 가지며, **자원의 개수를 나타내는 카운터** 역할

#### 기본 연산
- **P 연산 (Wait, Down)**: 자원 요청 (세마포어 값 감소)
- **V 연산 (Signal, Up)**: 자원 반납 (세마포어 값 증가)

#### 세마포어 종류

##### Binary Semaphore (이진 세마포어)
- 값이 0 또는 1만 가능
- 뮤텍스와 유사한 기능
- 상호 배제 목적

##### Counting Semaphore (계수 세마포어)
- 양의 정수 값 가능
- 여러 개의 동일한 자원 관리
- 자원 할당 제어

#### 예시 상황
- 주차장 관리: 10개 주차 공간이 있는 주차장 (세마포어 값 = 10)
- 데이터베이스 연결: 최대 5개 동시 연결 허용 (세마포어 값 = 5)

### 3. 모니터 (Monitor)

#### 개념
공유 자원과 그에 대한 연산을 하나의 단위로 묶어서 동시 접근을 제어하는 고급 동기화 도구

#### 특징
- **상호 배제**: 한 번에 하나의 프로세스만 모니터 내부에서 활동
- **조건 동기화**: 특정 조건이 만족될 때까지 대기 가능
- **캡슐화**: 공유 데이터와 연산을 하나로 묶음
- **추상화**: 프로그래머가 동기화 세부사항을 신경쓰지 않아도 됨

#### 조건 변수 (Condition Variable)
- **wait()**: 조건이 만족될 때까지 대기
- **signal()**: 대기 중인 프로세스 하나를 깨움

#### 예시 상황
- 은행 ATM 시스템: 계좌 잔액 조회/입금/출금 기능을 하나로 묶음
- 엘리베이터 제어: 층 이동, 문 열기/닫기를 통합 관리

## 고전적 동기화 문제들

### 1. 생산자-소비자 문제 (Producer-Consumer Problem)

#### 문제 설명
- **생산자**: 데이터를 생성하여 버퍼에 저장
- **소비자**: 버퍼에서 데이터를 가져와 소비
- **제약**: 버퍼 크기는 유한함

#### 실생활 예시
- 택배 물류센터: 택배 상차(생산자) vs 배송(소비자)
- 유튜브 스트리밍: 영상 인코딩(생산자) vs 재생(소비자)

#### 해결해야 할 문제
- 버퍼가 가득 찰 때 생산자 대기
- 버퍼가 비어있을 때 소비자 대기
- 버퍼 접근 시 동시성 제어

### 2. 독자-저자 문제 (Readers-Writers Problem)

#### 문제 설명
- **독자(Reader)**: 데이터를 읽기만 함 (여러 독자 동시 접근 가능)
- **저자(Writer)**: 데이터를 쓰기 함 (한 번에 하나만 접근 가능)
- **제약**: 저자가 쓰는 동안 독자는 접근 불가

#### 실생활 예시
- 도서관: 여러 사람이 동시에 책을 읽을 수 있지만, 사서가 책을 정리할 때는 접근 불가
- 위키피디아: 여러 사용자가 동시에 글을 읽을 수 있지만, 편집할 때는 한 명만

#### 우선순위 정책
- **독자 우선**: 독자가 있으면 새 독자 계속 허용 (저자 기아 현상 가능)
- **저자 우선**: 저자 요청이 있으면 새 독자 차단 (독자 기아 현상 가능)

### 3. 식사하는 철학자 문제 (Dining Philosophers Problem)

#### 문제 설명
- 5명의 철학자가 원형 테이블에 앉아 있음
- 각 철학자 사이에 포크가 하나씩 있음 (총 5개)
- 철학자는 **생각**하거나 **식사**함
- 식사하려면 **양쪽 포크를 모두** 사용해야 함

#### 발생 가능한 문제
- **데드락**: 모든 철학자가 왼쪽 포크를 든 상태에서 오른쪽 포크를 기다림
- **기아 현상**: 특정 철학자가 계속 식사 기회를 얻지 못함

#### 해결 방법
- **비대칭적 해법**: 한 철학자만 포크 획득 순서를 바꿈
- **동시 식사 제한**: 최대 4명만 동시에 식사 시도
- **조건 확인**: 양쪽 포크가 모두 사용 가능할 때만 식사 시작

## 데드락 (Deadlock)

### 정의
두 개 이상의 프로세스가 서로가 가진 자원을 기다리면서 **무한정 대기하는 상태**

### 실생활 예시
- **교차로 상황**: 네 방향에서 온 차들이 모두 교차로 중앙에 진입하여 서로 막힘
- **회의실 예약**: A팀이 회의실1을 쓰면서 회의실2를 기다리고, B팀이 회의실2를 쓰면서 회의실1을 기다림

### 데드락 발생 조건 (4가지 모두 만족해야 발생)

#### 1. 상호 배제 (Mutual Exclusion)
- 자원을 한 번에 하나의 프로세스만 사용 가능

#### 2. 점유 대기 (Hold and Wait)  
- 자원을 가진 채로 다른 자원을 기다림

#### 3. 비선점 (No Preemption)
- 다른 프로세스의 자원을 강제로 빼앗을 수 없음

#### 4. 순환 대기 (Circular Wait)
- 프로세스들이 원형으로 서로의 자원을 기다림

### 데드락 처리 방법

#### 1. 데드락 예방 (Prevention)
4가지 조건 중 하나를 원천 차단
- 단순하지만 자원 사용률이 떨어짐

#### 2. 데드락 회피 (Avoidance)
- 안전한 상태에서만 자원 할당
- 은행원 알고리즘이 대표적

#### 3. 데드락 탐지 및 복구 (Detection & Recovery)
- 주기적으로 데드락 탐지
- 발견 시 프로세스 종료 또는 자원 회수

#### 4. 데드락 무시 (Ignore)
- 타조 정책: 데드락이 드물게 발생한다고 가정하고 무시
- 많은 운영체제가 채택 (성능상 이유)

## Busy Waiting vs Blocking

### Busy Waiting (바쁜 대기)
#### 개념
계속해서 조건을 확인하면서 대기하는 방식

#### 특징
- **장점**: 락 해제 시 즉시 반응 가능, 짧은 대기에 효율적
- **단점**: CPU를 계속 사용하여 자원 낭비
- **적용**: 임계 구역이 짧고 대기 시간이 적을 때

### Blocking (블로킹 대기)
#### 개념
대기 큐에 들어가서 프로세스가 잠들어 있다가 깨워지는 방식

#### 특징
- **장점**: CPU 효율적 사용, 긴 대기에 적합
- **단점**: Context Switching 오버헤드, 반응성 떨어짐
- **적용**: 임계 구역이 길고 대기 시간이 길 때

## 동기화 기법 비교

| 기법 | 자원 제어 | 복잡도 | 장점 | 단점 | 적용 상황 |
|------|-----------|--------|------|------|----------|
| **뮤텍스** | 1개 | 낮음 | 단순, 직관적 | 하나의 자원만 | 파일 접근, 프린터 사용 |
| **세마포어** | 여러 개 | 중간 | 유연함, 다양한 용도 | 잘못 사용하기 쉬움 | 연결 풀, 주차장 관리 |
| **모니터** | 여러 개 | 높음 | 구조화, 안전함 | 언어 지원 필요 | 복잡한 동기화 |

## 실제 사용 예시

### 1. 웹 서버
- **문제**: 동시 접속자 수 제한
- **해결**: 세마포어로 최대 연결 수 제어

### 2. 데이터베이스
- **문제**: 동시 읽기/쓰기 제어
- **해결**: 독자-저자 문제 해법 적용

### 3. 파일 시스템
- **문제**: 파일 동시 수정 방지
- **해결**: 뮤텍스로 파일 잠금

### 4. 메모리 할당자
- **문제**: 힙 메모리 할당/해제 동기화
- **해결**: 뮤텍스로 메모리 풀 보호

## 성능 고려사항

### 1. 락 세분화 (Lock Granularity)
- **거친 락 (Coarse-grained)**: 큰 영역 보호, 간단, 경합 증가
- **세밀한 락 (Fine-grained)**: 작은 영역 보호, 복잡, 경합 감소

### 2. 락 순서 (Lock Ordering)
- 일관된 순서로 락 획득하여 데드락 방지
- 자원에 번호를 매겨 순서대로 요청

### 3. 대기 방식 선택
- **짧은 임계구역**: Busy Waiting 선택
- **긴 임계구역**: Blocking 선택

## 핵심 포인트 정리

1. **동기화의 목적**: Race Condition 방지, 데이터 일관성 보장

2. **임계구역 3조건**: 상호배제, 진행, 한정대기 모두 만족해야 함

3. **기법별 특징**:
   - 뮤텍스: 단순, 하나의 자원
   - 세마포어: 유연, 여러 자원
   - 모니터: 고급, 구조화

4. **데드락**: 4가지 조건이 모두 만족되면 발생, 설계 시 주의 필요

5. **성능 트레이드오프**: 안전성 vs 성능, 단순성 vs 유연성 사이의 균형

동기화는 멀티프로그래밍 환경에서 필수적인 개념이며, 시스템의 안정성과 성능을 좌우하는 중요한 요소임