# 페이징 & 세그멘테이션

## 들어가기 전에 알아야 할 배경 지식

### 메모리 관리의 기본 문제점
- **연속 할당의 한계**: 큰 프로세스를 연속된 공간에 배치하기 어려움
- **외부 파편화**: 메모리 중간중간 작은 빈 공간들이 흩어져 있어 사용 불가
- **메모리 보호 필요성**: 프로세스 간 메모리 영역 침범 방지

### 논리적 주소 vs 물리적 주소
- **논리적 주소**: 프로세스가 사용하는 가상의 주소 (0번지부터 시작)
- **물리적 주소**: 실제 메모리에서의 위치
- **주소 변환**: MMU가 논리적 주소를 물리적 주소로 변환

---

## 페이징 (Paging)

### 사전적 의미
페이징(Paging)은 "페이지를 나누다"라는 의미로, 메모리를 고정된 크기의 블록으로 나누어 관리하는 기법을 의미함

### 페이징의 핵심 개념

#### 페이징이 생긴 이유
```
기존 연속 할당의 문제점:
- 큰 프로세스를 연속된 공간에 배치하기 어려움
- 외부 파편화로 메모리 낭비 심각

페이징의 해결 아이디어:
- 메모리를 작은 조각(프레임)으로 나누기
- 프로세스도 같은 크기(페이지)로 나누기  
- 흩어져서 배치해도 논리적으로는 연속된 것처럼 보이게 함
```

#### 핵심 용어 정리

##### 페이지 (Page)
- **논리 메모리를 나눈 고정 크기 블록**
- 보통 4KB 크기로 설정
- 프로세스의 논리적 주소 공간을 동일한 크기로 분할

##### 프레임 (Frame)  
- **물리 메모리를 나눈 고정 크기 블록**
- 페이지와 동일한 크기
- 실제 메모리에서 페이지가 들어갈 슬롯

##### 페이지 테이블 (Page Table)
- 각 페이지가 어느 프레임에 저장되어 있는지 기록하는 표
- 논리적 주소를 물리적 주소로 변환하는 핵심 자료구조

### 페이징 동작 원리

#### 주소 변환 과정
```
논리적 주소 구조:
┌─────────────┬─────────────┐
│ 페이지 번호  │ 페이지 오프셋 │
└─────────────┴─────────────┘

예시 (4KB 페이지 크기):
논리 주소 16384 = 페이지 4, 오프셋 0
논리 주소 16500 = 페이지 4, 오프셋 116
```

#### 변환 단계
```
1단계: 논리 주소를 페이지 번호와 오프셋으로 분리
2단계: 페이지 테이블에서 해당 페이지의 프레임 번호 찾기
3단계: 프레임 번호 + 오프셋 = 물리적 주소
4단계: 물리 메모리의 해당 위치에 접근
```

### 실제 동작 예시

#### 메모리 상황
```
물리 메모리:
┌─────────┐ 프레임 0
│ 프로세스B│ 프레임 1  
│ 페이지2  │ 프레임 2
├─────────┤
│ 프로세스A│ 프레임 3
│ 페이지0  │ 프레임 4
├─────────┤
│ 프로세스A│ 프레임 5
│ 페이지1  │ 프레임 6
└─────────┘

프로세스A 페이지 테이블:
페이지 0 → 프레임 3
페이지 1 → 프레임 5  
페이지 2 → 프레임 1
```

#### 주소 변환 예시
```
프로세스A가 논리 주소 8192에 접근한다면:
- 페이지 크기 4KB = 4096바이트
- 8192 ÷ 4096 = 페이지 2, 오프셋 0
- 페이지 테이블 확인: 페이지 2 → 프레임 1
- 물리 주소 = 프레임 1의 시작 주소 + 0 = 4096
```

### 페이징의 장단점

#### 장점
- **외부 파편화 완전 해결**: 모든 빈 프레임을 활용 가능
- **메모리 관리 단순화**: 고정 크기로 관리하기 쉬움
- **프로세스 크기 제한 없음**: 사용 가능한 프레임만 있으면 실행 가능

#### 단점
- **내부 파편화 발생**: 마지막 페이지가 꽉 차지 않을 수 있음
- **페이지 테이블 공간 필요**: 프로세스마다 페이지 테이블 유지 필요
- **주소 변환 오버헤드**: 메모리 접근 시마다 테이블 참조 필요

---

## 세그멘테이션 (Segmentation)

### 사전적 의미
세그멘테이션(Segmentation)은 "분할"을 의미하며, 프로그램을 논리적 의미 단위로 나누어 관리하는 메모리 관리 기법을 의미함

### 세그멘테이션의 핵심 개념

#### 페이징과의 차이점
```
페이징:
- 물리적 분할 (고정 크기)
- 의미와 무관하게 일정 크기로 자름
- 4KB씩 기계적으로 분할

세그멘테이션:  
- 논리적 분할 (가변 크기)
- 프로그램의 의미 단위로 분할
- 기능별로 자연스럽게 분할
```

#### 세그먼트 종류
```
전형적인 세그먼트 구조:

세그먼트 0: Code 영역
├─ main() 함수
├─ 사용자 정의 함수들
└─ 라이브러리 함수들

세그먼트 1: Data 영역  
├─ 전역 변수
├─ 정적 변수
└─ 상수들

세그먼트 2: Stack 영역
├─ 지역 변수
├─ 함수 매개변수
└─ 리턴 주소

세그먼트 3: Heap 영역
├─ 동적 할당 메모리
└─ malloc/new로 할당된 공간
```

### 세그멘테이션 동작 원리

#### 세그먼트 테이블
각 세그먼트의 정보를 저장하는 표

```
세그먼트 테이블 구조:
┌────────────┬──────────┬─────────┐
│세그먼트 번호│ 기준 주소 │ 한계값  │
├────────────┼──────────┼─────────┤
│     0      │   1000   │  2000   │ Code
│     1      │   4000   │  1000   │ Data  
│     2      │   8000   │  3000   │ Stack
│     3      │  12000   │  5000   │ Heap
└────────────┴──────────┴─────────┘
```

#### 주소 변환 과정
```
논리적 주소 구조:
┌─────────────┬─────────────────┐
│세그먼트 번호 │ 세그먼트 오프셋  │
└─────────────┴─────────────────┘

변환 단계:
1. 논리 주소에서 세그먼트 번호와 오프셋 분리
2. 세그먼트 테이블에서 해당 세그먼트 정보 찾기
3. 오프셋이 한계값을 넘는지 확인 (보호 기능)
4. 기준 주소 + 오프셋 = 물리적 주소
```

### 세그멘테이션의 특징

#### 보호와 공유
```
보호 (Protection):
- 세그먼트별로 접근 권한 설정 가능
- Code: 읽기/실행만 허용
- Data: 읽기/쓰기 허용
- Stack: 읽기/쓰기 허용

공유 (Sharing):
- 의미 단위로 나뉘어 있어 공유하기 쉬움  
- 여러 프로세스가 같은 Code 세그먼트 공유 가능
- 라이브러리 코드를 여러 프로그램이 공유
```

#### 동적 증가
```
Stack과 Heap 세그먼트:
- 실행 중에 크기가 변할 수 있음
- Stack: 함수 호출 시 증가
- Heap: 동적 할당 시 증가
- 세그먼트 테이블의 한계값도 동적으로 조정
```

---

## 페이징 vs 세그멘테이션 비교

### 상세 비교표

| 구분 | 페이징 | 세그멘테이션 |
|------|--------|-------------|
| **분할 방식** | 물리적 (고정 크기) | 논리적 (가변 크기) |
| **분할 크기** | 모든 페이지 동일 (4KB) | 세그먼트마다 다름 |
| **파편화** | 내부 파편화 | 외부 파편화 |
| **주소 공간** | 1차원 | 2차원 (세그먼트+오프셋) |
| **보호 기능** | 어려움 | 쉬움 (의미 단위) |
| **공유 기능** | 어려움 | 쉬움 (코드 공유) |
| **구현 복잡도** | 단순함 | 복잡함 |

### 장단점 정리

#### 페이징
```
장점:
- 외부 파편화 완전 해결
- 구현이 단순함  
- 메모리 관리 용이

단점:
- 내부 파편화 존재
- 의미 단위 보호/공유 어려움
- 페이지 테이블 공간 필요
```

#### 세그멘테이션
```
장점:
- 논리적 단위로 보호/공유 쉬움
- 프로그래머 친화적
- 동적 세그먼트 크기 조정 가능

단점:  
- 외부 파편화 발생
- 구현이 복잡함
- 가변 크기로 인한 관리 어려움
```

---

## 페이지드 세그멘테이션 (Paged Segmentation)

### 하이브리드 접근법
두 기법의 장점을 결합한 방식

```
동작 방식:
1. 프로그램을 의미 단위로 세그먼트 분할
2. 각 세그먼트를 다시 페이지로 분할
3. 2단계 주소 변환 수행

주소 변환:
논리 주소 → 세그먼트 테이블 → 페이지 테이블 → 물리 주소
```

### 장점
- 세그멘테이션의 보호/공유 기능 유지
- 페이징의 외부 파편화 해결 효과
- 현대 운영체제에서 널리 사용

---

## 실제 시스템에서의 활용

### Intel x86 아키텍처
```
초기 설계:
- 세그멘테이션 기반 (8086, 80286)
- 세그먼트 레지스터 사용 (CS, DS, SS, ES)

현재:
- 페이징 위주로 전환 (80386 이후)
- 세그멘테이션은 호환성 유지 목적
```

### 현대 운영체제
```
Linux/Windows:
- 페이징을 주요 메모리 관리 기법으로 사용
- 가상 메모리와 함께 구현
- 4KB 페이지 크기가 표준
```

### ARM 아키텍처
```
모바일 기기:
- 페이징 기반
- 저전력 최적화
- 다양한 페이지 크기 지원 (4KB, 64KB)
```

---

## 핵심 정리

### 메모리 관리 기법의 진화
```
1단계: 연속 할당 → 외부 파편화 문제
2단계: 페이징 → 파편화 해결, 보호/공유 어려움  
3단계: 세그멘테이션 → 보호/공유 해결, 파편화 재발
4단계: 페이지드 세그멘테이션 → 두 장점 결합
```

### 선택 기준
- **단순한 시스템**: 페이징
- **보호가 중요한 시스템**: 세그멘테이션  
- **현대 범용 시스템**: 페이징 + 가상 메모리
- **고급 시스템**: 페이지드 세그멘테이션

### 기억할 핵심 개념
- **페이징**: 고정 크기, 물리적 분할, 외부 파편화 해결
- **세그멘테이션**: 가변 크기, 논리적 분할, 보호/공유 용이
- **주소 변환**: 논리 주소 → 테이블 참조 → 물리 주소
- **파편화**: 내부(페이징) vs 외부(세그멘테이션)

두 기법 모두 **비연속 할당**을 통해 메모리 효율성을 높이는 것이 목표이며, 현대 시스템에서는 상황에 맞게 적절히 조합하여 사용함