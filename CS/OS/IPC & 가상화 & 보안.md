# IPC & 가상화 & 보안

## Part 1: IPC (Inter-Process Communication)

### 1. IPC의 필요성

#### 프로세스의 독립성 문제
```
프로세스 특징:
- 각자 독립된 메모리 공간
- 다른 프로세스의 메모리 접근 불가
- 보안과 안정성을 위한 설계

문제:
- 협력이 필요한 프로세스들은 어떻게 통신?
- 데이터를 어떻게 공유?
```

#### IPC의 정의
프로세스 간에 데이터를 주고받는 메커니즘

---

### 2. IPC 방식의 분류

#### (1) 공유 메모리 방식
여러 프로세스가 같은 메모리 영역 공유

#### (2) 메시지 전달 방식
프로세스 간 메시지를 주고받음

---

## 3. IPC 메커니즘 종류

### (1) 파이프 (Pipe)

#### 개념
한 프로세스의 출력을 다른 프로세스의 입력으로 연결하는 통로

#### 익명 파이프 (Anonymous Pipe)
```
특징:
- 부모-자식 프로세스 간 통신
- 단방향 통신 (한쪽은 쓰기, 한쪽은 읽기)
- 양방향 통신 위해서는 2개 필요

구조:
프로세스 A ──[쓰기]──→ PIPE ──[읽기]──→ 프로세스 B
```

**동작 방식**
```
1. 파이프 생성
2. 프로세스 fork로 복제
3. 부모는 쓰기용, 자식은 읽기용 사용
4. 사용 안하는 끝은 닫기
5. 데이터 주고받기
```

**Shell에서의 사용**
```bash
ls | grep "txt"
   ↑     ↑
  쓰기  읽기
  
ls의 출력이 grep의 입력으로 전달됨
```

#### 명명된 파이프 (Named Pipe, FIFO)
```
특징:
- 파일 시스템에 이름으로 존재
- 관계없는 프로세스 간 통신 가능
- 양방향 가능

생성:
mkfifo myfifo (명령어로 생성)

사용:
프로세스 A: myfifo에 데이터 쓰기
프로세스 B: myfifo에서 데이터 읽기
```

**장점**
- 구현 단순
- 자동 동기화 (버퍼 관리)

**단점**
- 단방향 (익명 파이프)
- 부모-자식 관계 필요 (익명 파이프)
- 데이터 형식 제한

---

### (2) 메시지 큐 (Message Queue)

#### 개념
메시지를 큐에 넣고 빼는 방식

```
구조:
프로세스 A ──[메시지1]──→ ┌──────┐
프로세스 B ──[메시지2]──→ │ 큐   │ ──→ 프로세스 C
프로세스 C ──[메시지3]──→ └──────┘
                          FIFO
```

#### 특징
```
메시지 단위:
- 각 메시지는 타입과 데이터 포함
- 타입별로 선택적 읽기 가능

비동기 통신:
- 보내는 쪽: 큐에 넣고 계속 진행
- 받는 쪽: 필요할 때 읽기
```

**동작 방식**
```
1. 메시지 큐 생성
2. 프로세스 A: 메시지 타입과 데이터를 큐에 전송
3. 프로세스 B: 특정 타입의 메시지만 선택해서 수신
4. 필요 없으면 메시지 큐 제거
```

**장점**
- 비동기 통신
- 메시지 타입으로 선택적 읽기
- 여러 프로세스 간 통신 가능

**단점**
- 커널 버퍼 사용 (메모리 제한)
- 복사 오버헤드 (사용자↔커널)

---

### (3) 공유 메모리 (Shared Memory)

#### 개념
여러 프로세스가 동일한 메모리 영역을 공유

```
구조:
┌──────────┐   ┌──────────┐
│프로세스 A │   │프로세스 B │
└─────┬────┘   └────┬─────┘
      │             │
      └──────┬──────┘
             ↓
      ┌──────────┐
      │공유 메모리│
      └──────────┘
```

#### 특징
```
가장 빠른 IPC:
- 커널 경유 안 함
- 메모리 직접 접근
- 복사 불필요

동기화 필요:
- 동시 접근 시 충돌 가능
- 세마포어, 뮤텍스 필수
```

**동작 방식**
```
1. 공유 메모리 영역 생성
2. 각 프로세스가 자신의 주소 공간에 연결
3. 일반 메모리처럼 읽기/쓰기
4. 동기화 도구로 접근 제어
5. 사용 완료 후 연결 해제
```

**장점**
- 가장 빠름
- 대용량 데이터 교환 효율적

**단점**
- 동기화 코드 필요 (복잡도 증가)
- 동시 접근 제어 어려움

---

### (4) 소켓 (Socket)

#### 개념
네트워크 통신을 위한 IPC (같은 컴퓨터 or 다른 컴퓨터)

```
구조:
┌──────────┐      네트워크      ┌──────────┐
│프로세스 A │ ←──────────────→ │프로세스 B │
│(클라이언트)│                  │ (서버)   │
└──────────┘                  └──────────┘
```

#### 종류

**Unix Domain Socket**
```
같은 시스템 내 프로세스 간 통신:
- 파일 시스템 경로 사용
- 네트워크 오버헤드 없음
- 빠름
```

**Internet Socket**
```
네트워크를 통한 통신:
- IP 주소 + 포트 번호
- TCP/UDP 프로토콜
- 원격 통신 가능
```

**동작 방식**
```
서버:
1. 소켓 생성
2. 주소 바인딩 (IP + 포트)
3. 연결 대기 (listen)
4. 클라이언트 연결 수락 (accept)
5. 데이터 주고받기

클라이언트:
1. 소켓 생성
2. 서버에 연결 (connect)
3. 데이터 주고받기
```

**장점**
- 네트워크 통신 가능
- 양방향 통신
- 표준화된 인터페이스

**단점**
- 오버헤드 큼
- 구현 복잡

---

### (5) 시그널 (Signal)

#### 개념
프로세스에게 이벤트 발생을 알리는 소프트웨어 인터럽트

```
사용 예:
SIGINT  - Ctrl+C (프로그램 종료)
SIGKILL - 강제 종료
SIGCHLD - 자식 프로세스 종료
SIGUSR1 - 사용자 정의 시그널
```

**동작 방식**
```
1. 시그널 핸들러 등록 (어떤 시그널을 받으면 어떻게 처리할지)
2. 다른 프로세스가 시그널 전송
3. 운영체제가 대상 프로세스에 전달
4. 등록된 핸들러 실행
```

**특징**
- 간단한 알림용
- 데이터 전달 불가 (시그널 번호만)
- 비동기적

---

## 4. IPC 방식 비교

| 방식 | 속도 | 데이터 크기 | 양방향 | 네트워크 | 동기화 |
|------|------|-------------|--------|----------|--------|
| 파이프 | 보통 | 제한적 | 단방향 | X | 자동 |
| 메시지 큐 | 보통 | 중간 | O | X | 자동 |
| 공유 메모리 | 빠름 | 큼 | O | X | 수동 |
| 소켓 | 느림 | 큼 | O | O | 자동 |
| 시그널 | 빠름 | 없음 | O | X | - |

---

## Part 2: 가상화 (Virtualization)

### 1. 가상화의 개념

#### 정의
물리적 자원을 논리적으로 추상화하여 여러 개처럼 보이게 하거나, 없는 것을 있는 것처럼 보이게 하는 기술

#### 가상화의 목적
```
자원 활용 극대화:
- 하나의 물리적 자원을 여러 용도로 사용
- 유휴 자원 활용

격리와 독립성:
- 각 환경이 독립적으로 동작
- 하나의 오류가 다른 환경에 영향 안 줌

이식성:
- 환경을 쉽게 이동 가능
- 백업과 복구 용이
```

---

### 2. 가상화의 종류

#### (1) CPU 가상화
```
하나의 물리 CPU를 여러 가상 CPU로 분할:
- 타임 슬라이싱
- 각 VM이 독립된 CPU 사용하는 것처럼 보임
```

#### (2) 메모리 가상화
```
앞서 배운 가상 메모리:
- 물리 메모리보다 큰 주소 공간 제공
- 디스크를 메모리처럼 사용

VM의 메모리 가상화:
- 게스트 OS가 보는 메모리 주소
- 하이퍼바이저가 실제 물리 메모리로 매핑
```

#### (3) 저장소 가상화
```
여러 물리 디스크를 하나로:
- RAID
- 논리 볼륨 관리

하나의 디스크를 여러 개로:
- 파티션
- 가상 디스크 이미지
```

#### (4) 네트워크 가상화
```
가상 네트워크 인터페이스:
- 하나의 물리 NIC → 여러 가상 NIC
- 각 VM이 독립된 네트워크

소프트웨어 정의 네트워크 (SDN)
```

---

### 3. 가상 머신 (Virtual Machine)

#### 개념
물리적 컴퓨터 위에서 실행되는 가상의 컴퓨터

```
구조:
┌─────────┬─────────┬─────────┐
│  VM 1   │  VM 2   │  VM 3   │
│ (Linux) │(Windows)│(macOS)  │
├─────────┴─────────┴─────────┤
│      하이퍼바이저             │
├───────────────────────────┤
│    물리적 하드웨어           │
└───────────────────────────┘
```

#### Type 1 하이퍼바이저 (Bare Metal)

```
특징:
- 하드웨어 위에 직접 설치
- 호스트 OS 없음
- 높은 성능

예시:
- VMware ESXi
- Microsoft Hyper-V
- Xen
- KVM

용도:
- 데이터센터
- 클라우드 서비스
- 엔터프라이즈 서버
```

#### Type 2 하이퍼바이저 (Hosted)

```
특징:
- 호스트 OS 위에서 실행
- 응용 프로그램처럼 설치
- 상대적으로 느림

예시:
- VMware Workstation
- VirtualBox
- Parallels Desktop

용도:
- 개발/테스트
- 개인 사용
- 교육
```

---

### 4. 컨테이너 (Container)

#### 개념
OS 레벨 가상화 - 커널은 공유하고 프로세스만 격리

```
구조:
┌────────┬────────┬────────┐
│ App A  │ App B  │ App C  │
│ Libs   │ Libs   │ Libs   │
├────────┴────────┴────────┤
│  Container Engine        │
│  (Docker, containerd)    │
├──────────────────────────┤
│    Host OS (Linux)       │
├──────────────────────────┤
│      하드웨어            │
└──────────────────────────┘
```

#### VM vs Container

```
Virtual Machine:
구조:
- 각 VM마다 전체 OS
- 하이퍼바이저

특징:
- 무거움 (GB 단위)
- 부팅 느림 (분)
- 완전한 격리
- 다른 OS 실행 가능

Container:
구조:
- 호스트 커널 공유
- 프로세스 격리

특징:
- 가벼움 (MB 단위)
- 시작 빠름 (초)
- 프로세스 수준 격리
- 같은 OS만 가능
```

#### 컨테이너 격리 기술

**네임스페이스 (Namespace)**
```
프로세스 격리:
- PID: 프로세스 ID 격리
- NET: 네트워크 격리
- MNT: 파일 시스템 격리
- UTS: 호스트명 격리
- IPC: IPC 자원 격리
- USER: 사용자 ID 격리

각 컨테이너는 독립된 네임스페이스에서 실행
```

**cgroups (Control Groups)**
```
자원 제한:
- CPU 사용량 제한
- 메모리 사용량 제한
- 디스크 I/O 제한
- 네트워크 대역폭 제한

예시:
컨테이너 A: CPU 50%, 메모리 1GB
컨테이너 B: CPU 30%, 메모리 512MB
```

#### Docker

```
구성 요소:
- 이미지: 컨테이너의 템플릿 (실행 파일 같은 것)
- 컨테이너: 이미지의 실행 인스턴스 (실행 중인 프로세스)
- Dockerfile: 이미지 빌드 명세 (레시피)
- 레지스트리: 이미지 저장소 (앱스토어 같은 것)

동작:
1. Dockerfile 작성 (어떤 환경 필요한지)
2. 이미지 빌드 (실행 파일 만들기)
3. 컨테이너 실행 (프로그램 실행)
```

---

### 5. 가상화의 장단점

#### 장점
```
자원 효율성:
- 하드웨어 활용률 증가
- 비용 절감

관리 편의성:
- 중앙 집중 관리
- 쉬운 백업/복구
- 빠른 프로비저닝

유연성:
- 다양한 OS 테스트
- 개발 환경 일치
- 이식성
```

#### 단점
```
성능 오버헤드:
- 가상화 레이어 추가
- 일부 성능 손실

복잡성:
- 관리 도구 필요
- 학습 곡선

라이선스:
- 각 VM마다 OS 라이선스 필요 (VM)
```

---

## Part 3: 보안 (Security)

### 1. 운영체제 보안의 목표

#### CIA 트라이어드
```
Confidentiality (기밀성):
- 인가된 사용자만 접근
- 데이터 유출 방지

Integrity (무결성):
- 데이터가 변조되지 않음
- 허가된 방식으로만 수정

Availability (가용성):
- 필요할 때 시스템 사용 가능
- 서비스 거부 공격 방어
```

---

### 2. 보안 위협

#### (1) 악성 코드 (Malware)
```
바이러스:
- 다른 프로그램에 기생
- 자가 복제

웜:
- 독립적으로 실행
- 네트워크로 전파

트로이 목마:
- 정상 프로그램으로 위장
- 백도어 설치

랜섬웨어:
- 파일 암호화
- 금전 요구
```

#### (2) 침입 공격
```
버퍼 오버플로우:
- 메모리 경계 넘어 쓰기
- 코드 실행 권한 획득

권한 상승:
- 일반 사용자 → 관리자
- 취약점 악용

SQL 인젝션:
- 데이터베이스 조작
- 인증 우회
```

---

### 3. 보안 메커니즘

### (1) 접근 제어 (Access Control)

#### 사용자 인증 (Authentication)
```
방법:
- 비밀번호
- 생체 인식 (지문, 얼굴)
- 2단계 인증
- 인증서
```

#### 접근 권한 (Authorization)
```
파일 권한 (Unix):
rwxrwxrwx
│││││││││
│││└┴┴─── 기타 사용자 (Others)
││└────── 그룹 (Group)
│└─────── 소유자 (Owner)
└──────── r: 읽기, w: 쓰기, x: 실행

예시:
-rw-r--r--  file.txt
- 소유자: 읽기, 쓰기
- 그룹: 읽기만
- 기타: 읽기만
```

#### 접근 제어 모델

**임의 접근 제어 (DAC)**
```
특징:
- 소유자가 권한 결정
- 유연함
- Unix 파일 권한

단점:
- 소유자가 실수 가능
```

**강제 접근 제어 (MAC)**
```
특징:
- 시스템이 권한 결정
- 보안 레벨 기반
- 군사, 정부 시스템

예시:
Top Secret > Secret > Confidential > Unclassified
```

**역할 기반 접근 제어 (RBAC)**
```
특징:
- 역할에 권한 부여
- 사용자는 역할 할당받음

예시:
관리자 역할: 모든 권한
일반 사용자 역할: 읽기만
손님 역할: 제한적 읽기
```

---

### (2) 메모리 보호

#### 주소 공간 격리
```
각 프로세스의 가상 메모리 공간 분리:
- 다른 프로세스 메모리 접근 불가
- MMU와 페이지 테이블로 강제
```

#### ASLR (Address Space Layout Randomization)
```
개념:
- 메모리 레이아웃을 랜덤화
- 공격자가 주소 예측 못함

효과:
스택 주소: 매번 다른 위치
힙 주소: 매번 다른 위치
라이브러리: 매번 다른 위치

→ 버퍼 오버플로우 공격 어려움
```

#### DEP (Data Execution Prevention)
```
개념:
- 데이터 영역을 실행 불가로 설정
- NX 비트 (No eXecute)

효과:
스택에 코드 주입해도 실행 안 됨
힙에 코드 주입해도 실행 안 됨

→ 코드 인젝션 공격 방어
```

#### 스택 카나리 (Stack Canary)
```
개념:
- 스택에 특별한 값 배치
- 함수 반환 전 확인

동작:
함수 시작: [카나리 값 저장]
함수 종료: [카나리 값 확인]
           ↓
    변조됨? → 프로그램 종료

→ 버퍼 오버플로우 탐지
```

---

### (3) 커널 보안

#### 사용자 모드 vs 커널 모드 분리
```
이전에 배운 내용:
- 사용자 모드: 제한된 권한
- 커널 모드: 모든 권한
- 시스템 콜로만 전환

보안 효과:
- 응용 프로그램이 커널 메모리 접근 불가
- 하드웨어 직접 제어 불가
- 특권 명령어 실행 불가
```

#### 시스템 콜 검증
```
커널은 모든 시스템 콜 인자 검증:
- 포인터가 유효한 사용자 메모리 가리키는지
- 파일 디스크립터가 유효한지
- 권한이 있는지

악의적 인자 차단
```

---

### (4) 샌드박싱 (Sandboxing)

#### 개념
프로그램을 격리된 환경에서 실행

```
구조:
┌──────────────────┐
│   샌드박스       │
│  ┌──────────┐    │
│  │  앱      │    │
│  └──────────┘    │
│                  │
│  제한된 권한:    │
│  - 특정 파일만   │
│  - 네트워크 제한 │
│  - 시스템 콜 제한│
└──────────────────┘
```

#### 적용 사례
```
웹 브라우저:
- 각 탭이 샌드박스에서 실행
- 악성 사이트 방문해도 시스템 안전

모바일 앱:
- 각 앱이 권한 제한
- 다른 앱 데이터 접근 불가

Docker 컨테이너:
- 프로세스 격리
- 자원 제한
```

---

### (5) 암호화 (Encryption)

#### 디스크 암호화
```
전체 디스크 암호화:
- 모든 데이터 암호화
- 부팅 시 복호화

효과:
- 물리적 도난 시 데이터 보호
- 분실 시 데이터 유출 방지

예시:
- BitLocker (Windows)
- FileVault (macOS)
- LUKS (Linux)
```

#### 네트워크 암호화
```
SSL/TLS:
- HTTPS
- 데이터 전송 중 암호화

VPN:
- 가상 사설 네트워크
- 전체 트래픽 암호화
```

---

### (6) 보안 업데이트

#### 패치 관리
```
중요성:
- 취약점 발견 → 패치 배포
- 빠른 적용 필요

자동 업데이트:
- 운영체제 정기 업데이트
- 보안 패치 우선 적용
```

---

### 4. SELinux (Security-Enhanced Linux)

#### 개념
리눅스 커널에 강제 접근 제어 (MAC) 추가

```
동작:
- 모든 프로세스와 파일에 보안 컨텍스트
- 정책 기반 접근 제어
- 최소 권한 원칙

예시:
웹 서버 프로세스:
- /var/www/html/ 접근 허용
- /etc/passwd 접근 거부
- 네트워크 포트 80, 443만 허용
```

---

### 5. 보안 모범 사례

#### 최소 권한 원칙
```
필요한 최소한의 권한만 부여:
- 관리자 권한은 필요할 때만
- 프로세스는 필요한 권한만
- 사용자는 필요한 파일만 접근
```

#### 다층 방어 (Defense in Depth)
```
여러 보안 계층:
1. 방화벽 (네트워크)
2. 인증/인가 (접근 제어)
3. 암호화 (데이터)
4. 감사 로그 (모니터링)
5. 물리적 보안

한 계층 뚫려도 다른 계층에서 방어
```

#### 보안 감사
```
정기적 점검:
- 로그 분석
- 침입 탐지
- 취약점 스캔
- 권한 검토
```

---

## 핵심 정리

### IPC 선택 기준
```
파이프: 부모-자식, 단순 데이터 전달
메시지 큐: 비동기, 메시지 단위
공유 메모리: 대용량, 고속 (동기화 필요)
소켓: 네트워크 통신
시그널: 간단한 알림
```

### 가상화 비교
```
VM:
- 완전한 격리
- 다른 OS 가능
- 무거움

Container:
- 가벼움
- 빠른 시작
- 같은 OS
- 프로세스 격리
```

### 보안의 핵심
```
다층 방어:
1. 사용자/커널 모드 분리
2. 메모리 보호 (ASLR, DEP)
3. 접근 제어
4. 암호화
5. 샌드박싱
6. 정기 업데이트

최소 권한 원칙 + 지속적 모니터링
```