# 인터럽트(Interrupt) 완전 정복 가이드 ⚡

## 📖 목차
1. [인터럽트 기본 개념](#인터럽트-기본-개념)
2. [인터럽트 종류와 분류](#인터럽트-종류와-분류)
3. [인터럽트 처리 메커니즘](#인터럽트-처리-메커니즘)
4. [인터럽트 벡터와 테이블](#인터럽트-벡터와-테이블)
5. [인터럽트 우선순위 시스템](#인터럽트-우선순위-시스템)
6. [인터럽트 서비스 루틴(ISR)](#인터럽트-서비스-루틴isr)
7. [인터럽트 vs 예외 vs 트랩](#인터럽트-vs-예외-vs-트랩)
8. [하드웨어별 인터럽트 구현](#하드웨어별-인터럽트-구현)
9. [인터럽트와 시스템 성능](#인터럽트와-시스템-성능)
10. [현대 시스템의 인터럽트](#현대-시스템의-인터럽트)
11. [실제 예시와 프로그래밍](#실제-예시와-프로그래밍)
12. [스터디 팁과 총정리](#스터디-팁과-총정리)

---

## ⚡ 인터럽트 기본 개념

### 인터럽트란 무엇인가?

**인터럽트(Interrupt)**는 CPU가 현재 실행 중인 프로그램을 일시 중단하고, 다른 긴급하거나 중요한 작업을 처리하기 위해 제어권을 넘기는 메커니즘입니다.

```
현실 비유:
당신이 책을 읽고 있는데 (= CPU가 프로그램 실행)
전화벨이 울림 (= 인터럽트 발생)
책갈피 끼워두고 (= 컨텍스트 저장)
전화 받기 (= 인터럽트 처리)
통화 끝나면 (= ISR 완료)
책갈피 찾아서 (= 컨텍스트 복원)
다시 책 읽기 (= 원래 프로그램 재개)
```

### 인터럽트의 핵심 특징

#### 1. **비동기성 (Asynchronous)**
```
- CPU가 예측할 수 없는 시점에 발생
- 현재 실행 중인 명령어와 무관하게 발생
- 외부 이벤트에 의해 트리거됨
```

#### 2. **우선순위 기반 처리**
```
- 긴급도에 따른 처리 순서 결정
- 높은 우선순위 인터럽트가 낮은 우선순위를 선점 가능
- 시스템 안정성과 응답성 보장
```

#### 3. **자동 컨텍스트 보존**
```
- 하드웨어가 자동으로 CPU 상태 저장
- 인터럽트 처리 후 원래 상태로 완벽 복원
- 투명성 보장 (원래 프로그램이 인터럽트를 모름)
```

### 인터럽트의 필요성과 장점

#### 왜 인터럽트가 필요한가?

**1. 효율성 (Efficiency)**
```
폴링 방식의 문제:
while (true) {
    if (키보드_입력_있음()) {
        처리();
    }
    if (네트워크_패킷_도착()) {
        처리();
    }
    if (타이머_만료()) {
        처리();
    }
    // CPU가 계속 확인만 하며 낭비됨
}

인터럽트 방식의 해결:
- 이벤트 발생 시에만 CPU 개입
- 나머지 시간은 다른 작업 수행 가능
- CPU 활용률 대폭 향상
```

**2. 응답성 (Responsiveness)**
```
실시간 요구사항:
- 키보드 입력: 10-100ms 내 반응
- 마우스 이동: 1-10ms 내 반응
- 네트워크 패킷: μs 단위 반응
- 하드웨어 오류: 즉시 반응

인터럽트 없다면:
- 폴링 주기에 따른 지연 발생
- 실시간성 보장 불가능
```

**3. 멀티태스킹 지원**
```
타이머 인터럽트의 역할:
- 일정 시간마다 발생 (보통 1-10ms)
- 현재 프로세스 실행 중단
- 스케줄러가 다음 프로세스 선택
- 컨텍스트 스위칭 수행
→ 여러 프로그램이 동시 실행되는 것처럼 보임
```

**4. 하드웨어 추상화**
```
- 복잡한 하드웨어 동작을 소프트웨어가 직접 관리하지 않음
- 디바이스 드라이버가 인터럽트 기반으로 하드웨어 제어
- 응용 프로그램은 하드웨어 세부사항 몰라도 됨
```

---

## 🎭 인터럽트 종류와 분류

### 1. 발생 원인에 따른 분류

#### 1.1 하드웨어 인터럽트 (Hardware Interrupt)

외부 하드웨어 장치에서 발생하는 인터럽트

**외부 인터럽트 (External Interrupt)**
```
입력 장치:
- 키보드: 키 누름/떼기
- 마우스: 이동, 클릭, 스크롤
- 터치스크린: 터치, 멀티터치
- 조이스틱: 버튼, 방향키

센서류:
- 온도 센서: 임계값 초과
- 가속도 센서: 충격 감지
- 근접 센서: 물체 감지
```

**I/O 인터럽트 (I/O Interrupt)**
```
저장 장치:
- 하드디스크: 읽기/쓰기 완료
- SSD: 데이터 전송 완료
- 광학 드라이브: 디스크 삽입/제거

네트워크:
- 이더넷: 패킷 수신
- Wi-Fi: 연결 상태 변화
- 블루투스: 페어링 요청

프린터/스캐너:
- 용지 부족, 잉크 부족
- 인쇄 작업 완료
- 스캔 완료
```

**타이머 인터럽트 (Timer Interrupt)**
```
시스템 타이머:
- PIT (Programmable Interval Timer): 18.2Hz
- APIC Timer: 가변 주파수
- HPET (High Precision Event Timer): 고정밀도

용도:
- 프로세스 스케줄링 (Time slice)
- 시스템 시간 업데이트
- 타임아웃 처리
- 성능 모니터링
```

#### 1.2 소프트웨어 인터럽트 (Software Interrupt)

소프트웨어에 의해 의도적으로 발생하는 인터럽트

**시스템 콜 (System Call)**
```
파일 시스템:
- open(), read(), write(), close()
- mkdir(), rmdir(), chmod()

프로세스 관리:
- fork(), exec(), exit(), wait()
- kill(), getpid(), sleep()

네트워크:
- socket(), bind(), listen(), accept()
- send(), recv(), connect()

메모리 관리:
- malloc(), free(), mmap(), munmap()
```

**예외 (Exception)**
```
산술 예외:
- Division by Zero (0으로 나누기)
- Overflow (산술 오버플로우)
- Underflow (언더플로우)

메모리 예외:
- Segmentation Fault (잘못된 메모리 접근)
- Page Fault (페이지 부재)
- Stack Overflow (스택 오버플로우)

명령어 예외:
- Illegal Instruction (잘못된 명령어)
- Privilege Violation (권한 위반)
- Alignment Error (정렬 오류)
```

### 2. 마스킹 가능성에 따른 분류

#### 2.1 마스커블 인터럽트 (Maskable Interrupt)

소프트웨어적으로 비활성화할 수 있는 인터럽트

```
특징:
- 인터럽트 플래그(IF)로 제어 가능
- CLI 명령어로 비활성화
- STI 명령어로 활성화
- 긴급하지 않은 일반적인 인터럽트

예시:
- 키보드, 마우스 입력
- 네트워크 패킷 도착
- 타이머 인터럽트
- 디스크 I/O 완료
```

#### 2.2 논마스커블 인터럽트 (Non-Maskable Interrupt, NMI)

절대 비활성화할 수 없는 최고 우선순위 인터럽트

```
특징:
- 소프트웨어로 비활성화 불가능
- 시스템 안정성과 직결
- 즉시 처리해야 하는 치명적 상황

예시:
- 메모리 패리티 오류
- 버스 오류
- 전원 공급 이상
- 하드웨어 고장
- 시스템 리셋 버튼
- Watchdog 타이머 만료
```

### 3. 우선순위에 따른 분류

```
우선순위 (높음 → 낮음):

1. 하드웨어 리셋 (최고 우선순위)
   - 전원 리셋, 시스템 리셋

2. 논마스커블 인터럽트 (NMI)
   - 패리티 오류, 버스 오류

3. 마스커블 하드웨어 인터럽트
   Level 0: 타이머 (IRQ 0)
   Level 1: 키보드 (IRQ 1)
   Level 2: Cascade (IRQ 2)
   Level 3: COM2 (IRQ 3)
   Level 4: COM1 (IRQ 4)
   Level 5: LPT2 (IRQ 5)
   Level 6: 플로피 디스크 (IRQ 6)
   Level 7: LPT1 (IRQ 7)
   Level 8: 실시간 시계 (IRQ 8)
   ...
   Level 15: 보조 IDE (IRQ 15)

4. 소프트웨어 인터럽트 (최저 우선순위)
   - 시스템 콜, 예외
```

---

## 🔄 인터럽트 처리 메커니즘

### 인터럽트 발생부터 처리까지의 전체 과정

```
[1] 인터럽트 발생
     ↓
[2] 인터럽트 신호 검사
     ↓
[3] 현재 명령어 완료
     ↓
[4] 인터럽트 승인 (INTA)
     ↓
[5] 컨텍스트 저장
     ↓
[6] 인터럽트 벡터 확인
     ↓
[7] ISR 주소 획득
     ↓
[8] ISR 실행
     ↓
[9] 컨텍스트 복원
     ↓
[10] 원래 프로그램 재개
```

### 단계별 상세 분석

#### 1단계: 인터럽트 발생 (Interrupt Request)

**하드웨어적 신호 생성**
```
인터럽트 신호선:
- IRQ (Interrupt Request) 라인
- 전기적 신호: LOW → HIGH 또는 HIGH → LOW
- 지속 시간: 수 나노초 ~ 수 마이크로초

신호 방식:
- 엣지 트리거 (Edge-triggered): 신호 변화 순간 감지
- 레벨 트리거 (Level-triggered): 신호 레벨 유지 시 감지
```

#### 2단계: 인터럽트 신호 검사 (Interrupt Polling)

**CPU의 인터럽트 검사 시점**
```
검사 시점:
1. 각 명령어 실행 완료 후
2. 인터럽트가 활성화된 상태에서만
3. 현재 실행 중인 인터럽트보다 높은 우선순위인 경우만

검사 조건:
- 인터럽트 플래그 (IF) = 1
- 현재 우선순위 < 요청된 인터럽트 우선순위
- 해당 인터럽트가 마스킹되지 않음
```

#### 3단계: 현재 명령어 완료 (Instruction Completion)

**원자성 보장**
```
완료해야 하는 이유:
- 명령어의 원자성 보장
- 중간 상태로 인한 데이터 무결성 문제 방지
- 복원 시 일관된 상태 유지

예외 상황:
- 매우 긴 명령어 (문자열 처리 등)
- 인터럽트 가능한 명령어 (REP 접두사)
- 특별한 처리 방식 필요
```

#### 4단계: 인터럽트 승인 (Interrupt Acknowledge)

**CPU와 인터럽트 컨트롤러 간 통신**
```
INTA (Interrupt Acknowledge) 신호:
1. CPU가 INTA# 신호 활성화
2. 인터럽트 컨트롤러가 벡터 번호 전송
3. 데이터 버스를 통해 8비트 벡터 번호 전달
4. CPU가 벡터 번호 수신 확인
```

#### 5단계: 컨텍스트 저장 (Context Saving)

**자동 저장 (하드웨어)**
```
x86 아키텍처 자동 저장 항목:
1. EFLAGS 레지스터 → 스택
2. CS (Code Segment) → 스택  
3. EIP (Instruction Pointer) → 스택

64비트 모드 (x86-64):
1. RFLAGS → 스택
2. CS → 스택
3. RIP → 스택

스택 상태 변화:
ESP-12: [EFLAGS]
ESP-8:  [CS]
ESP-4:  [EIP]
ESP:    ← 현재 스택 포인터
```

**수동 저장 (소프트웨어/ISR)**
```
ISR에서 추가 저장해야 할 항목:
- 범용 레지스터 (EAX, EBX, ECX, EDX, ...)
- 인덱스 레지스터 (ESI, EDI)
- 베이스 포인터 (EBP)
- 세그먼트 레지스터 (DS, ES, FS, GS)
- 기타 상태 레지스터

저장 순서 (PUSHA 명령어):
PUSH EAX
PUSH ECX  
PUSH EDX
PUSH EBX
PUSH ESP (원래 값)
PUSH EBP
PUSH ESI
PUSH EDI
```

#### 6-7단계: 인터럽트 벡터 처리

**벡터 테이블 참조**
```
과정:
1. 인터럽트 벡터 번호 획득 (0-255)
2. 벡터 테이블 기준 주소 (IDTR) 확인
3. 벡터 번호 × 8 바이트 = 오프셋 계산
4. IDTR + 오프셋 = 디스크립터 주소
5. 디스크립터에서 ISR 주소 추출
```

#### 8단계: ISR 실행

**인터럽트 서비스 루틴 처리**
```
ISR의 기본 구조:
1. 진입 시 추가 레지스터 저장
2. 인터럽트 컨트롤러에 EOI 신호 전송
3. 실제 인터럽트 처리 코드 실행
4. 필요시 스케줄링 결정
5. 저장된 레지스터 복원
6. IRET 명령어로 복귀
```

#### 9-10단계: 복원 및 재개

**컨텍스트 복원 (Context Restoration)**
```
복원 순서 (저장의 역순):
1. ISR에서 수동 저장한 레지스터들 복원
2. IRET 명령어 실행:
   - EIP ← 스택에서 팝
   - CS ← 스택에서 팝
   - EFLAGS ← 스택에서 팝
3. 원래 프로그램의 다음 명령어부터 실행 재개
```

### 인터럽트 처리 시간 분석

```
총 인터럽트 처리 시간 = 지연시간 + 처리시간 + 복원시간

지연시간 (Latency):
- 인터럽트 발생 → 인식: 1-2 클록
- 현재 명령어 완료: 1-20 클록
- 컨텍스트 저장: 10-50 클록
총 지연시간: 12-72 클록 (수 마이크로초)

처리시간:
- 실제 ISR 실행 시간
- 수십 ~ 수천 클록 (용도에 따라)

복원시간:
- 컨텍스트 복원: 10-50 클록
- IRET 실행: 2-5 클록
총 복원시간: 12-55 클록
```

---

## 🗂️ 인터럽트 벡터와 테이블

### 인터럽트 벡터의 개념

**인터럽트 벡터 (Interrupt Vector)**
```
정의: 특정 인터럽트에 대응하는 ISR의 주소 정보
크기: 아키텍처에 따라 다름 (x86: 8바이트, ARM: 4바이트)
번호: 0-255 (x86 기준, 총 256개)
```

**벡터 번호의 의미**
```
벡터 번호    의미                예시
0           Division by Zero    나누기 0 오류
1           Debug              디버그 트랩  
2           NMI                논마스커블 인터럽트
3           Breakpoint         브레이크포인트
4           Overflow           산술 오버플로우
5           Bound Range        범위 초과
6           Invalid Opcode     잘못된 명령어
7           Device Not Available FPU 없음
8           Double Fault       이중 오류
9           Coprocessor        보조프로세서 오류
10          Invalid TSS        잘못된 TSS
11          Segment Not Present 세그먼트 부재
12          Stack Fault        스택 오류
13          General Protection 일반 보호 오류
14          Page Fault         페이지 오류
15          Reserved           예약됨
16          FPU Error         부동소수점 오류
17          Alignment Check    정렬 검사
18          Machine Check      머신 체크
19          SIMD Exception     SIMD 예외
20-31       Reserved           예약됨
32-255      User Defined       사용자 정의/하드웨어
```

### 인터럽트 디스크립터 테이블 (IDT)

#### x86 아키텍처의 IDT 구조

**IDT 레지스터 (IDTR)**
```
구조 (10바이트):
- Limit (16비트): IDT 크기 - 1
- Base (32비트/64비트): IDT 시작 주소

설정 명령어:
LIDT [IDT_descriptor]  ; IDT 로드
SIDT [memory]          ; 현재 IDT 정보 저장
```

**게이트 디스크립터 구조**
```
8바이트 게이트 디스크립터:

31                16 15  14 13  12    8 7   5 4   0
+------------------+---+---+---+------+-----+-----+
|   Offset 31-16   | P |DPL| 0 | Type | 000 | 000 | +4
+------------------+---+---+---+------+-----+-----+
|     Selector     |         Offset 15-0          | +0  
+------------------+-------------------------------+

필드 설명:
- Offset: ISR 주소 (16비트씩 분할 저장)
- Selector: 코드 세그먼트 선택자
- Type: 게이트 타입 (인터럽트/트랩/태스크)
- DPL: 디스크립터 특권 레벨
- P: Present 비트 (유효/무효)
```

**게이트 타입**
```
타입 코드    게이트 종류            특징
0x5         32비트 태스크 게이트    태스크 스위칭
0x6         16비트 인터럽트 게이트  IF 클리어
0x7         16비트 트랩 게이트      IF 유지
0xE         32비트 인터럽트 게이트  IF 클리어  
0xF         32비트 트랩 게이트      IF 유지
```

#### IDT 초기화 과정

**부트 단계에서 IDT 설정**
```assembly
; IDT 디스크립터 구조체
idt_descriptor:
    dw idt_end - idt_start - 1  ; IDT 크기
    dd idt_start                ; IDT 시작 주소

; IDT 테이블 영역
idt_start:
    times 256 dq 0              ; 256개 엔트리, 8바이트씩

; IDT 로드
setup_idt:
    lidt [idt_descriptor]       ; IDT 레지스터 설정
    ret
```

**개별 인터럽트 벡터 설정**
```c
// C 코드로 IDT 엔트리 설정
void set_idt_entry(int vector, uint32_t handler, uint16_t selector, uint8_t flags) {
    idt[vector].offset_low = handler & 0xFFFF;
    idt[vector].offset_high = (handler >> 16) & 0xFFFF;
    idt[vector].selector = selector;
    idt[vector].flags = flags;
    idt[vector].reserved = 0;
}

// 사용 예시
set_idt_entry(0, (uint32_t)divide_by_zero_handler, 0x08, 0x8E);
set_idt_entry(1, (uint32_t)debug_handler, 0x08, 0x8E);
set_idt_entry(32, (uint32_t)timer_handler, 0x08, 0x8E);
```

### 다른 아키텍처의 벡터 테이블

#### ARM 아키텍처 벡터 테이블

**ARM 예외 벡터 테이블**
```
주소        예외 타입                설명
0x00000000  Reset                   리셋
0x00000004  Undefined Instruction   정의되지 않은 명령어
0x00000008  Software Interrupt      소프트웨어 인터럽트
0x0000000C  Prefetch Abort          명령어 프리페치 오류
0x00000010  Data Abort              데이터 접근 오류
0x00000014  Reserved                예약됨
0x00000018  IRQ                     일반 인터럽트
0x0000001C  FIQ                     빠른 인터럽트
```

**ARM 벡터 테이블 특징**
```
- 고정 위치: 보통 0x00000000 또는 0xFFFF0000
- 간단한 구조: 각 벡터 4바이트
- 직접 점프: 벡터 위치에 분기 명령어 저장
- 빠른 처리: 테이블 참조 없이 직접 실행
```

#### RISC-V 인터럽트 벡터

**RISC-V 트랩 벡터**
```
CSR 레지스터:
- mtvec: 머신 모드 트랩 벡터 기준 주소
- stvec: 슈퍼바이저 모드 트랩 벡터 기준 주소
- utvec: 유저 모드 트랩 벡터 기준 주소

모드:
- Direct: 모든 트랩이 기준 주소로 점프
- Vectored: 인터럽트는 기준 주소 + 4×cause로 점프
```

---

## 🏆 인터럽트 우선순위 시스템

### 우선순위의 필요성

**동시 인터럽트 발생 상황**
```
시나리오:
- 키보드 입력 인터럽트 처리 중
- 네트워크 패킷 도착 인터럽트 발생
- 동시에 타이머 인터럽트도 발생

문제:
- 어떤 인터럽트를 먼저 처리할 것인가?
- 현재 처리 중인 인터럽트를 중단해야 하는가?
- 시스템 안정성과 성능을 어떻게 보장할 것인가?
```

### 우선순위 기반 인터럽트 처리

#### 인터럽트 우선순위 레벨 (IPL)

**Intel 8259A PIC 우선순위**
```
IRQ 번호    우선순위    일반적 용도              장치 예시
IRQ 0       최고        시스템 타이머           PIT (8254)
IRQ 1       2          키보드                  키보드 컨트롤러
IRQ 2       3          Cascade (연결용)        보조 PIC
IRQ 3       4          시리얼 포트 2           COM2
IRQ 4       5          시리얼 포트 1           COM1  
IRQ 5       6          병렬 포트 2             LPT2
IRQ 6       7          플로피 디스크           FDD
IRQ 7       8          병렬 포트 1             LPT1
IRQ 8       9          실시간 시계             RTC
IRQ 9       10         사용 가능               네트워크, 사운드
IRQ 10      11         사용 가능               USB, SCSI
IRQ 11      12         사용 가능               USB, SCSI
IRQ 12      13         PS/2 마우스             마우스
IRQ 13      14         수치 연산 프로세서      FPU
IRQ 14      15         주 IDE 채널             하드디스크
IRQ 15      최저        보조 IDE 채널           CD-ROM
```

#### 인터럽트 선점 (Interrupt Preemption)

**선점 규칙**
```
1. 높은 우선순위가 낮은 우선순위를 선점 가능
2. 같은 우선순위끼리는 선점 불가 (대기)
3. 논마스커블 인터럽트는 모든 것을 선점

예시 시나리오:
T0: IRQ 7 (LPT1) 처리 중
T1: IRQ 1 (키보드) 발생 → 즉시 선점
T2: IRQ 1 처리 완료 → IRQ 7 재개
T3: IRQ 0 (타이머) 발생 → IRQ 7을 다시 선점
T4: IRQ 0 처리 완료 → IRQ 7 재개
```

**중첩 인터럽트 스택 상태**
```
인터럽트 중첩 시 스택 변화:

원래 프로그램 실행 중:
[스택 최상단]

IRQ 7 발생 시:
[원래 프로그램 컨텍스트]  ← IRQ 7이 저장
[스택 최상단]

IRQ 1 발생 시 (IRQ 7 선점):
[원래 프로그램 컨텍스트]  ← IRQ 7이 저장
[IRQ 7 컨텍스트]          ← IRQ 1이 저장  
[스택 최상단]
```

### 현대적 우선순위 관리

#### APIC (Advanced Programmable Interrupt Controller)

**로컬 APIC 우선순위**
```
우선순위 레벨: 0-15 (16단계)
- 15: 최고 우선순위 (NMI, SMI)
- 14-10: 시스템 관리 인터럽트
- 9-6: 실시간 인터럽트
- 5-2: 일반 하드웨어 인터럽트  
- 1-0: 낮은 우선순위 (배경 작업)

TPR (Task Priority Register):
- 현재 태스크의 우선순위 설정
- TPR보다 높은 우선순위만 인터럽트 가능
- 동적 우선순위 조정 가능
```

**MSI (Message Signaled Interrupts)**
```
특징:
- 메모리 쓰기 기반 인터럽트
- IRQ 라인 불필요
- 더 많은 인터럽트 지원 (수천 개)
- 우선순위를 메시지에 포함

MSI-X 확장:
- 더 많은 벡터 지원
- 독립적인 마스킹
- 디바이스별 세밀한 제어
```

#### 인터럽트 친화성 (Interrupt Affinity)

**멀티코어에서의 인터럽트 분산**
```
SMP 인터럽트 라우팅:
- 특정 인터럽트를 특정 코어에 할당
- 로드 밸런싱으로 성능 향상
- 캐시 지역성 개선

설정 예시 (Linux):
echo 2 > /proc/irq/24/smp_affinity  # IRQ 24를 CPU 1에 할당
echo 4 > /proc/irq/25/smp_affinity  # IRQ 25를 CPU 2에 할당
```

---

## 🛠️ 인터럽트 서비스 루틴(ISR)

### ISR의 기본 구조와 요구사항

#### ISR의 특징

**핵심 요구사항**
```
1. 빠른 실행 (Fast Execution)
   - 가능한 한 짧은 실행 시간
   - 복잡한 작업은 하반부로 이연

2. 재진입 안전성 (Reentrancy)
   - 다른 인터럽트에 의해 중단될 수 있음
   - 공유 데이터 보호 필요

3. 최소한의 스택 사용
   - 인터럽트 스택 오버플로우 방지
   - 지역 변수 사용 최소화

4. 원자성 보장
   - 크리티컬 섹션에서 인터럽트 비활성화
   - 데이터 일관성 유지
```

### ISR 작성 기법

#### 어셈블리 ISR 구조

**기본 ISR 템플릿**
```assembly
; 타이머 인터럽트 서비스 루틴
timer_isr:
    ; 1. 레지스터 저장 (푸시 순서 중요)
    pushf               ; 플래그 레지스터 저장
    pusha               ; 모든 범용 레지스터 저장
    push ds             ; 세그먼트 레지스터 저장
    push es
    push fs
    push gs
    
    ; 2. 세그먼트 레지스터 설정 (커널 모드)
    mov ax, 0x10        ; 커널 데이터 세그먼트
    mov ds, ax
    mov es, ax
    
    ; 3. 실제 인터럽트 처리
    call timer_handler  ; C 함수 호출
    
    ; 4. EOI (End of Interrupt) 신호 전송
    mov al, 0x20        ; EOI 명령
    out 0x20, al        ; 마스터 PIC에 전송
    
    ; 5. 레지스터 복원 (팝 순서는 푸시의 역순)
    pop gs
    pop fs  
    pop es
    pop ds
    popa               ; 모든 범용 레지스터 복원
    popf               ; 플래그 레지스터 복원
    
    ; 6. 인터럽트 복귀
    iret               ; 원래 프로그램으로 복귀
```

**최적화된 ISR**
```assembly
; 빠른 키보드 인터럽트 핸들러 (최소한의 레지스터만 사용)
keyboard_isr:
    push eax           ; 사용할 레지스터만 저장
    push edx
    
    in al, 0x60        ; 키보드에서 스캔 코드 읽기
    mov [key_buffer], al ; 버퍼에 저장
    inc byte [key_count] ; 카운터 증가
    
    mov al, 0x20       ; EOI 전송
    out 0x20, al
    
    pop edx            ; 레지스터 복원
    pop eax
    iret               ; 복귀
```

#### C 언어 ISR

**컴파일러 지원 ISR**
```c
// GCC __attribute__ 사용
void __attribute__((interrupt)) timer_handler(void) {
    // 컴파일러가 자동으로 레지스터 저장/복원
    
    // 실제 타이머 처리
    system_tick_count++;
    
    if (current_process->time_slice <= 0) {
        schedule_next_process();
    }
    
    // EOI는 수동으로 전송
    outb(0x20, 0x20);
}

// Microsoft Visual C++ __interrupt 키워드
void __interrupt timer_isr(void) {
    timer_tick_count++;
    outportb(0x20, 0x20);  // EOI 전송
}
```

**인라인 어셈블리 활용**
```c
void keyboard_handler(void) {
    unsigned char scan_code;
    
    // 키보드에서 스캔 코드 읽기
    __asm__ volatile ("inb $0x60, %0" : "=a" (scan_code));
    
    // 스캔 코드 처리
    process_key_input(scan_code);
    
    // EOI 전송
    __asm__ volatile ("movb $0x20, %al; outb %al, $0x20");
}
```

### ISR 설계 패턴

#### 상반부/하반부 (Top Half/Bottom Half)

**상반부 (Top Half) - 긴급한 작업**
```c
// 네트워크 인터럽트 상반부
void __attribute__((interrupt)) network_top_half(void) {
    // 1. 긴급한 하드웨어 처리
    uint32_t status = read_network_status();
    
    // 2. 패킷 데이터를 임시 버퍼로 빠르게 복사
    if (status & RX_PACKET_READY) {
        copy_packet_to_buffer();
        schedule_bottom_half();  // 하반부 스케줄링
    }
    
    // 3. 하드웨어 인터럽트 클리어
    clear_network_interrupt();
    send_eoi();
}
```

**하반부 (Bottom Half) - 시간이 걸리는 작업**
```c
// 네트워크 인터럽트 하반부 (지연된 작업)
void network_bottom_half(void) {
    // 인터럽트 컨텍스트가 아님 - 시간 제약이 적음
    
    while (has_pending_packets()) {
        packet_t *packet = get_packet_from_buffer();
        
        // 복잡한 패킷 처리
        if (validate_packet_checksum(packet)) {
            route_packet_to_protocol_stack(packet);
            update_network_statistics(packet);
            log_packet_info(packet);
        }
        
        free_packet_buffer(packet);
    }
}
```

#### 인터럽트 통합 (Interrupt Coalescing)

**다중 이벤트 처리**
```c
#define MAX_EVENTS_PER_ISR 32

void __attribute__((interrupt)) disk_controller_isr(void) {
    int event_count = 0;
    uint32_t events[MAX_EVENTS_PER_ISR];
    
    // 한 번의 인터럽트로 여러 이벤트 처리
    while (event_count < MAX_EVENTS_PER_ISR && 
           (events[event_count] = read_disk_event()) != 0) {
        event_count++;
    }
    
    // 일괄 처리로 오버헤드 감소
    process_disk_events(events, event_count);
    send_eoi();
}
```

### ISR 디버깅과 문제 해결

#### 일반적인 ISR 버그들

**1. 레지스터 저장/복원 불일치**
```assembly
; 잘못된 예시
bad_isr:
    push eax
    push ebx
    push ecx
    
    ; ... 처리 코드 ...
    
    pop eax     ; 잘못됨! ecx를 먼저 팝해야 함
    pop ebx
    pop ecx
    iret
```

**2. EOI 신호 누락**
```c
// 잘못된 예시
void timer_isr(void) {
    handle_timer();
    // EOI 전송 누락! → 인터럽트가 다시 발생하지 않음
}

// 올바른 예시  
void timer_isr(void) {
    handle_timer();
    outb(0x20, 0x20);  // EOI 전송 필수
}
```

**3. 재진입 문제**
```c
// 위험한 코드
int shared_counter = 0;

void timer_isr(void) {
    shared_counter++;  // 다른 인터럽트가 중간에 끼어들 수 있음
    send_eoi();
}

// 안전한 코드
void timer_isr(void) {
    disable_interrupts();
    shared_counter++;
    enable_interrupts();
    send_eoi();
}
```

#### ISR 성능 측정

**실행 시간 측정**
```c
// 타이머를 이용한 ISR 성능 측정
void performance_measured_isr(void) {
    uint64_t start_time, end_time;
    
    start_time = read_timestamp_counter();
    
    // 실제 ISR 코드
    actual_interrupt_handler();
    
    end_time = read_timestamp_counter();
    
    // 통계 업데이트 (디버그 빌드에서만)
    #ifdef DEBUG
    update_isr_timing_stats(end_time - start_time);
    #endif
    
    send_eoi();
}
```

---

## ⚖️ 인터럽트 vs 예외 vs 트랩

### 각 개념의 정의와 특징

#### 인터럽트 (Interrupt)

**외부 비동기 이벤트**
```
특징:
- 비동기적 (Asynchronous): 현재 실행 중인 명령어와 무관
- 외부 발생: CPU 외부 하드웨어에서 발생
- 반복 가능: 같은 인터럽트가 여러 번 발생 가능
- 투명성: 원래 프로그램이 인터럽트를 모름

발생 원인:
- 하드웨어 장치 (키보드, 마우스, 네트워크)
- 타이머
- 전원 관리
- I/O 완료 신호
```

#### 예외 (Exception)

**내부 동기 이벤트**
```
특징:
- 동기적 (Synchronous): 현재 실행 중인 명령어와 직접 관련
- 내부 발생: CPU 내부에서 발생
- 결정적: 같은 조건에서 항상 같은 예외 발생
- 복구 가능/불가능으로 분류

발생 원인:
- 잘못된 명령어 (Invalid Opcode)
- 메모리 접근 오류 (Segmentation Fault)
- 산술 오류 (Division by Zero)
- 권한 위반 (Privilege Violation)
```

#### 트랩 (Trap)

**의도적 소프트웨어 인터럽트**
```
특징:
- 의도적: 프로그래머가 의도적으로 발생시킴
- 시스템 서비스: 운영체제 기능 호출
- 예측 가능: 특정 명령어 실행 시 발생
- 동기적: 트랩 명령어와 동기화됨

발생 원인:
- 시스템 콜 (System Call)
- 소프트웨어 인터럽트 명령어 (INT, SYSCALL)
- 디버깅 지원 (Breakpoint)
```

### 상세 비교 분석

#### 처리 방식의 차이

**인터럽트 처리**
```
흐름:
1. 외부 신호 발생
2. 현재 명령어 완료 대기
3. 인터럽트 플래그 확인
4. 우선순위 검사
5. 컨텍스트 저장 후 처리
6. 원래 위치로 정확히 복귀

복귀 지점:
- 인터럽트 발생 시점의 다음 명령어
- 원래 프로그램 흐름 유지
```

**예외 처리**
```
흐름:
1. 문제가 있는 명령어 실행 시도
2. 즉시 예외 발생
3. 컨텍스트 저장
4. 예외 핸들러 호출
5. 복구 시도 또는 프로그램 종료

복귀 지점:
- Fault: 문제가 된 명령어 재실행
- Trap: 다음 명령어부터 실행
- Abort: 복귀 불가능 (프로그램 종료)
```

**트랩 처리**
```
흐름:
1. 트랩 명령어 실행 (INT, SYSCALL)
2. 즉시 트랩 발생
3. 권한 레벨 변경 (User → Kernel)
4. 시스템 서비스 실행
5. 결과 반환 후 복귀

복귀 지점:
- 트랩 명령어의 다음 명령어
- 시스템 콜 결과 전달
```

#### 벡터 번호와 처리기

**x86 아키텍처 분류**
```
벡터 범위    타입        설명                    예시
0-31        예외        CPU 내부 예외           Division Error, Page Fault
32-47       IRQ         마스터 PIC 인터럽트     Timer, Keyboard
48-63       IRQ         슬레이브 PIC 인터럽트   Mouse, IDE
64-255      사용자      소프트웨어 인터럽트     System Call, Custom ISR
```

### 구체적인 예시 분석

#### 예외 처리 상세 예시

**페이지 폴트 (Page Fault) 예외**
```c
// 페이지 폴트 핸들러
void page_fault_handler(void) {
    // CR2 레지스터에서 문제가 된 주소 읽기
    uint32_t fault_address = read_cr2();
    
    // 오류 코드 분석
    uint32_t error_code = get_error_code();
    bool present = !(error_code & 0x1);     // 페이지 부재
    bool write = error_code & 0x2;          // 쓰기 시도
    bool user = error_code & 0x4;           // 유저 모드
    
    if (present) {
        // 페이지가 없음 - 디맨드 페이징
        if (allocate_page(fault_address)) {
            return;  // 복구 성공 - 명령어 재실행
        }
    }
    
    if (write && is_copy_on_write_page(fault_address)) {
        // Copy-on-Write 처리
        copy_page(fault_address);
        return;  // 복구 성공
    }
    
    // 복구 불가능 - 프로세스 종료
    terminate_process_with_segfault();
}
```

**시스템 콜 트랩 예시**
```assembly
; Linux x86-64 시스템 콜
; write(fd, buf, count) 호출

user_program:
    mov rax, 1          ; sys_write 시스템 콜 번호
    mov rdi, 1          ; fd = stdout
    mov rsi, message    ; buf = 메시지 주소  
    mov rdx, msg_len    ; count = 메시지 길이
    syscall             ; 트랩 발생 - 커널 모드로 전환
    ; 여기서 복귀 - 시스템 콜 결과가 rax에
```

#### 복합적 상황 처리

**인터럽트 중 예외 발생**
```
시나리오:
1. 타이머 인터럽트 처리 중
2. ISR에서 잘못된 포인터 역참조
3. 페이지 폴트 예외 발생

처리 과정:
1. 타이머 ISR 컨텍스트 저장
2. 페이지 폴트 핸들러 실행
3. 페이지 폴트 복구 또는 커널 패닉
4. 타이머 ISR로 복귀 (복구된 경우)
```

**예외 중 인터럽트 발생**
```
시나리오:
1. 페이지 폴트 처리 중 (디스크에서 페이지 로드)
2. 키보드 인터럽트 발생

처리 방식:
- 마스커블 인터럽트: 예외 처리 완료 후 처리
- 논마스커블 인터럽트: 즉시 선점하여 처리
```

### 성능과 오버헤드 비교

```
처리 시간 (상대적):
트랩 (시스템 콜): 50-200 사이클
예외 (페이지 폴트): 1,000-10,000 사이클  
인터럽트 (하드웨어): 100-1,000 사이클

오버헤드 요인:
1. 컨텍스트 스위칭 비용
2. 캐시 미스 증가
3. 파이프라인 플러시
4. TLB 미스 (주소 변환)
```

---

## 🔧 하드웨어별 인터럽트 구현

### x86/x64 아키텍처

#### Intel 8259A PIC (Programmable Interrupt Controller)

**PIC 구조와 동작**
```
마스터 PIC (IRQ 0-7):
포트 주소: 0x20 (명령), 0x21 (데이터)
- IRQ 0: 시스템 타이머
- IRQ 1: 키보드
- IRQ 2: 슬레이브 PIC 연결
- IRQ 3-7: 기타 장치

슬레이브 PIC (IRQ 8-15):  
포트 주소: 0xA0 (명령), 0xA1 (데이터)
- IRQ 8: 실시간 시계
- IRQ 9-15: 확장 장치
```

**PIC 프로그래밍**
```c
// PIC 초기화 (ICW1-ICW4)
void init_pic(void) {
    // ICW1: 초기화 시작
    outb(0x20, 0x11);  // 마스터 PIC
    outb(0xA0, 0x11);  // 슬레이브 PIC
    
    // ICW2: 벡터 오프셋 설정
    outb(0x21, 0x20);  // 마스터: IRQ 0-7 → 벡터 32-39
    outb(0xA1, 0x28);  // 슬레이브: IRQ 8-15 → 벡터 40-47
    
    // ICW3: PIC 연결 설정
    outb(0x21, 0x04);  // 마스터: IRQ 2에 슬레이브 연결
    outb(0xA1, 0x02);  // 슬레이브: 마스터의 IRQ 2에 연결
    
    // ICW4: 동작 모드 설정
    outb(0x21, 0x01);  // 8086 모드
    outb(0xA1, 0x01);
    
    // 모든 인터럽트 마스킹 해제
    outb(0x21, 0x00);
    outb(0xA1, 0x00);
}

// 특정 IRQ 마스킹/언마스킹
void mask_irq(int irq) {
    uint16_t port = (irq < 8) ? 0x21 : 0xA1;
    uint8_t value = inb(port) | (1 << (irq % 8));
    outb(port, value);
}

void unmask_irq(int irq) {
    uint16_t port = (irq < 8) ? 0x21 : 0xA1;
    uint8_t value = inb(port) & ~(1 << (irq % 8));
    outb(port, value);
}
```

#### APIC (Advanced Programmable Interrupt Controller)

**로컬 APIC 구조**
```
APIC 기준 주소: 0xFEE00000 (기본값)

주요 레지스터:
0x020: 로컬 APIC ID
0x080: 태스크 우선순위 (TPR)
0x0B0: EOI 레지스터
0x0F0: Spurious 인터럽트 벡터
0x300: ICR (Interrupt Command Register) Low
0x310: ICR High
0x320: LVT Timer
0x330: LVT Thermal Sensor
0x340: LVT Performance Counter
0x350: LVT LINT0
0x360: LVT LINT1
0x370: LVT Error
```

**APIC 프로그래밍**
```c
#define APIC_BASE 0xFEE00000

// APIC 레지스터 읽기/쓰기
uint32_t apic_read(uint32_t reg) {
    return *(volatile uint32_t*)(APIC_BASE + reg);
}

void apic_write(uint32_t reg, uint32_t value) {
    *(volatile uint32_t*)(APIC_BASE + reg) = value;
}

// APIC 초기화
void init_local_apic(void) {
    // Spurious 인터럽트 벡터 설정 및 APIC 활성화
    apic_write(0x0F0, 0x100 | 0xFF);  // 벡터 255, APIC 활성화
    
    // 모든 LVT 엔트리 마스킹
    apic_write(0x320, 0x10000);  // Timer
    apic_write(0x330, 0x10000);  // Thermal
    apic_write(0x340, 0x10000);  // Performance
    apic_write(0x350, 0x10000);  // LINT0
    apic_write(0x360, 0x10000);  // LINT1
    apic_write(0x370, 0x10000);  // Error
    
    // TPR을 0으로 설정 (모든 인터럽트 허용)
    apic_write(0x080, 0);
}

// EOI 전송
void apic_send_eoi(void) {
    apic_write(0x0B0, 0);
}
```

**IPI (Inter-Processor Interrupt) 전송**
```c
// 다른 CPU에 인터럽트 전송
void send_ipi(uint8_t dest_cpu, uint8_t vector) {
    // ICR High: 목적지 CPU ID
    apic_write(0x310, (uint32_t)dest_cpu << 24);
    
    // ICR Low: 벡터 번호와 전송 모드
    apic_write(0x300, vector | 0x4000);  // Fixed delivery mode
    
    // 전송 완료 대기
    while (apic_read(0x300) & 0x1000);  // Delivery Status 확인
}
```

### ARM 아키텍처

#### ARM GIC (Generic Interrupt Controller)

**GIC 구조**
```
GIC-400 (ARMv7):
- Distributor: 인터럽트 분배 및 우선순위 관리
- CPU Interface: 각 CPU 코어별 인터럽트 인터페이스
- Virtual Interface: 가상화 지원

인터럽트 타입:
- SGI (Software Generated Interrupt): 0-15
- PPI (Private Peripheral Interrupt): 16-31  
- SPI (Shared Peripheral Interrupt): 32-1019
```

**GIC 프로그래밍**
```c
// GIC 레지스터 기준 주소
#define GICD_BASE 0x01C81000  // Distributor
#define GICC_BASE 0x01C82000  // CPU Interface

// 인터럽트 활성화
void gic_enable_interrupt(int irq) {
    int reg = irq / 32;
    int bit = irq % 32;
    
    // Distributor에서 인터럽트 활성화
    volatile uint32_t *enable_reg = 
        (volatile uint32_t*)(GICD_BASE + 0x100 + reg * 4);
    *enable_reg |= (1 << bit);
}

// 인터럽트 우선순위 설정
void gic_set_priority(int irq, uint8_t priority) {
    volatile uint8_t *priority_reg = 
        (volatile uint8_t*)(GICD_BASE + 0x400 + irq);
    *priority_reg = priority;
}

// 인터럽트 수신 (CPU Interface)
uint32_t gic_read_interrupt(void) {
    volatile uint32_t *iar = (volatile uint32_t*)(GICC_BASE + 0x0C);
    return *iar & 0x3FF;  // 인터럽트 ID 추출
}

// EOI 전송
void gic_send_eoi(uint32_t irq) {
    volatile uint32_t *eoir = (volatile uint32_t*)(GICC_BASE + 0x10);
    *eoir = irq;
}
```

#### ARM 인터럽트 벡터 테이블

**벡터 테이블 설정**
```assembly
.section .vectors
.global _vector_table

_vector_table:
    b reset_handler         @ 0x00: Reset
    b undefined_handler     @ 0x04: Undefined Instruction
    b swi_handler          @ 0x08: Software Interrupt
    b prefetch_handler     @ 0x0C: Prefetch Abort
    b data_handler         @ 0x10: Data Abort
    b reserved_handler     @ 0x14: Reserved
    b irq_handler          @ 0x18: IRQ
    b fiq_handler          @ 0x1C: FIQ

@ IRQ 핸들러 구현
irq_handler:
    stmfd sp!, {r0-r12, lr}    @ 레지스터 저장
    
    bl gic_read_interrupt      @ 인터럽트 ID 읽기
    mov r4, r0                 @ ID 보존
    
    bl handle_irq              @ C 핸들러 호출
    
    mov r0, r4                 @ ID 복원
    bl gic_send_eoi            @ EOI 전송
    
    ldmfd sp!, {r0-r12, lr}    @ 레지스터 복원
    subs pc, lr, #4            @ 복귀
```

### RISC-V 아키텍처

#### RISC-V 인터럽트/예외 처리

**CSR (Control and Status Registers)**
```
mstatus: 머신 모드 상태
mie: 머신 인터럽트 활성화
mip: 머신 인터럽트 대기
mtvec: 머신 트랩 벡터 베이스
mepc: 머신 예외 프로그램 카운터
mcause: 머신 원인 레지스터
mtval: 머신 트랩 값
```

**RISC-V 인터럽트 처리**
```c
// 트랩 핸들러
void machine_trap_handler(void) {
    uint64_t mcause_val = read_csr(mcause);
    uint64_t mepc_val = read_csr(mepc);
    uint64_t mtval_val = read_csr(mtval);
    
    if (mcause_val & (1UL << 63)) {
        // 인터럽트
        switch (mcause_val & 0x7FFFFFFFFFFFFFFF) {
            case 7:  // 머신 타이머 인터럽트
                handle_timer_interrupt();
                break;
            case 11: // 머신 외부 인터럽트
                handle_external_interrupt();
                break;
        }
    } else {
        // 예외
        switch (mcause_val) {
            case 8:  // 환경 호출 (ECALL)
                handle_system_call();
                write_csr(mepc, mepc_val + 4);  // 다음 명령어로
                break;
            case 12: // 명령어 페이지 폴트
                handle_instruction_page_fault(mtval_val);
                break;
            case 13: // 로드 페이지 폴트
                handle_load_page_fault(mtval_val);
                break;
        }
    }
}
```

### 성능 최적화 비교

#### 아키텍처별 인터럽트 지연시간

```
처리 지연시간 (마이크로초):
x86 PIC:     10-50μs
x86 APIC:    2-10μs
ARM GIC:     1-5μs
RISC-V:      0.5-3μs

최적화 요소:
1. 하드웨어 복잡도
2. 벡터 테이블 구조
3. 컨텍스트 저장 방식
4. 캐시 친화성
```

---

## ⚡ 인터럽트와 시스템 성능

### 인터럽트 오버헤드 분석

#### 직접적 오버헤드

**컨텍스트 스위칭 비용**
```
하드웨어 자동 저장:
- 플래그 레지스터: 1 클록
- 코드 세그먼트: 1 클록  
- 명령어 포인터: 1 클록
총 3클록 (약 1-3 나노초 @ 1-3GHz)

소프트웨어 저장 (ISR):
- 범용 레지스터 8개: 8 클록
- 세그먼트 레지스터 4개: 4 클록
- 추가 상태 정보: 2-5 클록
총 14-17클록 (약 5-15 나노초)

벡터 테이블 참조:
- 메모리 접근: 100-300 클록 (캐시 미스 시)
- L1 캐시 적중: 1-2 클록
평균 5-10 클록
```

**실제 ISR 실행 시간**
```
간단한 ISR (키보드):
- 스캔 코드 읽기: 1-2 클록
- 버퍼 저장: 1-2 클록  
- EOI 전송: 1 클록
총 3-5 클록

복잡한 ISR (네트워크):
- 상태 확인: 5-10 클록
- 패킷 읽기: 50-200 클록
- 큐 조작: 20-50 클록
- 프로토콜 처리: 100-1000 클록
총 175-1260 클록
```

#### 간접적 오버헤드

**캐시 오염 (Cache Pollution)**
```
문제:
- ISR이 캐시 라인을 점유
- 원래 프로그램의 데이터가 캐시에서 축출됨
- 인터럽트 복귀 후 캐시 미스 증가

측정 예시:
인터럽트 없는 경우: 95% L1 캐시 적중률
인터럽트 있는 경우: 85% L1 캐시 적중률
성능 저하: 약 10-15%
```

**파이프라인 플러시**
```
현대 CPU의 파이프라인:
- 인텔 Core i7: 14-19 단계
- AMD Ryzen: 20단계
- ARM Cortex-A77: 13단계

인터럽트 발생 시:
- 전체 파이프라인 플러시
- 분기 예측 테이블 혼란
- 수십 클록의 성능 손실
```

### 인터럽트 최적화 기법

#### 1. 인터럽트 통합 (Interrupt Coalescing)

**개념과 구현**
```c
// 인터럽트 통합을 위한 구조체
struct interrupt_coalescing {
    uint32_t threshold;     // 임계 이벤트 수
    uint32_t timeout;       // 최대 대기 시간 (마이크로초)
    uint32_t pending_count; // 대기 중인 이벤트 수
    uint64_t last_interrupt; // 마지막 인터럽트 시간
};

// 네트워크 카드 인터럽트 통합
void network_interrupt_handler(void) {
    static struct interrupt_coalescing coalescing = {
        .threshold = 32,    // 32개 패킷마다 인터럽트
        .timeout = 50       // 50μs 최대 대기
    };
    
    uint32_t packets_processed = 0;
    uint64_t start_time = get_timestamp();
    
    // 여러 패킷을 한 번에 처리
    while (has_pending_packet() && 
           packets_processed < coalescing.threshold) {
        process_packet();
        packets_processed++;
    }
    
    // 통계 업데이트
    update_coalescing_stats(&coalescing, packets_processed);
    send_eoi();
}
```

#### 2. 인터럽트 친화성 (Interrupt Affinity)

**CPU 바인딩 최적화**
```bash
# Linux에서 인터럽트 친화성 설정
# 네트워크 인터럽트를 CPU 2, 3에만 할당
echo 0x0C > /proc/irq/24/smp_affinity

# 스토리지 인터럽트를 CPU 0, 1에만 할당  
echo 0x03 > /proc/irq/25/smp_affinity

# 성능 향상 효과:
# - 캐시 지역성 개선
# - NUMA 지역성 활용
# - CPU 로드 밸런싱
```

**동적 친화성 조정**
```c
// 동적 인터럽트 친화성 조정
void balance_interrupt_load(void) {
    for (int irq = 32; irq < 256; irq++) {
        uint64_t irq_count = get_irq_count(irq);
        int current_cpu = get_irq_affinity(irq);
        int cpu_load = get_cpu_load(current_cpu);
        
        // 로드가 높으면 다른 CPU로 이동
        if (cpu_load > LOAD_THRESHOLD) {
            int best_cpu = find_least_loaded_cpu();
            set_irq_affinity(irq, best_cpu);
        }
    }
}
```

#### 3. NAPI (New API) - Linux 네트워크 최적화

**폴링과 인터럽트 혼합**
```c
// NAPI 방식 네트워크 드라이버
int napi_poll(struct napi_struct *napi, int budget) {
    int work_done = 0;
    
    // 인터럽트 비활성화 상태에서 폴링
    while (work_done < budget && has_packets()) {
        process_one_packet();
        work_done++;
    }
    
    if (work_done < budget) {
        // 모든 패킷 처리 완료 - 인터럽트 모드로 복귀
        napi_complete(napi);
        enable_network_interrupts();
    }
    
    return work_done;
}

// 인터럽트 핸들러 (NAPI 스케줄링)
void network_interrupt_handler(void) {
    if (napi_schedule_prep(&adapter->napi)) {
        // 인터럽트 비활성화 후 폴링 스케줄
        disable_network_interrupts();
        __napi_schedule(&adapter->napi);
    }
}
```

### 성능 측정과 모니터링

#### 인터럽트 통계 수집

**시스템 레벨 모니터링**
```bash
# Linux 인터럽트 통계 확인
cat /proc/interrupts
watch -n 1 'cat /proc/interrupts'

# 특정 CPU의 인터럽트 부하 확인
mpstat -P ALL 1

# 인터럽트별 상세 정보
cat /proc/stat | grep intr
```

**프로그래밍을 통한 측정**
```c
// 인터럽트 성능 카운터
struct interrupt_stats {
    uint64_t total_interrupts;
    uint64_t total_latency;      // 누적 지연시간 (나노초)
    uint64_t max_latency;        // 최대 지연시간
    uint64_t min_latency;        // 최소 지연시간
    uint64_t cache_misses;       // 캐시 미스 수
};

// ISR에서 성능 측정
void __attribute__((interrupt)) measured_isr(void) {
    uint64_t start_time = rdtsc();  // 시작 시간 기록
    
    // 실제 인터럽트 처리
    handle_interrupt();
    
    uint64_t end_time = rdtsc();    // 종료 시간 기록
    uint64_t latency = end_time - start_time;
    
    // 통계 업데이트
    update_interrupt_stats(latency);
    
    send_eoi();
}
```

### 실시간 시스템에서의 인터럽트

#### 인터럽트 지연시간 보장

**하드 실시간 요구사항**
```
항공기 제어: 10μs 이내
의료 장비: 100μs 이내  
산업 자동화: 1ms 이내
멀티미디어: 10ms 이내
```

**RT-Linux의 인터럽트 처리**
```c
// 실시간 우선순위 인터럽트 스레드
int realtime_irq_thread(void *data) {
    struct irq_desc *desc = (struct irq_desc *)data;
    
    // 실시간 스케줄링 정책 설정
    struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
    sched_setscheduler(current, SCHED_FIFO, &param);
    
    while (!kthread_should_stop()) {
        // 인터럽트 대기
        wait_for_interrupt(desc);
        
        // 지연시간 측정 시작
        uint64_t start = ktime_get_ns();
        
        // 실제 인터럽트 처리
        handle_realtime_interrupt(desc);
        
        uint64_t latency = ktime_get_ns() - start;
        
        // 실시간 제약 위반 검사
        if (latency > desc->max_allowed_latency) {
            report_latency_violation(desc, latency);
        }
    }
    
    return 0;
}
```

---

## 🚀 현대 시스템의 인터럽트

### 가상화와 인터럽트

#### 하이퍼바이저의 인터럽트 가상화

**Intel VT-x의 가상 인터럽트**
```
기능:
- Virtual APIC: 게스트 OS용 가상 APIC
- Posted Interrupts: 하이퍼바이저 개입 없는 인터럽트 전달
- VMCS: VM 제어 구조체에 인터럽트 설정 저장

동작 과정:
1. 물리적 인터럽트 발생
2. 하이퍼바이저가 인터럽트 수신
3. 해당하는 게스트 VM 확인
4. 가상 인터럽트로 변환하여 게스트에 전달
5. 게스트 OS가 일반 인터럽트처럼 처리
```

**KVM의 인터럽트 처리**
```c
// KVM 가상 인터럽트 주입
int kvm_inject_interrupt(struct kvm_vcpu *vcpu, int vector) {
    struct kvm_interrupt irq;
    irq.irq = vector;
    
    // 게스트가 인터럽트를 받을 수 있는 상태인지 확인
    if (!kvm_arch_interrupt_allowed(vcpu)) {
        return -EBUSY;
    }
    
    // VMCS에 인터럽트 정보 설정
    vmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 
                 INTR_INFO_VALID_MASK | 
                 INTR_TYPE_EXT_INTR | 
                 vector);
    
    return 0;
}
```

#### 컨테이너와 인터럽트 격리

**네임스페이스 기반 인터럽트 관리**
```c
// 컨테이너별 인터럽트 통계 분리
struct container_irq_stats {
    struct task_struct *container_init;
    uint64_t irq_count[NR_IRQS];
    uint64_t irq_time[NR_IRQS];
    struct cgroup *cgroup;
};

// 컨테이너별 인터럽트 어카운팅
void account_irq_to_container(int irq, uint64_t processing_time) {
    struct task_struct *current_task = current;
    struct container_irq_stats *stats;
    
    // 현재 태스크가 속한 컨테이너 찾기
    stats = find_container_irq_stats(current_task);
    if (stats) {
        stats->irq_count[irq]++;
        stats->irq_time[irq] += processing_time;
    }
}
```

### MSI/MSI-X (Message Signaled Interrupts)

#### 기존 IRQ 라인의 한계

**전통적 IRQ 방식의 문제**
```
한계점:
- 제한된 IRQ 라인 수 (x86: 16개)
- 공유로 인한 성능 저하
- 엣지/레벨 감지 복잡성
- 멀티코어 확장성 부족

PCI 슬롯별 IRQ 할당 예시:
PCI Slot 1: IRQ 10 (네트워크 카드)
PCI Slot 2: IRQ 11 (사운드 카드)  
PCI Slot 3: IRQ 10 (USB 컨트롤러) ← 공유!
PCI Slot 4: IRQ 11 (스토리지) ← 공유!
```

#### MSI의 장점과 구현

**MSI 메커니즘**
```
특징:
- 메모리 쓰기 기반 인터럽트
- 각 디바이스가 고유 벡터 사용 가능
- 더 나은 성능과 확장성
- 원자적 인터럽트 전달

MSI 메시지 구조 (x86):
Address: 0xFEE00000 | (dest_cpu << 12)
Data: vector | (trigger_mode << 15) | (level << 14)
```

**MSI 설정 코드**
```c
// PCI 디바이스의 MSI 활성화
int enable_msi(struct pci_dev *dev) {
    struct msi_desc *entry;
    int vector;
    
    // MSI 능력 구조체 찾기
    int pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
    if (!pos) {
        return -ENODEV;
    }
    
    // 벡터 할당
    vector = alloc_msi_vector();
    if (vector < 0) {
        return vector;
    }
    
    // MSI 주소/데이터 설정
    uint32_t address = 0xFEE00000;  // 고정 주소
    uint32_t data = vector;         // 벡터 번호
    
    pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_LO, address);
    pci_write_config_dword(dev, pos + PCI_MSI_DATA, data);
    
    // MSI 활성화
    uint16_t control;
    pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &control);
    control |= PCI_MSI_FLAGS_ENABLE;
    pci_write_config_word(dev, pos + PCI_MSI_FLAGS, control);
    
    return vector;
}
```

**MSI-X의 확장 기능**
```c
// MSI-X 테이블 구조체
struct msix_entry {
    uint32_t msg_addr_lo;   // 메시지 주소 하위 32비트
    uint32_t msg_addr_hi;   // 메시지 주소 상위 32비트
    uint32_t msg_data;      // 메시지 데이터
    uint32_t vector_ctrl;   // 벡터 제어 (마스킹)
};

// 다중 MSI-X 벡터 설정
int setup_msix_vectors(struct pci_dev *dev, int num_vectors) {
    struct msix_entry *entries;
    int i;
    
    entries = kcalloc(num_vectors, sizeof(struct msix_entry), GFP_KERNEL);
    if (!entries) {
        return -ENOMEM;
    }
    
    // 각 벡터별 설정
    for (i = 0; i < num_vectors; i++) {
        entries[i].entry = i;  // 엔트리 번호
        entries[i].vector = alloc_msi_vector();
    }
    
    // MSI-X 활성화
    int ret = pci_enable_msix(dev, entries, num_vectors);
    if (ret) {
        kfree(entries);
        return ret;
    }
    
    return 0;
}
```

### 인터럽트 가상화 최적화

#### SR-IOV (Single Root I/O Virtualization)

**하드웨어 기반 I/O 가상화**
```
구성 요소:
- PF (Physical Function): 물리 디바이스
- VF (Virtual Function): 가상 디바이스 (게스트 전용)
- 직접 할당: 하이퍼바이저 우회

장점:
- 네이티브 수준 성능
- 인터럽트 직접 전달
- CPU 오버헤드 최소화
```

**SR-IOV 인터럽트 처리**
```c
// SR-IOV VF의 직접 인터럽트 처리
void sriov_vf_interrupt_handler(void) {
    // 게스트 OS가 직접 인터럽트 처리
    // 하이퍼바이저 개입 없음
    
    struct vf_device *vf = get_current_vf();
    
    // VF별 독립적 처리
    process_vf_packets(vf);
    
    // 게스트의 EOI가 직접 하드웨어에 전달됨
    vf_send_eoi(vf);
}
```

### IoT와 엣지 컴퓨팅의 인터럽트

#### 저전력 인터럽트 관리

**ARM Cortex-M의 WFI (Wait For Interrupt)**
```c
// 저전력 인터럽트 대기
void low_power_interrupt_wait(void) {
    // 모든 non-critical 클록 중단
    disable_peripheral_clocks();
    
    // 인터럽트 대기 상태로 진입
    __asm__ volatile ("wfi");  // Wait For Interrupt
    
    // 인터럽트 발생 시 자동으로 깨어남
    enable_peripheral_clocks();
}

// 슬립 모드 인터럽트 설정
void setup_wakeup_interrupts(void) {
    // GPIO 인터럽트 (버튼, 센서)
    setup_gpio_interrupt(BUTTON_PIN, GPIO_RISING_EDGE);
    
    // RTC 인터럽트 (주기적 깨어남)
    setup_rtc_alarm(WAKEUP_INTERVAL_SEC);
    
    // UART 인터럽트 (외부 통신)
    setup_uart_wakeup();
}
```

#### 실시간 IoT 인터럽트

**센서 데이터 처리**
```c
// 고속 ADC 인터럽트 처리
void __attribute__((interrupt)) adc_dma_complete_isr(void) {
    static uint16_t sensor_buffer[1024];
    static int buffer_index = 0;
    
    // DMA로 전송된 ADC 데이터 처리
    uint16_t adc_value = get_adc_result();
    sensor_buffer[buffer_index++] = adc_value;
    
    // 버퍼가 가득 찬 경우
    if (buffer_index >= 1024) {
        // 신호 처리 태스크에 알림
        xTaskNotifyFromISR(signal_processing_task, 
                          BUFFER_READY_NOTIFICATION, 
                          eSetBits, 
                          &higher_priority_task_woken);
        buffer_index = 0;
    }
    
    // 다음 ADC 변환 시작
    start_next_adc_conversion();
    
    portYIELD_FROM_ISR(higher_priority_task_woken);
}
```

---

## 💻 실제 예시와 프로그래밍

### 운영체제별 인터럽트 프로그래밍

#### Linux 커널 인터럽트 처리

**인터럽트 핸들러 등록**
```c
#include <linux/interrupt.h>
#include <linux/module.h>

// 인터럽트 서비스 루틴
static irqreturn_t my_interrupt_handler(int irq, void *dev_id) {
    // 인터럽트 처리 코드
    printk(KERN_INFO "Interrupt %d received\n", irq);
    
    // 하드웨어 레지스터에서 상태 읽기
    uint32_t status = ioread32(device_base + STATUS_REG);
    
    if (status & TX_COMPLETE) {
        handle_tx_complete();
    }
    
    if (status & RX_READY) {
        handle_rx_ready();
    }
    
    // 인터럽트 클리어
    iowrite32(status, device_base + STATUS_REG);
    
    return IRQ_HANDLED;
}

// 드라이버 초기화에서 인터럽트 등록
static int __init my_driver_init(void) {
    int result;
    
    // IRQ 요청
    result = request_irq(MY_IRQ_NUMBER, 
                        my_interrupt_handler,
                        IRQF_SHARED,        // 공유 가능한 인터럽트
                        "my_device",        // 디바이스 이름
                        &my_device);        // dev_id
    
    if (result) {
        printk(KERN_ERR "Cannot register IRQ %d\n", MY_IRQ_NUMBER);
        return result;
    }
    
    return 0;
}

// 드라이버 정리에서 인터럽트 해제
static void __exit my_driver_exit(void) {
    free_irq(MY_IRQ_NUMBER, &my_device);
}
```

**고성능 네트워크 드라이버**
```c
// NAPI 기반 네트워크 드라이버
struct my_net_adapter {
    struct net_device *netdev;
    struct napi_struct napi;
    void __iomem *base_addr;
    struct sk_buff_head rx_queue;
    spinlock_t lock;
};

// 인터럽트 핸들러 (NAPI 스케줄링만)
static irqreturn_t net_interrupt_handler(int irq, void *data) {
    struct my_net_adapter *adapter = data;
    
    // 인터럽트 비활성화
    iowrite32(0, adapter->base_addr + INT_ENABLE_REG);
    
    // NAPI 폴링 스케줄
    if (napi_schedule_prep(&adapter->napi)) {
        __napi_schedule(&adapter->napi);
    }
    
    return IRQ_HANDLED;
}

// NAPI 폴링 함수
static int net_napi_poll(struct napi_struct *napi, int budget) {
    struct my_net_adapter *adapter = container_of(napi, struct my_net_adapter, napi);
    int work_done = 0;
    
    // 패킷 처리 (인터럽트 비활성화 상태)
    while (work_done < budget) {
        struct sk_buff *skb = receive_packet(adapter);
        if (!skb) break;
        
        netif_receive_skb(skb);
        work_done++;
    }
    
    // 모든 패킷 처리 완료 시
    if (work_done < budget) {
        napi_complete(napi);
        // 인터럽트 재활성화
        iowrite32(INT_ENABLE_MASK, adapter->base_addr + INT_ENABLE_REG);
    }
    
    return work_done;
}
```

#### Windows 커널 인터럽트 처리

**WDM 드라이버의 ISR**
```c
// Windows Driver Model ISR
BOOLEAN MyInterruptServiceRoutine(
    PKINTERRUPT Interrupt,
    PVOID ServiceContext
) {
    PMY_DEVICE_EXTENSION deviceExtension = (PMY_DEVICE_EXTENSION)ServiceContext;
    BOOLEAN interruptRecognized = FALSE;
    
    // 하드웨어 상태 확인
    ULONG status = READ_REGISTER_ULONG(&deviceExtension->Registers->Status);
    
    if (status & MY_INTERRUPT_PENDING) {
        // 인터럽트 클리어
        WRITE_REGISTER_ULONG(&deviceExtension->Registers->Status, status);
        
        // DPC 큐잉 (지연된 처리)
        KeInsertQueueDpc(&deviceExtension->InterruptDpc, NULL, NULL);
        
        interruptRecognized = TRUE;
    }
    
    return interruptRecognized;
}

// DPC (Deferred Procedure Call) 루틴
VOID MyDpcForIsr(
    PKDPC Dpc,
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
) {
    PMY_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    
    // 시간이 걸리는 처리 작업
    ProcessInterruptData(deviceExtension);
    
    // I/O 요청 완료
    if (deviceExtension->PendingIrp) {
        IoCompleteRequest(deviceExtension->PendingIrp, IO_NO_INCREMENT);
        deviceExtension->PendingIrp = NULL;
    }
}
```

#### 임베디드 시스템 (FreeRTOS)

**실시간 운영체제에서의 인터럽트**
```c
// FreeRTOS 인터럽트 핸들러
void USART1_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    // USART 상태 확인
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
        char received_char = USART_ReceiveData(USART1);
        
        // 큐에 데이터 전송 (ISR에서 안전한 함수 사용)
        xQueueSendFromISR(uart_rx_queue, &received_char, &xHigherPriorityTaskWoken);
        
        // 인터럽트 클리어
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
    
    // 더 높은 우선순위 태스크가 깨어나면 컨텍스트 스위칭
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

// 메인 태스크에서 데이터 처리
void uart_processing_task(void *parameters) {
    char received_data;
    
    while (1) {
        // 큐에서 데이터 대기 (블로킹)
        if (xQueueReceive(uart_rx_queue, &received_data, portMAX_DELAY) == pdTRUE) {
            // 수신된 데이터 처리
            process_uart_data(received_data);
        }
    }
}
```

### 사용자 공간에서의 인터럽트 처리

#### UIO (Userspace I/O) 드라이버

**커널 우회 인터럽트 처리**
```c
// UIO 드라이버 (커널 공간)
static irqreturn_t uio_interrupt_handler(int irq, struct uio_info *info) {
    // 인터럽트 비활성화 (사용자 공간에서 재활성화)
    disable_device_interrupts(info->priv);
    
    return IRQ_HANDLED;
}

// 사용자 공간 애플리케이션
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int uio_fd;
    int irq_count = 0;
    void *device_mem;
    
    // UIO 디바이스 열기
    uio_fd = open("/dev/uio0", O_RDWR);
    if (uio_fd < 0) {
        perror("Cannot open UIO device");
        return -1;
    }
    
    // 디바이스 메모리 매핑
    device_mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uio_fd, 0);
    if (device_mem == MAP_FAILED) {
        perror("Cannot mmap device memory");
        close(uio_fd);
        return -1;
    }
    
    // 인터럽트 활성화
    uint32_t enable = 1;
    write(uio_fd, &enable, sizeof(enable));
    
    while (1) {
        // 인터럽트 대기 (블로킹)
        uint32_t pending;
        ssize_t result = read(uio_fd, &pending, sizeof(pending));
        
        if (result == sizeof(pending)) {
            printf("Interrupt received, count: %d\n", ++irq_count);
            
            // 디바이스 레지스터 직접 접근
            volatile uint32_t *status_reg = (volatile uint32_t*)device_mem;
            uint32_t status = *status_reg;
            
            // 인터럽트 처리
            process_device_interrupt(status);
            
            // 인터럽트 재활성화
            write(uio_fd, &enable, sizeof(enable));
        }
    }
    
    // 정리
    munmap(device_mem, 0x1000);
    close(uio_fd);
    return 0;
}
```

#### VFIO (Virtual Function I/O)

**가상화 환경에서의 직접 인터럽트 처리**
```c
// VFIO를 이용한 디바이스 직접 접근
#include <linux/vfio.h>

int setup_vfio_interrupts(int device_fd) {
    struct vfio_irq_info irq_info = {
        .argsz = sizeof(irq_info),
        .index = VFIO_PCI_MSI_IRQ_INDEX
    };
    
    // 인터럽트 정보 조회
    if (ioctl(device_fd, VFIO_DEVICE_GET_IRQ_INFO, &irq_info) < 0) {
        perror("Cannot get IRQ info");
        return -1;
    }
    
    // 이벤트 파일 디스크립터 생성
    int eventfd = eventfd(0, EFD_CLOEXEC);
    if (eventfd < 0) {
        perror("Cannot create eventfd");
        return -1;
    }
    
    // 인터럽트와 eventfd 연결
    struct vfio_irq_set *irq_set;
    size_t irq_set_size = sizeof(*irq_set) + sizeof(int);
    irq_set = malloc(irq_set_size);
    
    irq_set->argsz = irq_set_size;
    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER;
    irq_set->index = VFIO_PCI_MSI_IRQ_INDEX;
    irq_set->start = 0;
    irq_set->count = 1;
    *(int*)irq_set->data = eventfd;
    
    if (ioctl(device_fd, VFIO_DEVICE_SET_IRQS, irq_set) < 0) {
        perror("Cannot set IRQ");
        free(irq_set);
        close(eventfd);
        return -1;
    }
    
    free(irq_set);
    return eventfd;
}

// 인터럽트 처리 루프
void interrupt_handling_loop(int eventfd, volatile void *device_mmio) {
    struct pollfd pfd = {
        .fd = eventfd,
        .events = POLLIN
    };
    
    while (1) {
        // 인터럽트 대기
        int ret = poll(&pfd, 1, -1);
        if (ret > 0 && (pfd.revents & POLLIN)) {
            uint64_t event_count;
            read(eventfd, &event_count, sizeof(event_count));
            
            // 디바이스 상태 확인
            uint32_t status = *(volatile uint32_t*)(device_mmio + STATUS_OFFSET);
            
            // 인터럽트 처리
            if (status & RX_READY) {
                handle_rx_interrupt(device_mmio);
            }
            
            if (status & TX_COMPLETE) {
                handle_tx_interrupt(device_mmio);
            }
            
            // 상태 클리어
            *(volatile uint32_t*)(device_mmio + STATUS_OFFSET) = status;
        }
    }
}
```

### 성능 벤치마킹과 최적화

#### 인터럽트 지연시간 측정

**정밀한 타이밍 측정**
```c
// 하드웨어 타이머를 이용한 지연시간 측정
struct interrupt_latency_stats {
    uint64_t min_latency;
    uint64_t max_latency;
    uint64_t total_latency;
    uint64_t sample_count;
    uint64_t histogram[100];  // 지연시간 히스토그램
};

static struct interrupt_latency_stats latency_stats;
static uint64_t interrupt_start_time;

// 외부 신호와 동기화된 타이밍 측정
void __attribute__((interrupt)) timing_test_isr(void) {
    uint64_t current_time = read_tsc();  // Time Stamp Counter
    uint64_t latency = current_time - interrupt_start_time;
    
    // 통계 업데이트
    latency_stats.sample_count++;
    latency_stats.total_latency += latency;
    
    if (latency < latency_stats.min_latency || latency_stats.sample_count == 1) {
        latency_stats.min_latency = latency;
    }
    
    if (latency > latency_stats.max_latency) {
        latency_stats.max_latency = latency;
    }
    
    // 히스토그램 업데이트 (마이크로초 단위)
    uint64_t latency_us = latency / cpu_freq_mhz;
    if (latency_us < 100) {
        latency_stats.histogram[latency_us]++;
    }
    
    // 실제 인터럽트 처리
    handle_test_interrupt();
    send_eoi();
}

// 외부 신호 생성기와 동기화
void trigger_test_interrupt(void) {
    interrupt_start_time = read_tsc();
    // 외부 하드웨어에 인터럽트 트리거 신호 전송
    trigger_external_interrupt();
}
```

**성능 프로파일링**
```c
// 인터럽트 핸들러별 성능 통계
struct isr_performance_stats {
    const char *name;
    uint64_t call_count;
    uint64_t total_cycles;
    uint64_t max_cycles;
    uint64_t cache_misses;
};

#define MAX_ISRS 256
static struct isr_performance_stats isr_stats[MAX_ISRS];

// 성능 측정 래퍼
#define MEASURE_ISR_PERFORMANCE(isr_id, handler_func) \
do { \
    uint64_t start_cycles = read_tsc(); \
    uint64_t start_cache_misses = read_cache_miss_counter(); \
    \
    handler_func(); \
    \
    uint64_t end_cycles = read_tsc(); \
    uint64_t end_cache_misses = read_cache_miss_counter(); \
    \
    uint64_t elapsed = end_cycles - start_cycles; \
    isr_stats[isr_id].call_count++; \
    isr_stats[isr_id].total_cycles += elapsed; \
    isr_stats[isr_id].cache_misses += (end_cache_misses - start_cache_misses); \
    \
    if (elapsed > isr_stats[isr_id].max_cycles) { \
        isr_stats[isr_id].max_cycles = elapsed; \
    } \
} while(0)

// 성능 통계 출력
void print_isr_performance_stats(void) {
    printf("ISR Performance Statistics:\n");
    printf("%-20s %10s %15s %15s %15s\n", 
           "Handler", "Count", "Avg Cycles", "Max Cycles", "Cache Misses");
    
    for (int i = 0; i < MAX_ISRS; i++) {
        if (isr_stats[i].call_count > 0) {
            uint64_t avg_cycles = isr_stats[i].total_cycles / isr_stats[i].call_count;
            printf("%-20s %10lu %15lu %15lu %15lu\n",
                   isr_stats[i].name,
                   isr_stats[i].call_count,
                   avg_cycles,
                   isr_stats[i].max_cycles,
                   isr_stats[i].cache_misses);
        }
    }
}
```

### 디버깅 도구와 기법

#### 인터럽트 디버깅 기법

**소프트웨어 트레이싱**
```c
// 인터럽트 트레이스 로깅
#define TRACE_BUFFER_SIZE 10000

struct interrupt_trace_entry {
    uint64_t timestamp;
    uint16_t irq_number;
    uint16_t cpu_id;
    uint32_t context;      // 인터럽트 발생 시 컨텍스트
    uint32_t duration;     // 처리 시간 (사이클)
};

static struct interrupt_trace_entry trace_buffer[TRACE_BUFFER_SIZE];
static volatile int trace_index = 0;

// 인터럽트 진입 시 트레이스
void trace_interrupt_entry(int irq) {
    int idx = __sync_fetch_and_add(&trace_index, 1) % TRACE_BUFFER_SIZE;
    
    trace_buffer[idx].timestamp = read_tsc();
    trace_buffer[idx].irq_number = irq;
    trace_buffer[idx].cpu_id = smp_processor_id();
    trace_buffer[idx].context = read_context_info();
    trace_buffer[idx].duration = 0;  // 진입 시에는 0
}

// 인터럽트 종료 시 트레이스
void trace_interrupt_exit(int irq) {
    // 최근 같은 IRQ의 엔트리 찾기
    int current_idx = (trace_index - 1) % TRACE_BUFFER_SIZE;
    
    if (trace_buffer[current_idx].irq_number == irq && 
        trace_buffer[current_idx].duration == 0) {
        trace_buffer[current_idx].duration = 
            read_tsc() - trace_buffer[current_idx].timestamp;
    }
}

// 트레이스 분석
void analyze_interrupt_traces(void) {
    printf("Recent interrupt activity:\n");
    
    for (int i = 0; i < TRACE_BUFFER_SIZE; i++) {
        int idx = (trace_index + i) % TRACE_BUFFER_SIZE;
        struct interrupt_trace_entry *entry = &trace_buffer[idx];
        
        if (entry->timestamp != 0) {
            printf("IRQ %3d CPU %d Time %12lu Duration %8u Context 0x%08x\n",
                   entry->irq_number,
                   entry->cpu_id,
                   entry->timestamp,
                   entry->duration,
                   entry->context);
        }
    }
}
```

**하드웨어 디버깅 지원**
```c
// JTAG/SWD를 통한 실시간 인터럽트 모니터링
void setup_interrupt_debug_monitoring(void) {
    // DWT (Data Watchpoint and Trace) 설정
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    
    // 사이클 카운터 활성화
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    
    // PC 샘플링 활성화 (인터럽트 위치 추적)
    ITM->TCR |= ITM_TCR_ITMENA_Msk;
    ITM->TER |= (1UL << 0);  // 채널 0 활성화
}

// 실시간 인터럽트 상태 출력 (디버거 콘솔)
void debug_print_interrupt_state(void) {
    uint32_t active_interrupts = NVIC->IABR[0];  // 활성 인터럽트
    uint32_t pending_interrupts = NVIC->ISPR[0]; // 대기 인터럽트
    
    // ITM을 통해 디버거로 전송
    ITM_SendChar('I');  // 인터럽트 상태 마커
    ITM_SendChar((active_interrupts >> 24) & 0xFF);
    ITM_SendChar((active_interrupts >> 16) & 0xFF);
    ITM_SendChar((active_interrupts >> 8) & 0xFF);
    ITM_SendChar(active_interrupts & 0xFF);
}
```

---

## 📚 스터디 팁과 총정리

### 학습 단계별 체크리스트

#### 🟢 기초 단계 (필수 이해)
```
□ 인터럽트의 기본 개념과 필요성 이해
□ 인터럽트 vs 폴링 방식의 차이점 설명 가능
□ 하드웨어 인터럽트 vs 소프트웨어 인터럽트 구분
□ 인터럽트 발생부터 처리까지의 기본 과정 4단계 암기
□ 마스커블 vs 논마스커블 인터럽트 차이점 이해
□ 기본적인 우선순위 개념 이해
```

#### 🟡 중급 단계 (심화 이해)
```
□ 인터럽트 벡터 테이블의 구조와 동작 원리 이해
□ 컨텍스트 스위칭의 상세 과정 설명 가능
□ ISR 작성 시 주의사항과 최적화 기법 숙지
□ 인터럽트 중첩과 선점에 대한 이해
□ 예외, 트랩과의 차이점 명확히 구분
□ PIC/APIC 등 인터럽트 컨트롤러 동작 원리 이해
□ 간단한 ISR 코드 작성 및 분석 가능
```

#### 🔴 고급 단계 (전문가 수준)
```
□ 아키텍처별 인터럽트 구현 차이점 이해 (x86, ARM, RISC-V)
□ MSI/MSI-X의 장점과 구현 방식 이해
□ 가상화 환경에서의 인터럽트 처리 메커니즘
□ 실시간 시스템에서의 인터럽트 제약사항과 해결책
□ 성능 최적화 기법 (NAPI, 인터럽트 통합 등) 적용 가능
□ 멀티코어 환경에서의 인터럽트 분산과 친화성 관리
□ 고성능 드라이버 개발 시 인터럽트 최적화 설계 가능
```

### 실습 프로젝트 추천

#### 🔰 초급 프로젝트

**1. 타이머 인터럽트 기반 LED 깜빡이기**
```c
// Arduino/AVR 기반 간단한 타이머 인터럽트
#include <avr/interrupt.h>

volatile int led_state = 0;

// 타이머1 오버플로우 인터럽트 (약 1초마다)
ISR(TIMER1_OVF_vect) {
    led_state = !led_state;
    digitalWrite(13, led_state);
    
    // 타이머 재설정
    TCNT1 = 34286;  // 1초 주기를 위한 초기값
}

void setup() {
    pinMode(13, OUTPUT);
    
    // 타이머1 설정
    TCCR1A = 0;
    TCCR1B = (1 << CS12) | (1 << CS10);  // 1024 분주
    TCNT1 = 34286;
    TIMSK1 = (1 << TOIE1);  // 오버플로우 인터럽트 활성화
    
    sei();  // 전역 인터럽트 활성화
}

void loop() {
    // 메인 루프는 다른 작업 수행 가능
    // 인터럽트가 LED를 자동으로 제어
}
```

**2. 외부 인터럽트를 이용한 카운터**
```c
// 버튼 누름 감지 인터럽트
volatile int button_count = 0;

ISR(INT0_vect) {
    // 디바운싱을 위한 간단한 지연
    _delay_ms(50);
    
    if (!(PIND & (1 << PD2))) {  // 버튼이 여전히 눌려있으면
        button_count++;
        Serial.println(button_count);
    }
}

void setup() {
    Serial.begin(9600);
    
    // INT0 (PD2) 설정
    DDRD &= ~(1 << PD2);   // 입력으로 설정
    PORTD |= (1 << PD2);   // 풀업 저항 활성화
    
    // 외부 인터럽트 설정 (하강 엣지)
    EICRA |= (1 << ISC01);
    EIMSK |= (1 << INT0);
    
    sei();
}
```

#### 🔄 중급 프로젝트

**3. UART 인터럽트 기반 시리얼 통신**
```c
#define BUFFER_SIZE 128

volatile char rx_buffer[BUFFER_SIZE];
volatile int rx_head = 0;
volatile int rx_tail = 0;

// UART 수신 완료 인터럽트
ISR(USART_RX_vect) {
    char received_byte = UDR0;
    
    int next_head = (rx_head + 1) % BUFFER_SIZE;
    
    // 버퍼 오버플로우 체크
    if (next_head != rx_tail) {
        rx_buffer[rx_head] = received_byte;
        rx_head = next_head;
    }
}

// 버퍼에서 문자 읽기 (논블로킹)
int uart_getchar(void) {
    if (rx_head == rx_tail) {
        return -1;  // 버퍼 비어있음
    }
    
    char c = rx_buffer[rx_tail];
    rx_tail = (rx_tail + 1) % BUFFER_SIZE;
    
    return c;
}

void setup_uart_interrupt(void) {
    // UART 설정 (9600 bps)
    UBRR0H = 0;
    UBRR0L = 103;  // 16MHz에서 9600bps
    
    UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);  // 8비트 데이터
    
    sei();
}
```

**4. ADC 인터럽트 기반 센서 데이터 수집**
```c
#define SAMPLES_PER_SECOND 1000
#define SAMPLE_BUFFER_SIZE 100

volatile uint16_t adc_samples[SAMPLE_BUFFER_SIZE];
volatile int sample_index = 0;
volatile bool buffer_ready = false;

// ADC 변환 완료 인터럽트
ISR(ADC_vect) {
    uint16_t adc_value = ADCL | (ADCH << 8);
    
    adc_samples[sample_index++] = adc_value;
    
    if (sample_index >= SAMPLE_BUFFER_SIZE) {
        sample_index = 0;
        buffer_ready = true;
    }
    
    // 다음 변환 시작
    ADCSRA |= (1 << ADSC);
}

void setup_adc_interrupt(void) {
    // ADC 기준 전압: AVCC
    ADMUX = (1 << REFS0);
    
    // ADC 활성화, 인터럽트 활성화, 128 분주
    ADCSRA = (1 << ADEN) | (1 << ADIE) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
    
    // 첫 변환 시작
    ADCSRA |= (1 << ADSC);
    
    sei();
}

void process_samples(void) {
    if (buffer_ready) {
        // 샘플 버퍼 처리
        uint32_t sum = 0;
        for (int i = 0; i < SAMPLE_BUFFER_SIZE; i++) {
            sum += adc_samples[i];
        }
        
        uint16_t average = sum / SAMPLE_BUFFER_SIZE;
        Serial.print("Average ADC: ");
        Serial.println(average);
        
        buffer_ready = false;
    }
}
```

#### 🚀 고급 프로젝트

**5. 멀티채널 PWM 제어 시스템**
```c
// 복수 타이머를 이용한 정밀 PWM 제어
struct pwm_channel {
    volatile uint8_t *port;
    uint8_t pin;
    uint16_t duty_cycle;    // 0-1000 (0.1% 단위)
    uint16_t period;        // PWM 주기 (μs)
    uint16_t counter;
};

#define PWM_CHANNELS 4
volatile struct pwm_channel pwm_channels[PWM_CHANNELS];

// 고해상도 타이머 인터럽트 (10kHz)
ISR(TIMER2_COMPA_vect) {
    static uint16_t master_counter = 0;
    master_counter++;
    
    for (int i = 0; i < PWM_CHANNELS; i++) {
        struct pwm_channel *ch = &pwm_channels[i];
        
        if (master_counter % (ch->period / 100) == 0) {
            ch->counter = 0;
            *(ch->port) |= (1 << ch->pin);  // HIGH
        }
        
        if (ch->counter == (ch->duty_cycle * ch->period / 100000)) {
            *(ch->port) &= ~(1 << ch->pin); // LOW
        }
        
        ch->counter++;
    }
}
```

**6. 실시간 오실로스코프 (인터럽트 기반)**
```c
// 고속 샘플링 및 실시간 디스플레이
#define SAMPLE_RATE_HZ 100000  // 100kHz 샘플링
#define DISPLAY_WIDTH 320
#define TRIGGER_LEVEL 512

volatile uint16_t sample_buffer[DISPLAY_WIDTH * 2];  // 더블 버퍼링
volatile int active_buffer = 0;
volatile int sample_count = 0;
volatile bool trigger_found = false;

// 고속 ADC 샘플링 인터럽트
ISR(TIMER1_COMPA_vect) {
    // 현재 활성 버퍼에 샘플 저장
    uint16_t *buffer = (uint16_t*)sample_buffer + (active_buffer * DISPLAY_WIDTH);
    
    // ADC 변환 시작 및 결과 읽기 (동시 진행)
    ADCSRA |= (1 << ADSC);
    while (ADCSRA & (1 << ADSC));  // 변환 대기
    uint16_t sample = ADCL | (ADCH << 8);
    
    // 트리거 검출
    if (!trigger_found && sample_count > 0) {
        if (buffer[sample_count - 1] < TRIGGER_LEVEL && sample >= TRIGGER_LEVEL) {
            trigger_found = true;
            sample_count = 0;  // 트리거 지점부터 다시 시작
        }
    }
    
    if (trigger_found) {
        buffer[sample_count++] = sample;
        
        if (sample_count >= DISPLAY_WIDTH) {
            // 버퍼 스위칭
            active_buffer = 1 - active_buffer;
            sample_count = 0;
            trigger_found = false;
            
            // 메인 루프에 디스플레이 업데이트 신호
            set_display_update_flag();
        }
    }
}
```

### 문제 해결 가이드

#### 일반적인 인터럽트 버그들

**1. 인터럽트에서 블로킹 함수 호출**
```c
// ❌ 잘못된 예시
void timer_isr(void) {
    printf("Timer interrupt\n");  // 블로킹 가능
    delay(100);                   // 절대 금지!
    malloc(1024);                 // 위험함
}

// ✅ 올바른 예시  
void timer_isr(void) {
    timer_flag = true;           // 플래그만 설정
    increment_counter();         // 빠른 처리만
}

void main_loop(void) {
    if (timer_flag) {
        timer_flag = false;
        printf("Timer fired\n");  // 메인 루프에서 처리
    }
}
```

**2. 공유 변수 보호 실패**
```c
// ❌ 위험한 코드
volatile int shared_counter = 0;

void timer_isr(void) {
    shared_counter++;  // 32비트 증가는 원자적이지 않을 수 있음
}

void main_function(void) {
    int local_copy = shared_counter;  // 중간에 인터럽트 발생 시 문제
    printf("Counter: %d\n", local_copy);
}

// ✅ 안전한 코드
void main_function(void) {
    cli();  // 인터럽트 비활성화
    int local_copy = shared_counter;
    sei();  // 인터럽트 재활성화
    printf("Counter: %d\n", local_copy);
}
```

**3. 인터럽트 무한 루프**
```c
// ❌ EOI 누락으로 인한 문제
void network_isr(void) {
    process_packets();
    // EOI 전송 누락! → 인터럽트가 계속 대기 상태
}

// ✅ 올바른 EOI 처리
void network_isr(void) {
    process_packets();
    send_eoi_to_pic();  // 반드시 EOI 전송
}
```

### 최종 정리: 인터럽트 마스터하기

#### 🎯 핵심 포인트 요약

**1. 인터럽트의 본질**
- **비동기성**: 예측 불가능한 시점에 발생
- **우선순위**: 중요도에 따른 처리 순서
- **투명성**: 원래 프로그램에 영향 없음
- **효율성**: CPU 자원의 최적 활용

**2. 처리 메커니즘의 핵심**
- **컨텍스트 보존**: 완벽한 상태 저장/복원
- **빠른 처리**: 최소한의 ISR 실행 시간
- **안전성**: 공유 자원의 보호
- **확장성**: 멀티코어/가상화 환경 지원

**3. 성능 최적화의 열쇠**
- **인터럽트 통합**: 여러 이벤트 일괄 처리
- **상/하반부 분리**: 긴급/비긴급 작업 구분
- **친화성 관리**: CPU별 인터럽트 분산
- **캐시 효율성**: 메모리 접근 패턴 최적화

#### 📖 추천 학습 자료

**📚 필수 도서**
- "Understanding the Linux Kernel" - Daniel P. Bovet
- "Computer Systems: A Programmer's Perspective" - Bryant & O'Hallaron  
- "ARM System Developer's Guide" - Andrew Sloss
- "Intel 64 and IA-32 Architectures Software Developer's Manual"

**🌐 온라인 리소스**
- Linux Kernel Source Code (github.com/torvalds/linux)
- OSDev Wiki (wiki.osdev.org)
- ARM Developer Documentation
- Intel Architecture Manuals

**🛠️ 실습 도구**
- **QEMU**: 다양한 아키텍처 에뮬레이션
- **Bochs**: x86 시스템 시뮬레이션  
- **GDB**: 커널 수준 디버깅
- **Wireshark**: 네트워크 인터럽트 분석
- **perf**: Linux 성능 프로파일링

#### 🚀 학습 로드맵

**1단계: 기초 다지기 (2-4주)**
- 인터럽트 기본 개념 이해
- 간단한 ISR 작성 연습
- 아두이노/AVR로 실습

**2단계: 심화 학습 (4-8주)**  
- 운영체제 인터럽트 처리 분석
- Linux 커널 드라이버 분석
- 성능 측정 및 최적화

**3단계: 전문가 과정 (8-12주)**
- 실시간 시스템 설계
- 가상화 환경 인터럽트
- 고성능 시스템 개발

**4단계: 마스터 레벨 (지속적)**
- 최신 기술 트렌드 추적
- 커뮤니티 기여 (오픈소스)
- 연구 및 혁신

---
