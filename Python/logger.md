
## `print` 말고 로거(Logger)가 뭐죠?

`print()`가 개발 중 눈으로 값을 확인하는 **단순한 출력 도구**라면, \*\*로거(Logger)\*\*는 프로그램의 상태와 동작에 대한 정보를 체계적으로 기록하고 관리하는 **전문적인 기록 시스템**입니다.

단순히 콘솔에 메시지를 표시하는 것을 넘어, "누가, 언제, 어디서, 무슨 일이, 왜 일어났는지"를 목적에 따라 다양한 형식과 위치에 기록으로 남기는 행위를 \*\*로깅(Logging)\*\*이라고 합니다.

-----

### `print`와 로거(Logger)의 결정적인 차이점

| 구분 | `print()` | **로거 (Logger)** |
| :--- | :--- | :--- |
| **목적** | 개발 중 변수 값 등을 **단순히 눈으로 확인** | 프로그램의 동작 상태, 오류, 주요 이벤트 등을 **체계적으로 기록 및 추적** |
| **레벨 관리** | 없음 (모든 메시지가 동일하게 출력됨) | **레벨(Level) 시스템**으로 심각도에 따라 기록 여부 제어 (e.g., DEBUG, INFO, WARNING, ERROR) |
| **출력 제어** | 코드 수정 없이는 켜고 끄기 어려움 | 설정 변경만으로 **쉽게 로그 출력을 제어**하고, 출력 대상을 변경 가능 |
| **출력 대상** | 콘솔 (터미널) | **콘솔, 파일, 네트워크, 데이터베이스 등** 다양한 대상으로 출력 가능 |
| **정보의 풍부함** | 출력할 내용을 직접 다 만들어야 함 | **시간, 파일명, 함수명, 줄 번호 등** 유용한 정보를 자동으로 기록에 포함 가능 |
| **성능** | 많은 양을 출력할 경우 성능에 영향 | 비동기 처리, 버퍼링 등 **성능 최적화 기능** 제공 |

**간단한 비유:**

  * `print()`는 개발자가 급하게 남기는 **메모지**와 같습니다. 간단하고 빠르지만, 나중에 체계적으로 관리하기 어렵습니다.
  * \*\*로거(Logger)\*\*는 회의 내용을 상세히 기록하는 **회의록**이나 선박의 항해 상태를 기록하는 **항해 일지**와 같습니다. 정해진 형식과 규칙에 따라 기록되어, 문제가 발생했을 때 원인을 분석하는 데 결정적인 단서가 됩니다.

-----

### 왜 `print` 대신 로거를 사용해야 할까요?

개발할 때는 `print()`가 편해 보일 수 있지만, 실제 서비스를 운영(배포)할 때는 `print()`를 사용하면 여러 문제가 발생합니다.

1.  **정보의 홍수**: 수많은 `print`문이 콘솔에 뒤섞여 정작 중요한 오류 메시지를 놓치기 쉽습니다.
2.  **쓸모없는 로그**: 개발 시에만 필요했던 `print`문들이 운영 환경에서도 계속 실행되어 자원을 낭비합니다.
3.  **원인 분석의 어려움**: 에러가 발생했다는 사실만 알 뿐, 언제, 어떤 상황에서 발생했는지 맥락을 파악하기 어렵습니다.
4.  **기록의 유실**: 프로그램이 종료되거나 서버가 재시작되면 `print`로 출력된 내용은 모두 사라집니다.

**로거를 사용하면 이런 문제들을 해결할 수 있습니다.**

  * **레벨 설정**: "운영 환경에서는 'INFO' 레벨 이상의 로그만 파일에 기록해줘" 와 같이 심각도에 따라 로그를 필터링할 수 있습니다.
  * **유연한 설정**: 코드를 수정하지 않고 설정 파일 변경만으로 "이제부터는 'ERROR' 레벨 로그만 기록하자" 또는 "로그를 파일이 아닌 다른 서버로 보내자" 와 같이 유연하게 변경할 수 있습니다.
  * **상세한 분석**: 로그에 남은 시간, 발생 위치(파일, 함수) 등의 정보를 통해 오류의 원인을 훨씬 빠르고 정확하게 파악할 수 있습니다.

-----

### 파이썬의 `logging` 모듈 기본 사용법

파이썬은 `logging`이라는 강력한 표준 라이브러리를 기본으로 제공합니다.

**기본 예제:**

```python
import logging

# 로거 기본 설정
# level: 이 레벨 이상의 로그만 처리
# format: 로그 메시지 형식 지정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# 이제 print 대신 logging 함수를 사용합니다.
logging.debug("이 메시지는 출력되지 않습니다. (level이 INFO보다 낮기 때문)")
logging.info("서버가 시작되었습니다.")
logging.warning("메모리 사용량이 80%를 초과했습니다.")
logging.error("데이터베이스 연결에 실패했습니다.")
logging.critical("시스템의 핵심 기능이 중단되었습니다!")
```

**실행 결과:**

```
2025-07-23 20:47:57,123 - INFO - 서버가 시작되었습니다.
2025-07-23 20:47:57,123 - WARNING - 메모리 사용량이 80%를 초과했습니다.
2025-07-23 20:47:57,123 - ERROR - 데이터베이스 연결에 실패했습니다.
2025-07-23 20:47:57,123 - CRITICAL - 시스템의 핵심 기능이 중단되었습니다!
```

**로그 레벨(Level)의 심각도 순서** (아래로 갈수록 심각)

  * `DEBUG`: 개발 단계에서 상세한 정보가 필요할 때 사용
  * `INFO`: 일반적인 정보, 프로그램이 예상대로 동작하고 있음을 알림
  * `WARNING`: 심각한 문제는 아니지만 주의가 필요하거나 예상치 못한 일이 발생했을 때
  * `ERROR`: 심각한 문제로 인해 프로그램의 일부 기능이 동작하지 않을 때
  * `CRITICAL`: 매우 심각한 문제로 프로그램 자체가 중단될 수 있을 때

### 결론

**`print()`는 잠깐 쓰고 지울 디버깅용 도구**이고, **로거는 제품(프로그램)의 품질과 안정성을 위해 반드시 필요한 시스템**입니다. 간단한 스크립트가 아니라면, 처음부터 `logging` 모듈을 사용하는 습관을 들이는 것이 매우 중요합니다.

`logging` 뒤에는 로그 메시지를 보내는 함수, 로깅 시스템을 설정하는 함수, 그리고 더 세밀한 제어를 위한 로거(Logger), 핸들러(Handler), 포매터(Formatter) 객체를 가져오거나 생성하는 것들이 옵니다.

크게 **기본 함수**와 **고급 제어를 위한 객체**로 나눌 수 있습니다.

-----

### \#\# 1. 주요 기본 함수 (간편한 사용)

이 함수들은 내부적으로 \*\*루트 로거(root logger)\*\*라는 기본 로거를 사용하며, 간단한 스크립트에서 빠르게 로깅을 시작할 때 유용합니다.

| 함수 | 설명 |
| :--- | :--- |
| **`logging.basicConfig(**kwargs)`** | 로깅 시스템의 **가장 기본적인 설정을 한 번만** 수행합니다. 프로그램 시작 시 한 번만 호출해야 합니다. |
| **`logging.debug(msg)`** | 디버깅용 상세 정보를 기록합니다. (기본 레벨에서는 무시됨) |
| **`logging.info(msg)`** | 일반 정보성 메시지를 기록합니다. |
| **`logging.warning(msg)`** | 경고 메시지를 기록합니다. |
| **`logging.error(msg)`** | 오류 발생을 기록합니다. |
| **`logging.critical(msg)`** | 치명적인 오류 발생을 기록합니다. |
| **`logging.exception(msg)`** | `error()`와 비슷하지만, **예외(Exception) 추적 정보**를 함께 기록합니다. `try...except` 블록 안에서 사용합니다. |

#### **`basicConfig`의 주요 파라미터**

`basicConfig`는 로깅 시스템의 동작 방식을 손쉽게 설정하게 해줍니다.

  * **`level`**: 설정된 레벨 이상의 로그만 처리하도록 지정합니다. (e.g., `logging.INFO`)
  * **`format`**: 로그 메시지의 출력 형식을 지정합니다.
  * **`filename`**: 로그를 콘솔이 아닌 파일에 기록할 때 파일 경로를 지정합니다.
  * **`filemode`**: `filename` 지정 시 파일 열기 모드를 설정합니다. (`'w'`: 덮어쓰기, `'a'`: 이어쓰기)

**기본 함수 사용 예시:**

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='my_app.log',
    filemode='w'
)

logging.info("프로그램 시작")

try:
    result = 10 / 0
except ZeroDivisionError:
    logging.exception("0으로 나누기 시도 중 예외 발생!") # 에러와 함께 Traceback이 기록됨

logging.info("프로그램 종료")
```

위 코드를 실행하면 `my_app.log` 파일에 로그가 기록됩니다.

-----

### \#\# 2. 고급 제어를 위한 객체 (권장 방식)

여러 모듈로 구성된 복잡한 애플리케이션에서는 루트 로거만 사용하는 대신, 이름있는 **로거(Logger) 객체**를 만들어 사용하는 것이 훨씬 효과적입니다. 이를 통해 모듈별로 로깅을 분리하고 독립적으로 제어할 수 있습니다.

#### **핵심 3요소: Logger, Handler, Formatter ⚙️**

1.  **`logging.getLogger(name)`**: **로거 객체를 생성하거나 가져옵니다.**

      * 이름(`name`)을 지정하여 독립적인 로거를 만듭니다.
      * 일반적으로 `name`에는 `__name__`(현재 모듈의 이름)을 사용해 모듈별로 로거를 구분합니다.
      * **역할**: 로그 메시지를 받을 주체. "어떤 메시지를 받을지" 레벨로 필터링합니다.

2.  **핸들러 (e.g., `logging.FileHandler`, `logging.StreamHandler`)**: **로그를 어디로 보낼지 결정합니다.**

      * `logging.StreamHandler()`: 로그를 콘솔(터미널)로 보냅니다.
      * `logging.FileHandler(filename)`: 로그를 파일로 보냅니다.
      * **역할**: 로그 메시지의 최종 목적지를 담당.

3.  **`logging.Formatter(format_string)`**: **로그를 어떤 형식으로 꾸밀지 결정합니다.**

      * `format_string`에 `%(asctime)s`, `%(name)s`, `%(levelname)s` 등 특별한 코드를 넣어 출력 형식을 정의합니다.
      * **역할**: 로그 메시지의 출력 양식을 담당.

#### **고급 제어 실전 예제**

아래 예제는 `main_logger`라는 이름의 로거를 만들어, INFO 레벨 이상의 로그는 `console`에, DEBUG 레벨 이상의 로그는 `app.log` 파일에 서로 다른 형식으로 기록하는 방법입니다.

```python
import logging

# 1. 로거 생성 (이름으로 구분)
logger = logging.getLogger("main_logger")
logger.setLevel(logging.DEBUG) # 로거의 최저 레벨 설정 (이 레벨 이하의 로그는 무시)

# 2. 핸들러 생성 (로그를 어디로 보낼지 결정)
# 콘솔 핸들러: INFO 레벨 이상만 처리
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)

# 파일 핸들러: DEBUG 레벨 이상만 처리
file_handler = logging.FileHandler('app.log', mode='w')
file_handler.setLevel(logging.DEBUG)

# 3. 포매터 생성 (로그를 어떻게 꾸밀지 결정)
# 콘솔용 포매터
console_formatter = logging.Formatter('%(levelname)s - %(message)s')
# 파일용 포매터
file_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# 4. 핸들러에 포매터 연결
console_handler.setFormatter(console_formatter)
file_handler.setFormatter(file_formatter)

# 5. 로거에 핸들러 연결
logger.addHandler(console_handler)
logger.addHandler(file_handler)

# --- 로거 사용 ---
logger.debug("상세한 디버깅 정보입니다. 파일에만 기록됩니다.")
logger.info("일반 정보입니다. 콘솔과 파일 모두에 기록됩니다.")
logger.warning("경고! 파일과 콘솔에 모두 기록됩니다.")
logger.error("오류가 발생했습니다.")
```

**실행 결과:**

**💻 콘솔 출력:**

```
INFO - 일반 정보입니다. 콘솔과 파일 모두에 기록됩니다.
WARNING - 경고! 파일과 콘솔에 모두 기록됩니다.
ERROR - 오류가 발생했습니다.
```

**📄 `app.log` 파일 내용:**

```
2025-07-23 20:53:04,123 - main_logger - DEBUG - 상세한 디버깅 정보입니다. 파일에만 기록됩니다.
2025-07-23 20:53:04,123 - main_logger - INFO - 일반 정보입니다. 콘솔과 파일 모두에 기록됩니다.
2025-07-23 20:53:04,123 - main_logger - WARNING - 경고! 파일과 콘솔에 모두 기록됩니다.
2025-07-23 20:53:04,123 - main_logger - ERROR - 오류가 발생했습니다.
```

이처럼 `getLogger`, `Handler`, `Formatter`를 조합하면, 코드 수정 없이 설정만으로 로그의 형식, 레벨, 출력 위치를 자유자재로 제어할 수 있어 훨씬 전문적이고 유연한 로깅 시스템을 구축할 수 있습니다.