'''boj2212 - 센서
한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 
문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 
예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.

각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 
집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. 
N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 
집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 
센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 
따라서, 각 센서의 좌표는 정수 하나로 표현된다. 
이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 
단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.
'''
#1 6 9 3 6 7
#1 3 6 6 7 9 
# 1 3 6 / 6 7 9
# 1~6 사이에 하나, 6~9 사이에 하나 둬서 거리 합 최솟값 구하기? xx
# 1 3 / 6 6 7 9 로 나눠서 집중국 2개 세우는게 더 나음
# 정렬해서 인접 두 수의 차이 (거리)가 가장 큰 곳을 기준으로 나누기
# K-1 번 나누고..... 나눠진 원소들의 중간에다가 집중국 박기
# 집중국은 나눠진 원소들 좌표의 합 / 좌표 개수로 구한다.
# ex) 1 3 / 6 6 7 9 면 
# 집중국 1 = (1 + 3) / 2 = 2. / 좌표 2에 박으면 집중국의 수신 가능 영역은 왼쪽으로 1, 오른쪽으로 1로 좌표 1과 3의 센서와 수신 가능.
# 따라서 집중국 1의 수신 가능 영역 = 1 + 1 = 2
# 집중국 2 = (6+ 6 + 7 +9) / 4 = 28/4 = 7.
# 집중국 2 는 왼쪽으로 1, 오른쪽으로 2의 영역으로 6~9 수신 가능 집중국 2의 수신 가능 영역 3
# 따라서 합은 5... 구현이 복잡해보임
# 나누고 최댓값에서 최솟값 빼면 될듯? 3 - 1 = 2 / 9 - 6 = 3  합은 5
##############

# 최종 구현 방향
# 센서거리정렬해서 인접 두 수 차이를 리스트에 담기
# 두 수 차이 리스트를 거리 큰 순으로 정렬
# 전체 센서를 K - 1번 나눠서 K개의 집중국을 설치해야하므로...
# 거리차이 리스트 맨 앞에서부터 K-1개 빼고 나머리 거리는 다 더함
 
 

N = int(input()) # 센서의 개수
K = int(input()) # 집중국의 개수
sensor = list(map(int, input().split()))
sensor.sort()

# 인덱스 에러나서 예외처리함 
if K >= N:
    print(0)

else:
    distances = []
    for i in range(N - 1):
        distances.append(sensor[i + 1] - sensor[i])

    distances.sort(reverse=True) # 거리 큰 순으로 정렬
    # 3과 6의 차이가 젤 크므로 [3, 2, 2, 1, 0] 이렇게 될듯?
    # 3을 뺀 나머지를 더해도 될듯

    for i in range(K - 1):
        distances[i] = 0 # 가장 거리 큰거 제외하고 나머지 더할거라 거리 큰것들 0으로 재할당

    print(sum(distances))










# N = int(input()) # 센서의 개수
# K = int(input()) # 집중국의 개수
# sensor = list(map(int, input().split()))

# sensor.sort()


# div = N // K
# ans = 0


# def f(a):
#     global ans
#     sum_div = 0 # 나누어진 센서의 좌표 합

#     if a >= N:
#         for i in range(a - div, N):
#             sum_div += sensor[i]

#         flag = int(round(sum_div / (N - (a - div))))
#         for i in range(a - div, N):
#             ans += abs(flag - sensor[i])

#         return 

        

#     for i in range(a - div, a):
#        sum_div += sensor[i]

#     flag = int(round(sum_div / div)) #센서 좌표 합을 센서 개수로 나눠 집중국의 좌표를 구함
#     for i in range(a - div, a):
#        ans += abs(flag - sensor[i])



#     f(a + div)

# f(div)
# print(ans)

