## List 1 
## 확인 문제 

1.  **최적성이 의미하는 것은?**
    a) 빠름  
    b) 간단함  
    c) 더 개선 불가  
    d) 적은 메모리  

2.  **작업량을 판단하는 기준은?**
    a) 연산 횟수  
    b) 코드 길이  
    c) 변수 개수   
    d) 메모리  

3.  **리스트의 길이를 구하는 함수는?**
    a) size()  
    b) length()  
    c) len()   
    d) count()  
  
4.  **리스트의 첫 인덱스는?**
    a) 0  
    b) 1  
    c) -1  
    d) 2  


5.  O(n log n)보다 효율이 낮은 것은?  
    a) O(log n)  
    b) O($n^2$)  
    c) O(1)  
    d) O(n)

6.  arr = ['a', 'b', 'c']일 때 arr[1] = 'x'의 결과는?  
    a) ['a','b','c']  
    b) ['a','x','c']  
    c) ['x','b','c']  
    d) 에러

7.  arr = [3, 1, 7, 4, 6, 7]일 때, max\_idx값으로 올바른 것은?

<!-- end list -->

```
max_idx = 0  
for i in range(1,6):  
    if arr[max_idx] <= arr[i]:  
        max_idx = i  
```

8.  버블 정렬은 무엇을 비교하나요?  
    a) 첫값과 끝값  
    b) 인접한 값들  
    c) 가장 큰 값  
    d) 짝수 인덱스

죄송합니다. 요청하신 대로 다시 수정했습니다.

9.  **[5, 3, 1]에서 첫 번째 버블 정렬 후 결과는?**    
    a) [3, 1, 5]   
    b) [5, 1, 3]  
    c) [3, 5, 1]  
    d) [1, 3, 5]  
  
10. **카운팅 정렬은 어떤 방식인가요?**  
    a) 등장 횟수 세기  
    b) 위치 바꾸기  
    c) 나누기 정렬  
    d) 랜덤 정렬  
  
11. **카운팅 정렬의 전제 조건은?**   
    a) 정렬된 데이터  
    b) 값이 정수  
    c) 문자열  
    d) 리스트 길이 고정  
  
12. **완전 검색은 어떤 방법인가요?**  
    a) 무작위 선택  
    b) 빠르게 추정  
    c) 가능한 경우 모두 확인  
    d) 하나만 확인  




### 정답 및 해설  

1.  **c) 더 개선 불가** * 최적성은 더 이상 개선할 수 없는 상태를 의미합니다.  

2.  **a) 연산 횟수** * 작업량은 연산 횟수로 판단합니다.  

3.  **c) len()** * 리스트 길이는 len()으로 구합니다.  

4.  **a) 0** * 파이썬 리스트는 0부터 시작합니다.  

5.  **b) O($n^2$)** * O(1) < O(log n) < O(n) < O(n log n) < O($n^2$)  

6.  **b) ['a','x','c']** * 인덱스 1의 값이 'c'에서 'x'로 바뀝니다.  

7.  **5** * 리스트에서 최댓값이 여러 개일 경우 마지막 인덱스 max_idx를 찾는 코드입니다. 따라서 max_idx = 5입니다.  

8.  **b) 인접한 값들** * 버블 정렬은 인접한 값들을 비교합니다.  

9.  **b) [3, 1, 5]** * 첫 번째 버블 정렬 과정은 아래와 같습니다. 첫 번째 비교: 5와 3 -> 큰 수인 5가 뒤로 가야 하므로 자리를 바꿈 -> [3, 5, 1] 두 번째 비교: 5와 1 -> 다시 큰 수 5가 뒤로 가야 하므로 자리를 바꿈 -> [3, 1, 5]  

10. **a) 등장 횟수 세기** * 카운팅 정렬은 등장 횟수를 세어 리스트를 정렬하는 방법입니다.  

11. **b) 값이 정수** * 카운팅 정렬은 정수 값에 적합합니다.  

12. **c) 가능한 경우 모두 확인** * 완전 탐색은 가능한 경우를 모두 확인합니다.


## List2

1.  **다음 중 2차원 배열의 선언으로 올바른 것은?**  
     a) arr = [0, 1, 2, 3]  
    b) arr = [[1, 2, 3], [4, 5, 6]]  
    c) arr = (1, 2), (3, 4)  
    d) arr = [[1, 2], 3, 4]  
  
2.  **델타 탐색에서 상하좌우를 나타내는 방향 배열로 알맞은 것은?**   
    a) di = [1, -1, 0, 0], dj = [0, 0, 1, -1]  
    b) di = [0, 1, 0, -1], dj = [1, 0, -1, 0]  
    c) di = [-1, 1, -1, 1], dj = [-1, -1, 1, 1]  
    d) di = [1, 1, 1, 1], dj = [0, 1, -1, 0]  
  
3.  **n개의 원소로 이루어진 집합의 부분집합의 개수는 몇 개인가?**   
    a) n  
    b) $n^2$  
    c) $2^n$  
    d) n!  
  
4.  **다음 중 비트 연산을 통해 부분집합을 확인하는 코드에서 if i & (1<<j)가 의미하는 것은?**   
    a) i가 j보다 작으면  
    b) i의 j번째 비트가 1이면  
    c) i가 j보다 크면  
    d) i가 i의 인덱스일 때


5.  **다음 중 순차 검색(정렬되지 않은 배열)의 시간 복잡도는?**  
    a) O(log n)  
    b) O(1)  
    c) O(n)  
    d) O(n log n)  
  
6.  **이진 검색이 실패하는 조건으로 옳은 것은?**   
    a) 배열이 정렬되지 않은 경우  
    b) 배열의 길이가 짝수인 경우  
    c) 배열에 중복된 값이 있는 경우  
    d) 값이 음수인 경우  
  
7.  **선택 정렬의 특징으로 옳은 것은?**  
    a) 항상 O(log n)으로 동작한다  
    b) 선택된 요소만 정렬하고 나머지는 무시한다  
    c) 정렬 중 교환 횟수가 적다  
    d) 가장 큰 값부터 앞으로 보낸다  
  
8.  **다음 중 전치(transpose) 행렬에 대한 설명으로 옳은 것은?**   
    a) 각 행의 평균을 구한다  
    b) 대각선 방향으로만 값을 바꾼다  
    c) 행과 열의 위치를 바꾸는 연산이다  
    d) 모든 값에 -1을 곱한다


9.  **다음 중 '델타 탐색'에서 고려해야 할 조건으로 옳은 것은?**   
    a) 인접한 모든 원소가 0인지 확인  
    b) 인덱스가 유효한 범위 내에 있는지 확인  
    c) 배열이 오름차순인지 확인  
    d) 부분집합의 개수를 세어야 한다  
  
10. **다음 중 selection 알고리즘의 설명으로 적절하지 않은 것은?**   
    a) k번째로 작은 원소를 찾을 때 사용된다  
    b) 모든 요소를 정렬한 뒤 원하는 순서를 가져온다  
    c) 일반적으로 O(log n)의 시간 복잡도를 가진다  
    d) 최솟값, 최댓값, 중간값 탐색에 사용된다




### 정답 및 해설  

1.  **b) arr = [[1, 2, 3], [4, 5, 6]]** * 2차원 배열은 리스트의 리스트 형태로 선언되며, [[1, 2, 3], [4, 5, 6]]은 2행 3열 구조로 올바릅니다.  

2.  **b) di = [0, 1, 0, -1], dj = [1, 0, -1, 0]** * 상하좌우 순서의 방향 벡터는 각각 (0,1), (1,0), (0,-1), (-1,0)입니다.  

3.  **c) $2^n$** * 각 원소가 포함되거나 포함되지 않는 두 가지 경우가 있으므로, 전체 부분집합의 수는 $2^n$입니다.  

4.  **b) i의 j번째 비트가 1이면** * `(1<<j)`는 j번째 비트가 1인 수이고, `i & (1<<j)`는 i의 j번째 비트가 1인지 확인하는 표현입니다.  

5.  **c) O(n)** * 정렬되지 않은 배열에서는 순차적으로 모든 요소를 비교하므로 시간복잡도는 O(n)입니다.  

6.  **a) 배열이 정렬되지 않은 경우** * 이진 검색은 반드시 정렬된 배열에서만 수행할 수 있습니다. 정렬되지 않은 배열에서는 동작하지 않습니다.  

7.  **c) 정렬 중 교환 횟수가 적다** * 선택 정렬은 다른 정렬 알고리즘 중 교환 횟수가 비교적 적습니다.  

8.  **c) 행과 열의 위치를 바꾸는 연산이다** * 전치 행렬은 행의 원소를 열로, 열의 원소를 행으로 바꾸는 연산입니다.  

9.  **b) 인덱스가 유효한 범위 내에 있는지 확인** * 델타 탐색은 상하좌우를 탐색하므로 배열의 범위를 벗어나지 않도록 인덱스 유효성 검사를 꼭 해야 합니다.  

10. **c) 일반적으로 O(log n)의 시간 복잡도를 가진다** * selection 알고리즘은 O(kn)의 시간 복잡도를 가집니다.

## str1
1.  **d) 문자열의 길이를 변경할 수 없다.** * 문자열은 인덱싱, 슬라이싱이 가능한 순서가 있는 자료형입니다. 하지만 변경은 불가능(immutable)합니다.  

2.  **d) 고정 길이 인코딩으로 4바이트로 표현한다.** * 4바이트 고정으로 인코딩하는 방식은 UTF-32입니다.  

3.  **b) yth** * 슬라이싱은 시작 인덱스 포함, 끝 인덱스 미포함입니다. 따라서 1~3까지 y, t, h가 출력됩니다.  

4.  **b) 'l'** * 음수 인덱스는 뒤에서부터 셉니다. -1은 'e', -2는 'l'입니다.  

5.  **c) 새로운 문자열을 반환한다.** * 문자열은 immutable이므로, replace()는 원래 문자열을 변경하지 않고 새로운 문자열을 반환합니다.  

6.  **d) "3.14.15"** * "3.14.15"는 숫자 형식이 잘못되어 float()나 int()로 변환할 수 없습니다.  

7.  **find()** * find()는 특정 문자가 처음 등장하는 위치(인덱스)를 반환합니다. 찾지 못하면 -1을 반환합니다.  

8.  **count()** * 문자열에서 특정 문자가 몇 번 나오는지 셀 때 count() 메서드를 사용합니다.  

9.  **HELLO PYTHON** * upper()는 문자열의 모든 알파벳을 대문자로 바꿉니다.  

10. **::-1** * 슬라이싱의 세 번째 인자(step)를 -1로 주면 역순이 됩니다.  

11. **'Hello'** * strip()은 문자열의 앞뒤 공백을 제거합니다. 중간 공백은 제거하지 않습니다.  

12. **A-B-C** * join()은 리스트의 각 요소 사이에 지정한 문자열을 삽입해 하나의 문자열로 만듭니다.
