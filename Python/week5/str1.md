## 학습시작
웹페이지에서 `쏅샗샖믽쉹헮얷쪵뭹` 라는 문구가 표시됩니다.
1. 저장할 때 UTF-8로 저장하고, 읽을 때 EUC-KR로 읽었기 때문입니다
2. 웹페이지라면 `<meta charset="UTF-8">` 지정이 필요합니다

### 목차
#### 문자열
- 코드체계
- 문자열
- 연습문제
- 연산
#### 패턴매칭
- 고지식한 패턴 검색
- KMP 알고리즘
- 보이어-무어 알고리즘
- 문자열 암호화

### 코드체계
문자에 대응되는 숫자를 정한 것입니다.
예를 들어 글자 A를 메모리에 저장하는 방법을 생각해볼까요? 메모리는 숫자만 저장할 수 있습니다. 영어가 대소문자 합쳐서 52자 이므로 6비트(64가지 경우)면 저장할 수 있습니다. 예를 들어 'a' -> 000000(0), 'b' -> 000001(0), 'c' -> 000010(3) 같이 6비트 이진수(10진수)를 배정합니다.

### 코드체계의 문제
* 네트워크가 발전되기 전 미국의 각 지역 별로 코드체계를 정해 놓고 사용.
* 네트워크가 발전하면서 서로 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생김.

### 코드체계의 개선
* 그래서 혼돈을 피하기 위해 표준안을 만들기로 함.
* 1967년, 미국에서 ASCII(American Standard Code for Information Interchange)라는 문자 인코딩 표준이 제정됨.
* ASCII는 7-bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들이 공백을 비롯한 95개의 출력 가능한 문자들로 이루어짐.


### 확장 아스키 (Extended ASCII)
* 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가.
* 표준 아스키는 7-bit를 사용하여 문자를 표현, 확장 아스키는 1Byte 내의 8-bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있음.
* 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수 있도록 하고 있고, 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못함.
* 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독할 수 있음.


### 확장 아스키 (Extended ASCII)
* 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가.
* 표준 아스키는 7-bit를 사용하여 문자를 표현, 확장 아스키는 1Byte 내의 8-bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있음.
* 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수 있도록 하고 있고, 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못함.
* 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독할 수 있음.

### 유니코드
유니코드 : 다국어 처리를 위한 표준 코드체계이다.
* 컴퓨터가 발전하면서 미국뿐 아니라 각 나라에서 컴퓨터가 발전함
* 각 국가들은 자국의 문자를 표현하기 위하여 코드체계를 만들어서 사용하게 됨
    * 우리나라도 한글 코드체계를 만들어 사용했고 조합형, 완성형 두 종류를 가지고 있었습니다.
* 인터넷이 전 세계로 발전하면서 ASCII를 만들기 전과 같은 문제가 국가 사이에 정보를 주고 받을 때 발생함.
    * 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석할 수 밖에 없음.
* 다국어 처리를 위해 표준인 **유니코드**를 만듬
    * 비영리 단체인 유니코드 컨소시엄([https://home.Unicode.org](https://home.Unicode.org))에서 관리합니다.
    * 이모지(Emoji)도 유니코드 문자입니다.


### 유니코드 Character Set
* 유니코드도 다시 Character Set으로 분류됨.
    * UCS-2(Universal Character Set 2)
    * UCS-4(Universal Character Set 4)
* 유니코드를 저장하는 변수의 크기를 정의함.
    * 그러나, 바이트 순서에 대해서는 표준화하지 못했습니다.
* 파일을 읽을 때 UCS-2, UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생.
    * 그래서 유니코드의 적당한 외부 인코딩이 필요하게 되었습니다.


### 바이트 단위 저장 순서
* 바이트 단위 저장 순서가 정해지지 않은 경우 잘못된 해석 가능성
    * 여러 바이트로 이루어진 데이터를 저장하는 방식을 Endian 이라고 합니다.
    * **Big-endian**은 상위 바이트(MSB, Most Significant Byte)를 가장 낮은 주소에 저장합니다.
    * **Little-endian**은 하위 바이트(LSB, Least Significant Byte)를 가장 낮은 주소에 저장
* little-endian과 big-endian : 여러 바이트로 표현된 수를 바이트 단위로 저장하는 순서를 나타낸다.


### 유니코드 인코딩 (UTF : Unicode Transformation Format) (일부)
* UTF-8 (in web)
    * MIN : 8-bit, MAX : 32-bit(1 Byte * 4)
    * 필요한 크기에 따른 저장 방법 예
        * 0xxxxxxx
        * 110xxxxx 10xxxxxx
        * 1110xxxx 10xxxxxx 10xxxxxx
        * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
* UTF-16 (in windows, java)
    * MIN : 16-bit, MAX : 32-bit(2 Byte * 2)
* UTF-32 (in unix)
    * MIN : 32-bit, MAX : 32-bit(4 Byte * 1)


### Python 인코딩
* UTF-8
    * 2.x 버전은 기본 인코딩 방식이 ASCII로 UTF-8 사용시 코드 첫 줄에 다음 문장 추가해야 함:
        * `# -*- coding: utf-8 -*-`
    * 3.x 버전은 UTF-8 방식이 기본이므로 표시 생략.
* 다른 인코딩 방식으로 처리시 첫 줄에 작성하는 항목에 원하는 인코딩 방식을 지정해주면 됨


### 문자열의 분류
* **Length-Controlled 문자열**
    * 문자열의 길이 정보를 함께 저장해서, 그 길이만큼 문자 데이터를 읽는 방식입니다.
    * Java, Python, 네트워크 패킷에 사용됩니다.
* **Delimited 문자열**
    * 문자열의 끝을 나타내는 특정한 구분자(Delimiter)가 있어서, 구분자가 나올 때까지 문자열로 인식합니다.
    * C언어는 널문자(`‘\0’`)를 사용합니다.


### 파이썬 str 클래스 구조
* 길이 외에 다른 정보도 저장
    * PyObject_HEAD: 모든 Python 객체가 상속하는 공통 구조입니다.
    * length: 문자열의 길이입니다.
    * hash: 문자열의 해시값으로, 딕셔너리 키로 쓸 때 사용됩니다.
    * interned: 같은 문자열을 관리하는 플래그입니다.
    * kind: 문자열 인코딩의 크기입니다.
    * data: 문자열이 저장된 실제 메모리 주소를 가리키는 포인터입니다.


### C언어에서 문자열
* 문자열은 문자들의 배열 형태로 구현된 응용 자료형.
* 문자 배열에 문자열을 저장할 때는 항상 마지막에 끝을 표시하는 널문자(`‘\0’`) 필요.
    * `char ary[]="abc"; // char ary[]={'a', 'b', 'c', '\0'};`
* 문자열 처리에 필요한 연산을 함수 형태로 제공함.
    * `strlen()`, `strcpy()`, `strcmp()`, …


### Java에서의 문자열
* 문자열 데이터를 저장, 처리해주는 클래스를 제공함.
* **String 클래스.**
    * `String str="abc"; // 또는 String str = new String("abc")`
* 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공함.
    * `+, length(), replace(), split(), substring(), ...`


### Python3에서의 문자열
* 텍스트 데이터의 취급방법이 통일되어 있음
    * python2와 달리 바이트 문자열과 Unicode 구분이 없습니다.
    * 유니코드(Unicode) 기반이라 어떤 언어나 기호도 동일한 방식으로 처리합니다.
* 문자열 기호
    * `'` (홑따옴표), `"` (쌍따옴표), `'''` (홑따옴표 3개), `"""` (쌍따옴표 3개)
* 연산
    * `+` 연결 (Concatenation)
        * 문자열 + 문자열 : 이어 붙여주는 역할
        * 예) `'ab' + 'c'`
    * `*` 반복
        * 문자열 * 수 : 수만큼 문자열이 반복
        * `'ab' * 3`
* 문자열은 데이터의 순서가 구분되는 시퀀스 자료형으로 분류됨.
    * 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있습니다.
* 문자열 클래스에서 제공되는 메소드.
    * replace(), split(), isalpha(), find()
* 문자열은 튜플과 같이 요소값을 변경할 수 없음(immutable)

### C, Java, Python3 문자열의 차이
* C는 아스키 코드로 저장
    * 한글을 출력할 수 있으나 콘솔의 도움을 받아야 합니다.
* Java는 유니코드(UTF=16, 2-Byte)로 저장
* Python3는 유니코드(UTF-8)로 저장


### 문자열 뒤집기

  * 문자열을 역순으로 재정의

<!-- end list -->

```python
s = 'Reverse this strings' # 'sgnirts siht esreveR'
s = s[::-1]
```

  * 리스트로 변환 후 다시 문자열로 변환

<!-- end list -->

```python
s = 'abcd'
s = list(s)
s.reverse()
s = ''.join(s)
```

### 회문
* "기러기", "토마토", "스위스"와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장이나 낱말
* 문자열 길이의 절반만 비교하면 됩니다.

```python
is_palindrome(txt):
    for i : 1 -> len(txt)/2
        if txt[i] != txt[len(txt) - i]
            return False
    return True
```

### 문자열 비교

  * `==` 연산자와 `is` 연산자
      * `==`는 값(value)이 같은지를 비교합니다.
      * `is`는 객체의 정체성(identity), 즉 같은 객체(메모리 주소)인지 비교합니다.
      * `==` 연산자는 내부적으로 특수 메서드 `__eq__()`를 호출합니다.

<!-- end list -->

```python
s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 = s1
s5 = s1[:2] + 'c'

print(s1 == s2) # True
print(s1 is s2) # True
print(s4 == s5) # True
print(s4 is s5) # False
```

```python
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b) # True (값이 같음)
print(a is b) # False (다른 객체임)
```

### C와 Java에서의 문자열 비교
* C
    * `strcmp()` 함수를 사용해 문자열의 내용을 비교합니다.
* Java
    * `==` 연산자는 객체의 주소(참조)를 비교합니다. (Python의 `is` 연산자 역할)
    * `equals()` 메소드는 객체의 내용을 비교합니다. (Python의 `==` 역할)


### 사전 순서 비교

  * 비교 연산자 `<` 사용
      * 유니코드를 비교합니다.

<!-- end list -->

1.  두 문자열의 사전상 순서를 비교하는 my\_strcmp() 함수를 구현한 예입니다.

<!-- end list -->

```python
def my_strcmp(s1, s2):
    if s1 < s2:
        return -1 # s1이 s2보다 사전 순서상 앞서는 경우
    elif s1 > s2:
        return 1  # s1이 s2보다 사전 순서상 나중인 경우
    else:
        return 0  # s1과 s2 문자열의 내용이 같은 경우
```

  * TIP
      * 문자열에 대한 `<` 연산은 유니코드 값에 대한 비교입니다.
      * 따라서 'Apple' \< 'apple' 도 True 이고 'Zebra' \< 'apple' 도 True입니다.

### 문자열 숫자를 숫자로 변환

1.  문자열을 숫자로 변환하는 예입니다.

<!-- end list -->

```python
a = int('123')
b = float('3.14')
c = int('A0', 16) # 문자열 'A0'를 16진법으로 해석해서 변환
```

2.  숫자를 문자열로 변환하는 예입니다.

<!-- end list -->

```python
a = str(123)
b = str(3.14)
```
* **코드체계란?**
    * 문자에 대응되는 숫자를 정한 것
    * ASCII, Unicode로 규격화
    * 표준화 되지 않은 부분때문에 외부 인코딩이 필요
* **문자열**
    * 문자들이 순서대로 나열된 데이터
    * 순서가 구분되는 시퀀스 자료형이고 요소값을 변경할 수 없음(immutable)
* **연산**
    * 연결(+), 반복(*), 비교(==, is)등 다양한 연산 가능
    * 문자열 객체에 사용할 수 있는 다양한 메서드 제공


## 확인 문제
### 각 문제에 올바른 답안을 생각해봅시다

1.  **문자열 자료형에 대한 설명으로 옳은 것은?**  
    a) 리스트로만 표현할 수 있다.  
    b) 숫자와 동일한 연산자만 사용할 수 있다.  
    c) 변경가능한(mutable) 자료형이다.  
    d) 문자열은 순서가 있는(ordered) 자료형이다.  

2.  **UTF-8 인코딩에 대한 설명으로 옳지 않은 것은?**  
    a) UTF-8은 가변 길이 바이트로 인코딩한다.  
    b) 영어 알파벳은 UTF-8에서 1바이트로 표현된다.  
    c) 전 세계 대부분의 문자와 호환된다.  
    d) 고정 길이 인코딩으로 4바이트로 표현한다.  

3.  **다음 문자열 슬라이싱 결과는?**  

    ```
    text = "Python"
    print(text[1:4])
    ```

4.  **문자열 s = "apple"이 있을 때, s[-2]의 결과는?**  
    a) 'p'  
    b) 'l'  
    c) 'e'  
    d) 'a'  


5.  **문자열 replace() 메서드의 설명으로 바른 것은?**   
    a) 대소문자를 자동으로 구분하지 않는다.    
    b) 원래 문자열을 직접 변경한다.    
    c) 새로운 문자열을 반환한다.    
    d) 문자열의 길이를 변경할 수 없다.  

6.  **다음 중 문자열을 숫자로 변환할 수 없는 경우는?**  
    a) "42"  
    b) "3.14"  
    c) "123"  
    d) "3.14.15"  

7.  **다음 설명에 맞는 메서드는?**   
* 문자열 "hello world"에서 'o' 문자가 처음 등장하는 인덱스를 반환하는 메서드    

8.  **다음 설명에 맞는 메서드는?** 
* "banana"라는 문자열에서 'a'의 개수를 세기 위한 메서드는?  


### 각 문제에 올바른 답안을 생각해봅시다  

9.  **다음 코드의 실행 결과는?** 

    ```
    text = "hello python"
    result = text.upper()
    print(result)
    ```
10. **다음 [ ]안에 들어갈 문자열을 역순으로 만드는 슬라이싱 표현식은?** 
    ```
    text = "apple"
    r_text = text[  ]
    ```
11. **result에 저장된 값은?** 
    ```
    text = "  Hello  "
    result = text.strip()
    ```
12. **다음 코드의 실행 결과는?** 
    ```
    text = '-'.join(["A", "B", "C"])
    print(text)
    ```



### 정답 및 해설  

1.  **d) 문자열의 길이를 변경할 수 없다.** * 문자열은 인덱싱, 슬라이싱이 가능한 순서가 있는 자료형입니다. 하지만 변경은 불가능(immutable)합니다.  

2.  **d) 고정 길이 인코딩으로 4바이트로 표현한다.** * 4바이트 고정으로 인코딩하는 방식은 UTF-32입니다.  

3.  **b) yth** * 슬라이싱은 시작 인덱스 포함, 끝 인덱스 미포함입니다. 따라서 1~3까지 y, t, h가 출력됩니다.  

4.  **b) 'l'** * 음수 인덱스는 뒤에서부터 셉니다. -1은 'e', -2는 'l'입니다.  

5.  **c) 새로운 문자열을 반환한다.** * 문자열은 immutable이므로, replace()는 원래 문자열을 변경하지 않고 새로운 문자열을 반환합니다.  

6.  **d) "3.14.15"** * "3.14.15"는 숫자 형식이 잘못되어 float()나 int()로 변환할 수 없습니다.  

7.  **find()** * find()는 특정 문자가 처음 등장하는 위치(인덱스)를 반환합니다. 찾지 못하면 -1을 반환합니다.  

8.  **count()** * 문자열에서 특정 문자가 몇 번 나오는지 셀 때 count() 메서드를 사용합니다.  

9.  **HELLO PYTHON** * upper()는 문자열의 모든 알파벳을 대문자로 바꿉니다.  

10. **::-1** * 슬라이싱의 세 번째 인자(step)를 -1로 주면 역순이 됩니다.  

11. **'Hello'** * strip()은 문자열의 앞뒤 공백을 제거합니다. 중간 공백은 제거하지 않습니다.  

12. **A-B-C** * join()은 리스트의 각 요소 사이에 지정한 문자열을 삽입해 하나의 문자열로 만듭니다.

