## 목차
* List
    * 과정 소개
    * 알고리즘
    * 배열
    * 연습 문제
    * 버블 정렬 (Bubble Sort)
    * 카운팅 정렬 (Counting Sort)
    * 완전 검색
    * 탐욕 알고리즘

### 의사코드(슈도코드, Pseudocode)와 순서도
* 컴퓨터 분야에서 알고리즘을 표현하는 방법

### 알고리즘의 성능
* APS 과정의 목표 중 하나 : 보다 좋은 알고리즘을 이해하고 활용하기
* 좋은 알고리즘이란?
    * **정확성**: 얼마나 정확하게 동작하는가  
    * 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가  
    * 메모리 사용량: 얼마나 적은 메모리를 사용하는가  
    * 단순성: 얼마나 단순한가  
    * 최적성: 더 이상 개선할 여지없이 최적화되었는가  

### 알고리즘의 시간 복잡도
* 알고리즘의 작업량을 표현할 때 시간 복잡도로 표현
* 시간 복잡도(Time Complexity)
    * 실제 걸리는 시간을 측정
    * 실행되는 명령문의 개수를 계산


### 시간 복잡도 표시
* 빅-오 표기법(Big-O Notation)을 언급하는 경우가 많음  
* 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시  
* 계수(Coefficient)는 생략하여 표시  
    * O(3n+2) = O(3n) = O(n)
        * 최고차항(3n)만 선택, 계수 3 제거
    * O(2n²+10n+100) = O(n²)
    * O(4) = O(1)

### 시간 복잡도별 실제 실행 시간 비교
* 5천만에 대한 연산을 수행한다면?
* $1\mu s = 10^{-6}$초
* $1ms = 10^{-3}$초

| N | logN | N | NlogN | $N^2$ | $N^3$ | $2^N$ |
|---|---|---|---|---|---|---|
| 10 | 0.003 $\mu s$ | 0.01 $\mu s$ | 0.033 $\mu s$ | 0.1 $\mu s$ | 1 $\mu s$ | 1 $\mu s$ |
| 20 | 0.004 $\mu s$ | 0.02 $\mu s$ | 0.086 $\mu s$ | 0.4 $\mu s$ | 8 $\mu s$ | 1 ms |
| 30 | 0.005 $\mu s$ | 0.03 $\mu s$ | 0.147 $\mu s$ | 0.9 $\mu s$ | 27 $\mu s$ | 1 s |
| 40 | 0.005 $\mu s$ | 0.04 $\mu s$ | 0.213 $\mu s$ | 1.6 $\mu s$ | 64 $\mu s$ | 18.3 min |
| 50 | 0.006 $\mu s$ | 0.05 $\mu s$ | 0.282 $\mu s$ | 2.5 $\mu s$ | 125 $\mu s$ | 13 days |
| $10^2$ | 0.007 $\mu s$ | 0.10 $\mu s$ | 0.664 $\mu s$ | 10 $\mu s$ | 1 ms | 4 x $10^{13}$ years |
| $10^3$ | 0.010 $\mu s$ | 1.00 $\mu s$ | 9.966 $\mu s$ | 1 ms | 1 s | |
| $10^4$ | 0.013 $\mu s$ | 10 $\mu s$ | 130 $\mu s$ | 100 ms | 16.7 min | |
| $10^5$ | 0.017 $\mu s$ | 0.10 ms | 1.67 ms | 10 s | 11.6 days | |
| $10^6$ | 0.020 $\mu s$ | 1 ms | 19.93 ms | 16.7 min | 31.7 days | |
| $10^7$ | 0.023 $\mu s$ | 0.01 s | 0.23 s | 1.16 days | 31,709 years | |
| $10^8$ (1억) | 0.027 $\mu s$ | 0.10 s | 2.66 s | 115.7 days | 3.17 x $10^4$ years | |
| $10^9$ | 0.030 $\mu s$ | 1 s | 29.90 s | 31.7 years | | |


### 배열 (Array)
* 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조


### 배열의 예시
* 6개의 변수를 사용해야 하는 경우
    * 이를 배열로 바꾸어 사용하는 예시
    * num0 = 0; num3 = 3;
    * num1 = 1; num4 = 4;
    * num2 = 2; num5 = 5;

    * -> num = [0, 1, 2, 3, 4, 5]
> 실제로 메모리에서 연속된 공간을 가져서 의미가 있음


### 배열의 필요성
* 프로그램 내에서 여러 개의 변수가 필요할 때
    * 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있음
* 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언
* 단순히 다수의 변수 선언을 의미하는 것이 아님
    * 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음

### 입력 받은 정수를 1차원 배열에 저장하는 방법
* 첫 줄에 양수의 개수 N이 주어진다. ($5 \le N \le 1000$)
* 다음 줄에 빈칸으로 구분된 N개의 양수 Ai가 주어진다. ($1 \le Ai \le 1000000$)

### 정수 N을 입력 받고, 공백으로 구분된 정수들을 리스트로 입력 받는 코드
```python
N = int(input())
arr = list(map(int, input().split()))
```

### 정렬의 종류
* APS 과정을 통해 자료구조와 알고리즘을 학습하면서 다양한 형태의 정렬을 학습
* 대표적인 정렬 방식의 종류
    * 버블 정렬 (Bubble Sort)
    * 퀵 정렬 (Quick Sort)
    * 카운팅 정렬 (Counting Sort)
    * 삽입 정렬 (Insertion Sort)
    * 선택 정렬 (Selection Sort)
    * 병합 정렬 (Merge Sort)

### 버블 정렬 (Bubble Sort)
* 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

### 버블 정렬 과정
* ① 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
* ② 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
* ③ 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 함
### 시간 복잡도
* $O(n^2)$


### 카운팅 정렬 (Counting Sort)
* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식


### 카운팅 정렬 제한 사항
* ① 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    * 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
* ② 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
### 시간 복잡도
* $O(n+k)$
    * n: 리스트 길이, k: 정수의 최댓값

### 탐욕 알고리즘 (Greedy)
* 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방식

### 탐욕 알고리즘 특징
* 최적해를 구하는 데 사용되는 근시안적인 방법
* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음
* 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근임

### 탐욕 알고리즘 과정
* ① 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가
* ② 실행 가능성 검사: 새로운 부분 해 집합이 실행 가능한지를 확인 (곧, 문제의 제약 조건을 위반하지 않는지를 검사)
* ③ 해 검사: 새로운 부분 해 집합이 문제의 해가 되는지를 확인 (아직 전체 문제의 해가 완성되지 않았다면 ①의 해 선택부터 다시 시작)


