# SW 문제 해결 응용
## 완전 탐색

목차
---
### 완전 탐색
* 반복과 재귀
* 순열
* 완전탐색
* 연습 문제
* 실습 문제


## 반복과 재귀

반복(Iteration)과 재귀(Recursion)는 유사한 작업을 수행할 수 있음.

---

### **반복(Iteration)**
* 수행하는 작업이 완료될 때까지 계속 반복함.
* 루프(for, while 구조)를 사용함.
* 반복문은 코드를 n번 반복시킬 수 있음.

---

### **재귀(Recursion)**
* 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법임.
* 하나의 큰 문제를 해결하기 쉬운 더 작은 문제로 쪼개고 결과들을 결합함.
* 재귀호출은 n중 반복문과 같은 효과를 냄.

### 순열이란?
* 서로 다른 N개에서 R개를 중복 없이, 순서를 고려하여 나열하는 것임.
* **예시)**
  * [0] [1] [2]로 구성된 3장의 카드가 다양하게 존재함.
  * 이 중 2장을 뽑아, 순열을 나열함.
  * (순열은 중복을 취급하지 않음.)

### 중복순열이란?
* 서로 다른 N개에서 R개를 **중복**을 허용하고, 순서를 고려하여 나열하는 것임.
* **예시)**
  * [0] [1] [2]로 구성된 3장의 카드가 다양하게 존재함.
  * 이 중에 2장을 뽑아, 중복순열을 나열함.

### 중복순열 구현 원리
1.  재귀호출을 할 때마다, 이동 경로를 흔적으로 남김.
2.  가장 마지막 레벨에 도착했을 때, 이동 경로를 출력함.

### 순열(Permutation)
* `path`라는 전역 리스트를 준비함.
* Level 2, Branch 3으로 동작되는 재귀 코드를 구현함.
* 재귀호출을 하기 직전에 이동할 곳의 위치를 `path` 리스트에 기록함.
* 재귀호출 됨. 그리고 코드가 계속 진행되어 `path.append(i)`를 수행함.
* 두 번 재귀호출 되었고, 이제 바닥에 도착했으니 출력하는 코드를 수행  
* 함수가 리턴되고, 함수가 즉시 종료됨
* 이후 path에 적은 마지막 기록이 삭제 되어야 함
* 이어서 for문이 진행되고, 변수 i 값은 1이 됨
* path 배열 마지막에 1이 삽입됨
* 재귀호출이 된 후, path 리스트를 출력
* 중복 순열 소스코드 완성 -> [0, 0] ~ [2, 2]까지 출력하는 소스 코드

```python
path = []

def KFC(x):
  if x == 2:
    print(path)
    return
  
  for i in range(3):
    path.append(i)
    KFC(x + 1)
    path.pop()

KFC(0)
```

