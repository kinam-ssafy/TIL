# 컴퓨팅 사고력
## 목차

### 컴퓨팅 사고력
- 프로그래밍과 논리/수학
- 논리와 증명
- 수와 표현
- 집합과 조합론
- 기초 수식
- 재귀
- 동적 계획법


## 프로그래밍과 논리/수학
### 논리 (Hard Logic)

생각이나 주장의 타당성과 옳고 그름을 판별하는 규칙이나 원리를 의미함.

경험적, 직관적, 확률적 판단을 의미하는 soft logic에 반대되는 의미로 hard logic이라고 표현함.

맞는 이유와 틀린 이유를 정확히 밝히는 생각의 규칙임.

### 프로그래밍의 어려운 점
- **프로그래밍 언어 문법과 라이브러리 사용**
  - 처음 보는 사람은 알 수 없음.
  - 훈련에 비례하여 실력이 늘게 됨.
- **논리**
  - 직관적인 접근을 논리로 착각하기 쉬움.

  ### 카드 문제

직관으로 접근하면 어려운 문제

* **사실**: 모든 카드의 한쪽 면에는 알파벳이, 다른 쪽 면에는 숫자가 쓰여 있음.
* **주장**: 한쪽이 D이면 반대쪽은 3.

* 주장이 사실인지 확인하기 위해 다음 카드들 중 반드시 뒤집어 보아야 하는 것은 몇 개이고 어느 것인가?  

  # D, F, 3, 7

* **답**: [D]와 [7]
* [D]를 뒤집어 보아야 한다는 것은 누구나 알아냄.
* [3]을 뒤집어 보아야 한다고 말하는 경우가 많이 있음.
  - 그러나 [3] 뒤에 [D]가 있든 없든 주장이 사실인지 여부에 영향이 없음.
* [7]을 뒤집어 볼 필요가 없다고 말하는 경우도 많음.
  - 그러나 [7] 뒤에 [D]가 있으면 주장이 성립하지 않게 됨.

  ### 맥주집 문제
* **규칙**: 20세 이하인 사람은 맥주를 마실 수 없음.
* 나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 몇 명이고 누구인가?
  - **답**: [17세]와 [맥주]

    # 17세, 31세, 콜라, 맥주

### 카드 문제와 맥주집 문제의 비교
- 맥주집 문제가 훨씬 풀기 쉬움.
- 사실, 두 문제는 완전히 같은 문제임. 즉, 논리적 구성이 완전히 동일함.
- 왜 맥주집 문제가 풀기 쉬운가?
  - 논리 구조를 정확히 이해하고 맥주집 문제를 푸는 사람은 카드 문제를 똑같이 풀 수 있음.
  - 맥주집 문제를 풀 때 푼 논리를 사용한 것이 아님.

### Soft Logic
* 맥주집 문제를 풀 때 직관을 사용한 것과 같은 경우
* 직관은 논리적인 느낌을 주는 것
* 직관의 장점은 (익숙한 상황에서) 빠름
* 직관의 단점은 정확하지 않음 (가끔은 익숙한 상황에서도 틀림)
* 또 다른 단점은 강한 착각을 일으킨다는 것

### Hard Logic vs Soft Logic
* **일상 생활**
  - Soft Logic이 빠르기 때문에 유용함.
  - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재함.

* **프로그래밍**
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것임.
  - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요함.

  ### Hard Logic vs Soft Logic
* **문제에 대해 오해하는 경우**
  * Soft Logic으로 알고리즘을 이해하려고 하는 경우임.
  * 알고리즘 설명을 보고 또 봐도 이해가 안 되는 것은 증명을 안 봤기 때문임.
  * 증명을 봐도 이해가 안 되는 것은 직관으로 이해하려고 하기 때문임.
  * 가끔 직관적으로 이해되는 알고리즘이 있지만, 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능함.

  ### 명제
- 참이나 거짓을 알 수 있는 식이나 문장
- p, q, r, …로 표현
- 예) 서울은 대한민국의 수도다.
1+1=3
- 진릿값
  - 참이나 거짓을 표현
  - T, F 또는 1, 0
  - 예) p가 거짓(F), q가 참(T)


### 명제의 연산(결합)

* **부정 (NOT)**
  * p가 명제일 때, 명제의 진릿값이 반대가 됨.
  * `~p` 또는 `-p`로 표기하고, not p 또는 p의 부정으로 읽음.
* **논리곱 (AND)**
  * p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제임.
  * `p ^ q`로 표기하고, p and q 또는 p 그리고 q로 읽음.

---

**진리표**

| p | ~p |
|:---:|:---:|
| T | F |
| F | T |

| p | q | p ^ q |
|:---:|:---:|:---:|
| T | T | T |
| T | F | F |
| F | T | F |
| F | F | F |

### 명제의 연산(결합)

* **논리합 (OR)**
  * p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제임.
  * `p V q`로 표기하고 p or q나 p 또는 q로 읽음.

| p | q | p V q |
|:---:|:---:|:---:|
| T | T | T |
| T | F | T |
| F | T | T |
| F | F | F |

### 명제의 연산(결합)

* **배타적 논리합 (XOR)**
  * p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제임.
  * `p ⊕ q`로 표기하고, p xor q 또는 p exclusive OR q로 읽음.

| p | q | p ⊕ q |
|:---:|:---:|:---:|
| T | T | F |
| T | F | T |
| F | T | T |
| F | F | F |

### 조건명제
* p, q가 명제일 때, 명제 p가 조건(원인), q가 결론(결과)으로 제시되는 명제임.
* `p → q` (p이면 q이다)

| p | q | p → q |
|:---:|:---:|:---:|
| T | T | T |
| T | F | F |
| F | T | T |
| F | F | T |

### 쌍방조건명제
* p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
* `p ↔ q` (p면 q고, q면 p다)

| p | q | p ↔ q |
|:---:|:---:|:---:|
| T | T | T |
| T | F | F |
| F | T | F |
| F | F | T |

### 조건명제의 역, 이, 대우
- **주어진 명제**: `p → q`
- **역**: `q → p`
- **이**: `~p → ~q`
- **대우**: `~q → ~p`

| p | q | p → q | q → p | ~p → ~q | ~q → ~p |
|---|---|---|---|---|---|
| T | T | T | T | T | T |
| T | F | F | T | T | F |
| F | T | T | F | F | T |
| F | F | T | T | T | T |


### 문제 1: 다음을 명제식 형태로 쓰고 참인지 거짓인지 판단하시오

**① 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.**
* p: 0은 홀수이다. (거짓)
* q: 미국에서 2080년 월드컵이 열린다. (알 수 없음)
* 명제식: p → q. `p` 명제가 거짓이므로, `q` 명제의 참/거짓 여부와 관계없이 해당 명제식은 **참**이다.

---

**② 만약 19893827938274839이 Prime Number라면, 2는 짝수이다.**
* p: 19893827938274839은 Prime Number이다. (알 수 없음)
* q: 2는 짝수이다. (참)
* 대우 명제는 `~q → ~p`인데, `~q`는 '2가 홀수이다'가 되어 거짓인 명제가 됨. 따라서 `~q` 명제가 거짓이므로, `~p` 명제의 참/거짓 여부와 관계없이 해당 명제식은 **참**이 됨. 대우 명제식이 참이므로, 본 명제 또한 **참**이다.

### 문제 2: p와 q가 명제이고 p → q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?
* **p → q가 거짓이기 위해선 p 참, q 거짓인 경우임.**

1. `~p → q`: `~p`는 거짓, `q`도 거짓이므로 조건 명제는 **참**.
2. `p V q`: `p`는 참이므로 **참**.
3. `q → p`: `q`는 거짓, `p`는 참이므로 **참**.


### 문제 3: 다음 명제들의 역, 이, 대우를 쓰시오

---

**① 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.**

* **역**: 만약 미국에서 2080년 월드컵이 열린다면, 0이 홀수이다.
* **이**: 만약 0이 짝수라면, 미국에서 2080년 월드컵이 열리지 않는다.
* **대우**: 만약 미국에서 2080년 월드컵이 열리지 않는다면, 0은 짝수이다.

---

**② 만약 19893827938274839이 Prime Number라면, 2는 짝수이다.**

* **역**: 만약 2가 짝수이면 19893827938274839이 Prime Number 이다.
* **이**: 만약 19893827938274839이 Prime Number가 아니라면 2는 홀수이다.
* **대우**: 만약 2가 홀수이면 19893827938274839이 Prime Number가 아니다.

### 문제 4: 다음 명제식의 진리표를 만드시오 (풀이 1)

**① p∧(q→~p)**

| p | q | ~p | (q→~p) | p∧(q→~p) |
|---|---|---|---|---|
| T | T | F | F | F |
| T | F | F | T | T |
| F | T | T | T | F |
| F | F | T | T | F |

### 문제 4: 다음 명제식의 진리표를 만드시오 (풀이 2)

**② (p∧~q)→r**

| p | q | r | ~q | (p∧~q) | (p∧~q)→r |
|:---:|:---:|:---:|:---:|:---:|:---:|
| T | T | T | F | F | T |
| T | T | F | F | F | T |
| T | F | T | T | T | T |
| T | F | F | T | T | F |
| F | T | T | F | F | T |
| F | T | F | F | F | T |
| F | F | T | T | F | T |
| F | F | F | T | F | T |

### 증명

* **직접 증명**
  * `p → q`가 참임을 증명하기 위해 p를 참으로 가정했을 때 q도 참임을 증명하는 방법임.
  * Trivial Proof(자명 증명)
  * Vacuous Proof(공허한 증명)

* **간접 증명**
  * 증명해야 하는 명제를 변형하여 증명하는 방법임.
  * 대우에 의한 증명
  * 모순에 의한 증명

* **수학적 귀납법**
  * 일정한 규칙을 나타내는 명제 `P(n)`이 성립함을 증명하는 방법임.



### Trivial Proof: ∀x, P(x)→Q(x)를 증명하려는데, Q(x)가 항상 참인 경우
- 다음 명제를 증명하시오.

∀ : 모든 ~에 대해서 (For ALL)
∃ : 어떤 ~가 존재함 (There Exists)

---

**① 실수 x에 대해, 만약 x<-1이면 x² + ¼ > 0이다.**
* `x² + ¼ > 0` 이고, `x² > -¼` 이며, `x`는 실수이므로 `Q(x)`는 항상 참임.
* 따라서 ∀x, `P(x)→Q(x)`이다.

---

**② n이 홀수이면 4n³ + 6n² + 12는 짝수이다.**
* `4n³ + 6n² + 12 = 2(2n³+3n²+6)` 이므로 `4n³ + 6n² + 12`는 짝수임.
* 그러므로 `Q(x)`는 항상 참임.
* 따라서 ∀x, `P(x)→Q(x)`이다.

### Vacuous Proof: ∀x, P(x)→Q(x)를 증명하려는데, P(x)가 항상 거짓인 경우
- 다음 명제를 증명하시오.

---

**① 실수 x에 대해, 만약 2x²-4x+4<0이면 x>8이다.**
* `2x²-4x+4 = 2(x²-2x)+4 = 2(x-1)²+2` 이고, `2(x-1)²+2≥0` 이다.
* 따라서 `2x²-4x+4<0`은 거짓이다.
* 그렇기 때문에 `P(x)`는 거짓이므로 해당 명제 ∀x, `P(x)→Q(x)`는 참이다.

---

**② 4n³+6n²+11는 짝수이면 n이 홀수이다.**
* `4n³+6n²+11 = 2(2n³+3n²+5)+1` 이므로 `4n³+6n²+11`은 홀수이다.
* 그러므로 `P(x)`는 거짓이므로 해당 명제 ∀x, `P(x)→Q(x)`는 참이다.


### 수학적 귀납법과 증명의 수준

  - 0보다 크거나 같은 정수 범위에 대해 `P(n)`이 성립함을 증명함.

  - 수학적 귀납법의 기본형: `P(1)`이 참이고, `P(n)→P(n+1)`이 참이면 `P(n)`은 모든 자연수 `n`에 대해 참임.

  - 수학적 귀납법의 강한 형태: `P(1)`이 참이고, `P(1)∧P(2)∧···∧P(n)→P(n+1)`이 참이면 `P(n)`은 모든 자연수 `n`에 대해서 참임.

  - 다음 함수가 1부터 `x`까지의 합을 계산함을 증명한다면

<!-- end list -->

```python
def sum(x):
    if (x <= 0):
        return 0
    return x + sum(x-1)
```

### 수학적 귀납법과 증명의 수준

  * 상세한 증명을 하려면 단순히 "답이 맞는 것이 당연하다"라고 말하는 것으로는 충분하지 않음.
  * 증명이 가능한 명제를 만들어야 함.
  * 이 경우 증명이 가능한 명제는 다음과 같음: "`sum(x)`가 리턴하는 값은 `1+2+···+x`의 값과 항상 같다"
  * 이제 수학적 귀납법을 적용할 수 있음.
  * `P(1)`이 참이다: "`sum(1)`이 리턴하는 값은 `1`이다"를 증명하면 됨. 실제 코드에 1을 대입하면 1을 리턴함을 알 수 있음.

<!-- end list -->

```
sum(1)
if (x <= 0) return 0
return 1 + sum(0)
```

### 수학적 귀납법과 증명의 수준

  * 임의의 값 `k`에 대해 `P(k)`가 참이라고 가정함: `sum(k)`가 `1+2+...+k`를 리턴함.
  * `k+1`에 대해 `P(k+1)`이 참이라고 증명함.

<!-- end list -->

```
sum(k+1)
if (k+1 <= 0) return 0
return k+1 + sum(k)
```

  * `sum(k)`는 `1+2+...+k`라고 가정했으므로, `sum(k+1) = 1+2+...+k+k+1`을 리턴함. `P(k+1)`이 참.
  * 따라서 `sum(x)`는 1에서 x까지의 합을 리턴함.

## 논리와 증명
### 문제 1: 다음 명제들이 항진명제라는 것을 진리표를 이용해서 보이시오

* **항진명제**: 명제의 진릿값과 무관하게 항상 참인 명제

---

**① `~( ~p ∧ q ) ∨ q`**

| p | q | ~p | (~p ∧ q) | ~(~p ∧ q) | ~(~p ∧ q) ∨ q |
|:---:|:---:|:---:|:---:|:---:|:---:|
| T | T | F | F | T | T |
| T | F | F | F | T | T |
| F | T | T | T | F | T |
| F | F | T | F | T | T |


### 문제 1: 다음 명제들이 항진명제라는 것을 진리표를 이용해서 보이시오

**② (~p∨q)∨(p∧~q)**

| p | q | ~p | ~q | (~p∨q) | (p∧~q) | (~p∨q)∨(p∧~q) |
|---|---|---|---|---|---|---|
| T | T | F | F | T | F | T |
| T | F | F | T | F | T | T |
| F | T | T | F | T | F | T |
| F | F | T | T | T | F | T |


### 문제 2: 다음 명제들이 모순명제라는 것을 진리표를 이용해서 보이시오

* **모순명제**: 명제의 진릿값과 무관하게 항상 거짓인 명제

---

**② (p∧q)∧(p∧~q)**

| p | q | (p∧q) | ~q | (p∧~q) | (p∧q)∧(p∧~q) |
|---|---|---|---|---|---|
| T | T | T | F | F | F |
| T | F | F | T | T | F |
| F | T | F | F | F | F |
| F | F | F | T | F | F |

### 문제 3: 다음 명제의 쌍 들에 대해서 두 명제가 동등한지를 진리표를 이용해 확인하시오

**① `p∧(p∨q)`와 `p`**

| p | q | (p∨q) | p∧(p∨q) |
|:---:|:---:|:---:|:---:|
| T | T | T | T |
| T | F | T | T |
| F | T | T | F |
| F | F | F | F |

`p`와 `p∧(p∨q)`의 열이 동일하므로 두 명제는 동등함.


### 문제 3: 다음 명제의 쌍 들에 대해서 두 명제가 동등한지를 진리표를 이용해 확인하시오

**② `~p∨~q`와 `~(p∨q)`**

| p | q | ~p | ~q | ~p∨~q | (p∨q) | ~(p∨q) |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| T | T | F | F | F | T | F |
| T | F | F | T | T | T | F |
| F | T | T | F | T | T | F |
| F | F | T | T | T | F | T |

`~p∨~q`와 `~(p∨q)`의 열이 다르므로 두 명제는 동등하지 않음.

### 문제 4: 명제식의 변형을 통하여 다음 명제를 간소화 하시오

**① (p∧~q)∨(p∧q)**
`(p∧~q)∨(p∧q) = p∧(~q∨q) = p∧U = p` (`U`는 항진명제)

**② (p∨~q)∧(~p∨~q)**
`(p∨~q)∧(~p∨~q) = (~q∨p)∧(~q∨~p) = ~q∨(p∧~p) = ~q∨∅ = ~q` (`∅`는 모순 명제)


### 문제 5: 다음 명제들이 참인지 거짓인지 확인하시오 (단, R은 실수의 집합, Z는 정수의 집합)

**① ∀x∈R, x² ≥ x**
`x=1/2`일 때, `x² ≥ x`를 만족하지 않으므로 (반례) 명제는 **거짓**이다.

**② ∀x∈Z, x² ≥ x**
해당 명제를 만족하지 않는 `x`의 범위는 `0 < x < 1`인데, 해당 범위에는 정수 값이 존재하지 않는다. 다시 말해 모든 정수 `x`에 대해 부등식 `x² ≥ x`를 만족한다고 할 수 있다. 따라서 명제는 **참**이다.

### 문제 5: 다음 명제들이 참인지 거짓인지 확인하시오 (단, R은 실수의 집합, Z는 정수의 집합)

**③ ∃x∈R, x² < x**
- `x=1/2`일 때, `x² < x`를 만족함. (어떤 `x`가 존재) 따라서 ③ 명제는 **참**이다.

---

**④ ∃x∈Z, x² < x**
- `x² < x`, `x²-x < 0`, `x(x-1) < 0`이므로, 위 부등식의 해는 `0 < x < 1`이 됨. 이때, 해당 부등식 조건을 만족하는 어떤 정수도 존재하지 않음. 따라서 ④ 명제는 **거짓**이다.

### 문제 6: (직접 증명) $n$이 짝수이면 $3n+5$는 홀수임을 증명하라

- **힌트**: $n=2k$로 두고 $3n+5$가 2(어떤 정수)+1 형태로 표현될 수 있는가?

---

**Proof**

$n = 2k$일 때(k는 정수), $3n + 5 = 3*(2k) + 5 = 6k + 5 = 6k + 4 + 1 = 2*(3k + 2) + 1$
그러므로 $3n+5$는 홀수이다.

### 문제 7: $n$이 홀수이면 $n^2+n$은 짝수임을 증명하라

**Proof**

$n=2k+1$일 때 (k는 정수), $n^2+n=(2k+1)^2+(2k+1) = 4k^2+4k+1+2k+1 = 4k^2+6k+2 = 2(2k^2+3k+1)$
그러므로 $n^2+n$은 짝수이다.



---

### **문제 8: m이 짝수이고 n이 홀수이면 2m+3n은 홀수임을 증명하라**

---

**Proof)**

* m = 2k, n = 2l+1 일 때 (k, l은 정수),
* 2m + 3n = 2*(2k) + 3*(2l+1) = 4k + 6l + 3 = 2(2k + 3l + 1) + 1
* 그러므로 2m+3n은 홀수이다.

다음은 사진에서 추출한 텍스트입니다.

---

### **문제 9: (대우를 증명) 자연수 n에 대해, n²+5가 홀수이면 n은 짝수임을 증명하라**

---

**Proof)**

* 대우명제는, 'n이 홀수이면 n²+5은 짝수이다.'와 같다.
* n = 2k + 1일 때, n²+5 = (2k+1)²+5 = 4k²+4k+6 = 2(2k²+2k+3)
* 그러므로 n이 홀수이면 n²+5는 짝수이다.
* 대우 명제가 참이므로, 본 명제 또한 참이다.


### **문제 10: n²이 짝수이면 n은 짝수임을 증명하라**

---

**Proof)**

* 주어진 명제의 대우명제는, 'n이 홀수이면 n²이 홀수이다.'와 같다.
* n = 2k + 1 일 때, n² = (2k+1)² = 4k² + 4k + 1 = 2(2k² + 2k) + 1
* 그러므로 n이 홀수이면 n²이 홀수이다.
* 대우 명제가 참이므로, 본 명제 또한 참이다.

---

### **문제 11: (경우를 나누어 증명) 자연수 n에 대해 n²+5n+3은 항상 홀수임을 증명하라.**

---

**Proof)**

* **n이 짝수인 경우**
  * n = 2k (k>=1), n²+5n+3 = (2k)²+5(2k)+3 = 4k²+10k+3 = 2(2k²+5k+1)+1
  * 그러므로, n이 짝수인 경우 n²+5n+3은 항상 홀수이다.

* **n이 홀수인 경우**
  * n = 2k+1 (k>=0), n²+5n+3 = (2k+1)²+5(2k+1)+3 = 4k²+14k+9 = 2(2k²+7k+4)+1
  * 그러므로, n이 홀수인 경우 n²+5n+3은 항상 홀수이다.

* n이 짝수인 경우와 홀수인 경우 모두 n²+5n+3은 항상 홀수이므로, 자연수 n에 대해 n²+5n+3은 항상 홀수이다.


### **문제 12: n²이 3의 배수이면 n은 3의 배수임을 증명하라 (과제)**

## 수와 표현
### **약간의 설명**

---

* 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
* k개의 비트를 사용하면 0부터 2ᵏ-1까지 표현 가능
* 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 최대 2ᵏ 가지의 값을 표현하는 것이 가능
* 10진수로 k자리를 쓰면 0부터 10ᵏ-1까지 표현이 가능한 것과 완전히 동일한 과정
* 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
  * 2ᵏ-¹ ≥ n이 성립해야 합니다. -> 즉, 2ᵏ ≥ n+1
  * 같은 의미로, k ≥ log(n+1) -> 약 logn 비트가 필요합니다.
* x=logₙ과 2ˣ=n은 같은 말

---

### **log n 이란**

---

* 2의 몇 승이 n이 되는가의 답
* n을 표현하는 데 몇 비트가 필요한가의 답
* 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되는가의 답
* n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되는가에 대한 답
* x=log n일 때 x와 n을 비교하면 x가 더 작고, n이 커질수록 엄청나게 달라짐
  * 100자리 n은 읽을 수도 없을 정도로 큰 값이지만 x는 작은 값입니다.
* 컴퓨터 분야에서 로그의 밑은 항상 2

---

### **log n 이란**

---

* 32비트 컴퓨터의 주소 공간은 2³²= 약 40억 개
* n + (n/2 + n/2) + (n/4 + n/4 + n/4 + n/4) + ... + (1 + 1 + ...) ≒ nlogn
* n+n/2+n/4+...+1 ≒ 2n
* 위 두 식에서 항의 개수는 log n개.
  * 분모를 2ᵏ로 나타내면, 1 = n/2ᵏ, 2ᵏ = n 이므로 k = log n 입니다.


---

### **문제 1: 2진수 표현에서 log n 비트로 표현할 수 있는 숫자 범위는?**

---

* n비트로 표현할 수 있는 숫자는 2ⁿ가지
* log₂n 비트로 표현할 수 있는 숫자는 n가지

### **문제 2: 스무고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇 가지인가?**

---

* 2²⁰ = 1048576 가지

### **문제 3: n이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오**

---

* **① 2n < n²**
    * n > 2일 때 2n < n²이므로, 2보다 큰 모든 n에 대해 부등호가 항상 성립한다.

* **② 2ⁿ/² < √3ⁿ**
    * n > 0일 때 3ⁿ/² > 2ⁿ/²이 항상 성립하므로, 0보다 큰 모든 n에 대해 부등호가 항상 성립한다.

### **문제 3: n이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오**

---

* **③ 2ⁿˡᵒᵍⁿ > n!**
    * n > 1일 때, nⁿ > n! 이 항상 성립한다. 따라서 1보다 큰 모든 n에 대해 부등호가 항상 성립한다.
* **④ log 2²ⁿ < n√n**
    * n > 4일 때 2n < n³/²이 항상 성립한다. 따라서 4보다 큰 모든 n에 대해 부등호가 항상 성립한다.


### **문제 4: x=logₐyz일 때 x를 2를 밑으로 하는 로그들로 표현하시오. 단, 로그 함수의 인자는 모두 문자 하나여야 한다.**

---

* **로그의 성질에 대해 찾아볼 것**

$$x = \frac{\log_2 y + \log_2 z}{\log_2 a}$$


### **문제 5: 다음 함수들의 역함수를 구하시오**

---

* **① f(x)=log(x-3)-5**
  $$f(x) = \log(x-3)-5$$ $$2^{f(x)+5} = x-3$$ $$x = 2^{f(x)+5}+3$$ $$f^{-1}(x) = 2^{x+5}+3$$

* **② f(x)=3log(x+3)+1**
  $$f(x) = 3\log(x+3)+1$$ $$\frac{f(x)-1}{3} = \log(x+3)$$ $$2^{\frac{f(x)-1}{3}} = x+3$$ $$x = 2^{\frac{f(x)-1}{3}}-3$$ $$f^{-1}(x) = 2^{\frac{x-1}{3}}-3$$

* **③ f(x)=2x3ˣ-1**
  $$f(x) = 2 \times 3^x-1$$ $$f(x)+1 = 2 \times 3^x$$ $$\frac{f(x)+1}{2} = 3^x$$ $$x = \log_3(\frac{f(x)+1}{2})$$ $$x = \log_3(f(x)+1) - \log_3 2$$ $$f^{-1}(x) = \log_3(x+1) - \log_3 2$$


## 집합과 조합론 
### **집합과 조합론에 대한 약간의 설명**

---

* 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
* 예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면, 4k=2(2k)임을 보이면 되는 것이다.
* 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 된다.


### **다음 두 집합이 같다는 것을 상세히 증명**

---

* **A={x|x=2k+1,k는 자연수}, B={x|x=4k+1 혹은 x=4k+3,k는 자연수}**

* **A가 B의 부분집합이다:**
  * A에 포함되는 임의의 원소 x를 가정.
  * x=2k+1임.
  * k가 짝수인 경우(k=2t)와 홀수인 경우(k=2t+1)로 나눔.
  * **짝수인 경우** x=2k+1=2(2t)+1=4t+1로서, x는 B에 포함됨.
  * **홀수인 경우** x=2k+1=2(2t+1)+1=4t+3으로서, x는 B에 포함됨.
  * 모든 가능한 경우에 x는 B에 포함됨.

* **B가 A의 부분집합이다:**
  * B에 포함되는 임의의 원소 x를 가정.
  * x=4k+1인 경우, x=4k+1=2(2k)+1로서 x는 A에 포함됨. x=4k+3인 경우, x=4k+3=2(2k+1)+1로서 x는 A에 포함됨.
  * 모든 가능한 경우에 x는 B에 포함됨.

* 위 두 증명에서 집합 A와 B는 같다.

### **조합론**

---

* 조합론은 경우의 수를 따지는 문제들을 말함
* 조합의 개수는 C를 이용하여 C₂처럼 표현하기도 하지만 $\binom{5}{2}=10$과 같은 괄호 표현을 더 많이 씀

### **문제 1: $\binom{n}{k} + \binom{n}{k-1} = \binom{n+1}{k}$임을 증명하라**

---

**Proof)**

$$\binom{n}{k} + \binom{n}{k-1} = \frac{n!}{(n-k)!k!} + \frac{n!}{(n-(k-1))!(k-1)!}$$

$$= n! \left( \frac{1}{(n-k)!k!} + \frac{1}{(n-k+1)!(k-1)!} \right)$$

$$= n! \left( \frac{1}{(n-k)!k(k-1)!} + \frac{1}{(n-k+1)(n-k)!(k-1)!} \right)$$

$$= \frac{n!}{(n-k)!(k-1)!} \left( \frac{1}{k} + \frac{1}{n-k+1} \right)$$

$$= \frac{n!}{(n-k)!(k-1)!} \left( \frac{n-k+1+k}{k(n-k+1)} \right)$$

$$= \frac{n!}{(n-k)!(k-1)!} \left( \frac{n+1}{k(n-k+1)} \right)$$

$$= \frac{n!(n+1)}{(n-k+1)!(k-1)!k} = \frac{(n+1)!}{(n-k+1)!k!}$$

$$= \binom{n+1}{k}$$

### **문제 6: 8x8 체스 판에 말 두 개를 놓으려고 한다. 아무 곳에나 놓아도 되지만 한 칸에 두 개가 들어가지는 못한다. 가능한 방법은 모두 몇 가지인가?**

---

* 8x8 체스 판 중에서 두 곳을 고르는 조합을 구하는 문제이므로,
  $$\binom{64}{2} = \frac{64 \times 63}{2 \times 1} = 2,016$$
* 모두 2,016개가 존재한다.

### **문제 7: 비밀번호를 0부터 9까지의 숫자만 가지고 만든다고 하자. 4개 이상 6개 이하의 숫자를 쓸 수 있다고 할 때 가능한 비밀번호의 가지수는 얼마인가?**

---

* 가능한 비밀번호는 숫자가 4개, 5개, 6개가 들어갈 경우이다.
* **숫자가 6개 사용될 경우:** 10 × 9 × 8 × 7 × 6 × 5 = 151,200
* **숫자가 5개 사용될 경우:** 10 × 9 × 8 × 7 × 6 = 30,240
* **숫자가 4개 사용될 경우:** 10 × 9 × 8 × 7 = 5,040

따라서 총 가능한 비밀번호의 가지 수는 **186,480개**이다.


## 기초 수식
### **약간의 설명**

---

* 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재함
* 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 얼마나 걸릴지 예측할 수 있음
* 재귀식을 O() notation 수준으로 풀어보는 연습이 필요


### **문제 1: T(n)=T(n-1)+1, T(0) = 1**

---

* $$T(n) = T(n-1) + 1$$*$$= T(n-2) + 1 + 1$$*$$= T(n-k) + k$$*$$= T(0) + n, n==k$$*$$= 1+n$$*$$O(T(n)) = O(n)$$


### **약간의 설명**

-----

  * 재귀란 자기 자신을 호출하는 함수, 그럼 끝날 수가 있는가?
  * 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음
  * 하지만, 다른 입력으로 호출하면 끝날 수 있음

<!-- end list -->

```python
def abc(x):
  return abc(x)
# 이 함수는 안 끝남
```

```python
def sum(x):
  if (x <= 0):
    return 0
  return x + sum(x-1)
# 이 함수는 끝남. 결과 값은?
```

* 함수란 어떤 문제를 해결하는 방법을 코딩한 것
* 함수가 어떤 문제의 단 한 케이스만을 해결하는 것이 아님
* 제대로 코딩 된 것이라면 해결하는 문제의 모든 케이스들을 해결해야 함
* 수학적 귀납법 증명 사용 가능
  * (가) n이 0일 때 문제를 풀 수 있음
  * (나) n-1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있다
  * 위 두 가지가 사실이면 모든 가능한 n에 대해 문제를 풀 수 있다는 것이 사실

  * 위 박스의 함수 sum()을 보면 정확히 앞의 두 가지를 코딩한 것임
* 따라서, sum() 함수는 문제를 해결한다는 것을 증명할 수 있음
* 방금 보인 증명은 high-level 증명이며, 상세한 증명은 앞에서 본 적이 있음
* 어떤 미스터리한 이유로 문제가 해결되는 것은 아니고, 실제로 프로그램을 돌리면 필요한 계산이 다 일어남. 순차적인 코드에서 일어나는 계산과 완전히 동일. 다만 표현하는 방법이 달라진 것
* 다르게 생각하는 방법
  * 어떤 문제를 해결하려다 부분 문제를 만났는데, 원래 해결하려던 입력 케이스와 동일한 문제에 속하지만 "크기가 더 작은" 입력 케이스를 해결하는 것이 그 부분 문제였다!
  * 즉, 부분 문제가 동일한 문제인 경우!


## 동적 계획법
### **약간의 설명**

---

* 간단하게 설명하면 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것임 (**Memoization**)
* 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 함
* 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과 값을 순서를 정해서 계산할 수 있음 (**Dynamic Programming**)
* 동적 계획법 알고리즘을 슈도코드로 작성하고, 정확성 증명 및 시간 복잡도를 계산하는 연습이 필요함

