# 분할 정복

## 목 차
### 분할 정복
* 분할 정복 기법
* 병합 정렬
* 퀵 정렬
* 이진 검색

## 분할 정복
문제를 작은 하위 문제로 나누고(분할) 각각을 해결(정복)한 뒤, 그 결과를 결합(통합)하여 원래 문제를 해결하는 알고리즘 기법

## 목차
### 분할 정복
* 분할 정복 기법
* 병합 정렬
* 퀵 정렬
* 이진 검색

***

## 분할 정복
문제를 작은 하위 문제로 나누고(분할) 각각을 해결(정복)한 뒤, 그 결과를 결합(통합)하여 원래 문제를 해결하는 알고리즘 기법

***

## 분할 정복 기법의 유래
* 1805년 12월 2일 아우스터리츠 전투에서 나폴레옹이 사용한 전략
* 전력이 우세한 연합군을 공격하기 위해 나폴레옹은 연합군의 중앙부로 쳐들어가 연합군을 둘로 나눔
* 둘로 나뉜 연합군을 한 부분씩 격파함

## 분할 정복 기법의 설계 전략
* 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눔
* 정복(Conquer): 나눈 작은 문제를 각각 해결
* 통합(Combine): (필요하다면) 해결된 답을 모음


## 분할 정복 기법의 구조
* Top-down approach 예시

|과정|내용|
|---|---|
|**문제의 크기**|n|
|**분할**|크기 n/2인 부분 문제 1, 크기 n/2인 부분 문제 2|
|**정복**|부분 문제 1의 해, 부분 문제 2의 해|
|**결합**|전체 문제의 해|


## 분할 정복 기법의 예시 - 거듭 제곱

  * 분할 정복 기반의 알고리즘: O(log₂n)

<!-- end list -->

```
Cⁿ = {
    Cⁿ/² * Cⁿ/²   n은 짝수
    C⁽ⁿ⁻¹⁾/² * C⁽ⁿ⁻¹⁾/² * C  n은 홀수
}
```

$C^8$ = C \* C \* C \* C \* C \* C \* C \* C
$C^8$ = C⁴ \* C⁴ = ($C^4$)$^2$ = (($C^2$)$^2$)$^2$

...

$C^n$ = $C^{(n-1)/2}$ \* $C^{(n-1)/2}$ \* C = ($C^{(n-1)/2}$)$^2$ \* C

```
Recursive_Power(x, n)
  IF n == 1 : RETURN x
  IF n is even
    y ← Recursive_Power(x, n/2)
    RETURN y * y
  ELSE
    y ← Recursive_Power(x, (n-1)/2)
    RETURN y * y * x
```

## 병합 정렬
Merge Sort

여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

## 병합 정렬 과정
* 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻음
* top-down 방식

***

## 시간 복잡도
* O(n log n)


## 병합 정렬 과정 예시

• {69, 10, 30, 2, 16, 8, 31, 22}를 병합 정렬하는 과정

**분할 단계: 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속한다.**

```
69  10  30   2  16   8  31  22
```

↓

```
69  10  30   2        16   8  31  22
```

↓

```
69  10      30   2        16   8      31  22
```

↓

```
69   10     30    2       16    8     31   22
```

## 병합 정렬 과정 예시

• {69, 10, 30, 2, 16, 8, 31, 22}를 병합 정렬하는 과정

**병합 단계: 2개의 부분집합을 정렬하면서 하나의 집합으로 병합. 8개의 부분집합이 1개로 병합될 때까지 반복**

```
69    10    30     2    16     8    31    22
```

↓

```
10  69     2  30      8  16     22  31
```

↓

```
2  10  30  69         8  16  22  31
```

↓

```
2   8  10  16  22  30  31  69
```

## 병합 정렬 알고리즘

```python
# 1. 분할
# 2. 정복 & 병합(정렬)

#병합 정렬 알고리즘
def merge(left, right):
    # 두 리스트를 병합한 결과 리스트
    result = [0] * (len(left) + len(right))
    l = r = 0   #인덱스

    # 두 리스트에서 비교할 대상이 남아있을 때까지 반복
    while l < len(left) and r < len(right):
        if left[l] < right[r]:
            result[l + r] = left[l]
            l += 1

        else:
            result[l + r] = right[r]
            r += 1

    while l < len(left):
        #왼쪽 리스트에 남은거 모두 result에 추가
        result[l + r] = left[l]
        l += 1

    while r < len(right):
        result[l + r] = right[r]
        r += 1

    return result


def merge_sort(li):
    if len(li) == 1:
        return li
    
    #절반씩 분할하여 출력
    mid = len(li) // 2
    left = li[:mid]
    right = li[mid:]

    left_list = merge_sort(left)
    right_list = merge_sort(right)

    merge_list = merge(left_list, right_list)
    return merge_list

arr = [69, 10, 30, 2, 16, 8, 31, 22, 23]
sorted_arr = merge_sort(arr)
print(sorted_arr)
```

## 퀵 정렬
Quick Sort

기준값을 중심으로 주어진 배열을 두 개로 분할하고, 각각을 정렬하여 전체 배열을 정렬하는 방식

## 병합 정렬과 퀵 정렬의 차이

| | 병합 정렬 | 퀵 정렬 |
|---|---|---|
| **분할 기준** | 단순히 배열을 반으로 나눔 | 기준 아이템(pivot item)을 중심으로 기준보다 작은 것을 왼편, 큰 것을 오른편에 위치시킴 |
| **병합 처리** | 정렬된 부분을 다시 병합하는 과정이 필요 | 별도의 병합 과정 불필요 |

***

## 시간 복잡도
* 평균 시간 복잡도 O(nlogn)
* Partitioning이라는 과정을 반복하면서, 빠른 속도로 정렬이 되는 알고리즘

## Partitioning
1.  작업 영역을 정함.
2.  작업 영역 중 가장 왼쪽에 있는 수를 **Pivot**이라 하자. (Pivot을 “기준”으로 해석)
3.  Pivot을 기준으로
    * 왼쪽에 Pivot보다 작은 수를 배치 (정렬 아님)
    * 오른쪽에 Pivot보다 큰 수를 배치 (정렬 아님)

- 파티셔닝이 끝나고 Pivot의 위치는 확정(Fix)됨
- 즉, 정렬이 다 되었을 때에도 Pivot의 위치는 그대로 배정됨
- 한 번의 파티셔닝 이후, 왼쪽과 오른쪽 부분 배열에 대해 재귀적으로 파티셔닝을 반복하여 정렬을 진행

### Hoare-Partition
1. pivot 하나 정함
2. pivot 다음 인덱스를 i, 끝 인덱스를 j로
3. i를 증가시킴 -> 피봇보다 큰 값 찾음
4. j를 증가시킴 -> 피봇보다 작은 값 찾음
5. 서로 교환
6. 언젠가 i j 교차하며 끝날 것
7. pivot을 피봇보다 작은 값 찾은 것과 교환


### Lomuto Partition
1. 맨 오른쪽을 pivot으로 정함
2. i, j는 0번 인덱스부터 시작
3. i, j 같이 가다가 i는 pivot보다 큰 수를 만나면 멈춤
4. j는 pivot보다 작은 수를 만나면 멈춤
5. i, j에 해당하는 값 스왑
6. j가 pivot까지 간 후 pivot과 i+1에 해당하는 값 스왑

>> 대부분의 상황에서 Hoare Partition이 좋으니 Lomuto는 참고용으로만 알아두기

파티셔닝 기법 2가지(호어, 로무토)
-퀵 정렬
 - 평균 속도 : O(N log N)
 - 최악의 경우 : O(N ^ 2) >> 역순 정렬 되어있는 경우

- 데이터가 많을수록 역순 정렬 되어있지 않을 확률 높으므로 유리함

## 코드 예시

```python
# 퀵 정렬

# 피봇 : 제일 왼쪽 요소
# 이미 정렬된 배열이나 역순 정렬된 배열에서 최악의 성능

def hoare_partition1(left, right):
    pivot = arr[left] # 피벗을 제일 왼쪽 요소로 설정
    i = left + 1
    j = right 

    while i <= j:   #교차가 되면 끝
        while i <= j and arr[i] <= pivot:   #i는 pivot 보다 큰 값을 검색
            i += 1

        while i <= and arr[j] >= pivot: #j는 피벗보다 작은 값 검색
            j -= 1

        if i < j: #swap 
            arr[i], arr[j] = arr[j], arr[i]

    #피벗과 j위치를 swap
    arr[left], arr[j] = arr[j], arr[left]
    return j

def quick_sort(arr, left, right):
    if left < right:
        pivot_pos = hoare_partition1(arr, left, right)
        quick_sort(arr, left, pivot_pos - 1)
        quick_sort(arr, pivot_pos + 1, right)

number = [64, 34, 25, 12, 22, 11, 90]
quick_sort(number, 0, len(number) - 1)
print(number)

```




## 이진 검색
Binary Search

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

* **목표 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행**함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행

## 이진 검색의 과정
1.  자료의 중앙에 있는 원소를 고름
2.  중앙 원소의 값과 찾고자 하는 목표 값을 비교함
3.  목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행함
4.  찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복함

* 이진 검색을 하기 위해서는 자료가 **정렬된 상태**여야 함


## 분할 정복 알고리즘 정리
* 병합 정렬
  * 외부 정렬(External Sort)의 기본이 되는 정렬 알고리즘
  * 멀티코어(Multi-Core) CPU나 다수의 프로세서에서 정렬 알고리즘을 병렬화하기 위해 병합 정렬 알고리즘이 활용

* 퀵 정렬
  * 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘

* 이진 검색
  * 정렬된 데이터를 기준으로 특정 값이나 범위를 검색하는 데 사용
  * [이진 검색을 활용한 심화 학습 키워드] Lower Bound, Upper Bound
    * 정렬된 배열에서 특정 값 이상(이하)가 처음으로 나타나는 위치를 찾는 알고리즘
    * 특정 데이터의 범위 검색 등에 활용


## 코드 예시

```python
#이진 탐색

def binary_search_while(target):
    left = 0
    right = len(arr) - 1
    cnt = 0 
    #left right가 교차될때까지 반복
    while left <= right:
        mid = (left + right) // 2
        cnt += 1

        if arr[mid] == target:
            return mid, cnt  #mid위치에 존재한다고 return
        
        # target보다 정답이 왼쪽에 있는 경우
        if arr[mid] > target:
            right = mid - 1 #mid를 포함 안하는 코드

        # target보다 정답이 오른쪽에 있는 경우
        if arr[mid] < target:
            left = mid + 1
    return -1, cnt


def binary_search_recur(left, right, target):
    if left > right:
        return -1
    
    mid = (left + right) // 2
    #검색하면 종료
    if target == arr[mid]:
        return mid

    if target < arr[mid]:
        return binary_search_recur(left, mid - 1, target)
    
    else:
        return binary_search_recur(mid + 1, right, target)
    

arr = [4, 2, 9, 7, 11, 23, 19]

# 이진 검색은 항상 정렬된 데이터에 적용
arr.sort()

binary_search_while(9)
#mid 를 찾으려면 left랑 right있으면 편함 

```
